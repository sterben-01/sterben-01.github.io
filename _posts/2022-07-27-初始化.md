---
title: 初始化
date: 2022-07-20 01:55:00 -0500
categories: [笔记]
tags: [C++]
pin: false
author: 01

toc: true
comments: true
typora-root-url: ../../Sterben-01.github.io
math: false
mermaid: true
  
---

# 聚合初始化

> 从 初始化器列表初始化聚合体。是[列表初始化](https://zh.cppreference.com/w/cpp/language/list_initialization)的一种形式。

`(aggregate initialization)`。聚合类型可以进行直接列表初始化。**没有构造函数也可以初始化其中的参数**。但是聚合类型有如下限制

> ## [聚合](https://en.cppreference.com/w/cpp/language/aggregate_initialization.html)（Aggregate）
>
> **聚合**属于以下类型之一：
>
> - **数组类型**（array types）
> - **类类型**，并满足下列条件：
>   - **没有用户声明的构造函数**（no user-declared constructors）
>      （至 C++11 之前）
>   - **没有用户提供的、继承的或显式的构造函数**（no user-provided, inherited, or explicit constructors）
>      （自 C++11 起，至 C++20 之前）
>   - **没有用户声明或继承的构造函数**（no user-declared or inherited constructors）
>      （自 C++20 起）
>   - **没有私有或受保护的直接非静态数据成员**（no private or protected direct non-static data members）
>   - **没有基类**（no base classes）
>      （至 C++17 之前）
>   - **没有虚拟基类**（no virtual base classes）
>   - **没有私有或受保护的直接基类**（no private or protected direct base classes）
>      （自 C++17 起）
>   - **没有虚成员函数**（no virtual member functions）
>   - **没有默认成员初始化器**（no default member initializers）
>      （自 C++11 起，至 C++14 之前）
>
> ## 元素（Element）
>
> **聚合的元素**为：
>
> - 对于**数组**：按下标递增顺序的数组元素。
> - 对于**类**：
>   - **至 C++17 之前**：按声明顺序的**非静态数据成员**（不包括匿名位域，anonymous bit-fields）。
>   - **自 C++17 起**：先是按声明顺序的**直接基类**，随后是按声明顺序的**直接非静态数据成员**，且这些成员**既不是匿名位域，也不是匿名联合（anonymous union）的成员**。

```c++
class test{
    public:
    struct obj{
        int _objval;
    };
    int _val;
    obj inclass_obj;
    test(int x, int y): _val(x), inclass_obj._objval(y){} // 错误。这是构造函数初始化列表。用来初始化的。这里的inclass_obj._objval(y)是赋值操作。不允许。详细说就是，初始化列表只能初始化对象。这里是给一个对象的某个变量赋值。这是错误的。
    test(int x, int y): _val(x), inclass_obj(y){} 	// 错误 obj类没有有参构造函数。
    test(int x, int y): _val(x), inclass_obj(){} 	// 可以 obj类有默认无参构造函数。
    test(int x, int y): _val(x), inclass_obj{y}{} 	// 可以 这里的inclass_obj{y}叫做聚合初始化。注意后面的{}是test构造函数的{}。不要搞混
    
};
```

针对第一行错误代码，我们可以让`obj`自带一个有参构造。然后使用有参构造对`obj`进行初始化。

- 这东西真正牛逼的在这呢。如果聚合体中间有嵌套，你可以不用使用花 括号分割


```c++
struct Aggregate {
    int arr[4];
    int j;
};
int main(){
    Aggregate aggr = {1, 2, 3, 4, 5};
}
```

## 聚合初始化的例子 和 构造函数的重载决议

看一段代码

```c++
struct A1{
    explicit A1(int x = 10) : x_(x) {}
    int x_;
};


struct B{
    B() = default;
    A1 a;
};


int main(){
    B b;
    return 0;
}

```

这样都正常，但是如果我们给`B b`换成：

```c++
B b = B{};
B b = {};
B b{B{}};
```

会提示：

```c++
<source>: In function 'int main()':
<source>:19:13: warning: converting to 'A1' from initializer list would use explicit constructor 'A1::A1(int)'
   19 |     B b = B{};
      |             ^
<source>:7:14: note: 'A1::A1(int)' declared here
    7 |     explicit A1(int x = 10) : x_(x) {}
      |              ^~
<source>:19:13: note: in C++11 and above a default constructor can be explicit
   19 |     B b = B{};
      |             ^
ASM generation compiler returned: 0
<source>: In function 'int main()':
<source>:19:13: warning: converting to 'A1' from initializer list would use explicit constructor 'A1::A1(int)'
   19 |     B b = B{};
      |             ^
<source>:7:14: note: 'A1::A1(int)' declared here
    7 |     explicit A1(int x = 10) : x_(x) {}
      |              ^~
<source>:19:13: note: in C++11 and above a default constructor can be explicit
   19 |     B b = B{};
      |             ^
Execution build compiler returned: 0
```

为啥呢？我们先看一下[聚合初始化的细节](https://en.cppreference.com/w/cpp/language/aggregate_initialization.html) (简略版)：

> 1. 先确定聚合中**被显式初始化的元素**
>
> 2. 被显示初始化的元素规则...[此处不展开]
>
> 3. **被隐式初始化的元素**规则：
>
>    1. 对于**非 union 的聚合**，每个**未被显式初始化**的元素按如下方式初始化：
>
>       - 如果该元素有**默认成员初始化器**（default member initializer），则从该初始化器进行初始化。（自 C++11 起）
>       - 否则，如果该元素**不是引用**，则从一个**空的初始化列表**进行拷贝初始化。（the element is [copy-initialized](https://en.cppreference.com/w/cpp/language/copy_initialization.html) from an empty initializer list.）
>       - 否则（即该元素是引用且没有默认成员初始化器），程序是不良形式。
>
>    2. 如果聚合是一个 `union` 且初始化列表**为空**，则：
>
>       - 如果有任何变体成员具有默认成员初始化器，则该成员由其默认成员初始化器进行初始化。（自 C++11 起）
>       - 否则，`union` 的**第一个成员**（如果有）从一个**空初始化列表**进行拷贝初始化。（the element is [copy-initialized](https://en.cppreference.com/w/cpp/language/copy_initialization.html) from an empty initializer list.）
>

所以我们的代码

```c++
B b = B{};
```

因为我们没有显式初始化`A1`，且`A1`不是引用，所以`A1`是从一个**空初始化列表**进行拷贝初始化（复制列表初始化）

所以就是

```c++
A1 a = {};
```

这个地方意味着a是被值初始化。我们查看值初始化的定义，发现a会被默认初始化。这里会尝试找到最匹配的构造函数。但是我们在构造函数重载决议中找到了这一点：

> #### 通过构造函数初始化
>
> 当类类型的对象被[直接初始化](https://en.cppreference.com/w/cpp/language/direct_initialization.html)或[默认初始化（包括](https://en.cppreference.com/w/cpp/language/default_initialization.html)[复制列表](https://en.cppreference.com/w/cpp/language/list_initialization.html)初始化上下文中的默认初始化）(C++11 起)时，候选函数均为被初始化类的构造函数。参数列表为初始化器的表达式列表。
>
> 否则，候选函数均为被初始化类的[转换构造函数](https://en.cppreference.com/w/cpp/language/converting_constructor.html)。参数列表为初始化器的表达式。
>
> **对于复制列表初始化上下文中的默认初始化，如果选择到了explicit标记的构造函数，则初始化格式不正确。**（自 C++11 起）

所以我们发现

```c++
A1 a = {};
```

这个代码格式不正确，所以有问题。

来自[这里](https://stackoverflow.com/questions/72712318/converting-to-a-from-initializer-list-would-use-explicit-constructor-aaint)







# 列表初始化（花/大括号初始化）

> 从 *花括号初始化器列表* 列表初始化对象。

**带等号和不带等号一般不做区分。`int c{5};`是直接列表初始化 ，`int d = {5};`是拷贝列表初始化。 两种形式一般不做区分。**

首先第一点：c++不允许在一个类内使用圆括号初始化另一个类。

```c++
class test{
    int a = 5; 	//拷贝初始化 OK
    int b(5); 	//直接初始化。ERROR。
    int c{5};	//默认类型使用的列表初始化。其实还是调用了对应的构造函数进行了直接初始化。也叫直接列表初始化
    int d = {5}; //和上面那种一般不做区分。一般也不用。但是这个叫做拷贝列表初始化。
};
```



```c++
class test{
    int test_val1;
    int test_val2;
    public:
    test(int x, int y):test_val1(x), test_val2(y){};
    struct obj{
        int _objval;
        int _faf;
        obj(){}
        obj(int x): _objval(x){}		//注意我们obj有自定义构造函数。所以不是聚合体。
    };
    obj inclass_obj1; 		//obj对象使用无参构造函数
    obj inclass_obj2(); 	//这是返回obj类型的函数
    obj inclass_obj3(5); 	//这里表面是使用了obj的有参构造，但是不允许这种行为。因为有二义性。编译器认为这是个返回obj类型的形参为5的函数。但是形参为5是啥玩意？所以一个类内不允许使用圆括号初始化另一个类。也就是不允许使用直接初始化
    //替代方案：
    obj inclass_obj4 = {test_val1}; // 列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造  //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj5{test_val2}; //列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造 //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数
    obj inclass_obj6 = 5; //该处的初始化方式是隐式调用obj(int)构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化。
    obj inclass_obj7 = obj(5); //显式调用有参构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化 OK

};
```

# 为什么使用列表初始化？

1. 可以使用初始化列表接受任意长度。不想细说了，查查就可以。用得少。除了容器类。

2. 所有场合都可用，比如：

   - 它能表达一组值，来初始化STL容器：

    ```c++
     std::vector<int> v{1, 3, 5};
     std::vector<int> v = {1, 3, 5}; //当然这也可以。
    ```

   - 它能用来给类的非static成员设定默认值（而`()`就不行）上面提到了。：

   ```c++
   class Widget {
   ...
   private:
       int x{0};   // 可以
       int y = 0;  // 可以
       int z(0);   // 不行
   };
   ```

   - 它和`()`都能用于初始化一个uncopyable的对象（而`=`就不行）：

   ```c++
   std::atomic<int> ai1{0};   // 可以
   std::atomic<int> ai2(0);   // 可以
   std::atomic<int> ai3 = 0;  // 不行
   ```

   - 包括替换`make_pair`

   ```c++
   unordered_map<int, int> my_map;
   my_map.insert(make_pair<int, int>(5,10)); //使用make_pair
   my_map.insert({10,20}); //使用uniform_initialization
   ```

   

3. 使用列表初始化初始**内置类型**的变量时，防止类型窄化，避免精度丢失的隐式类型转换。

   ```c++
   int b = 4.4;		//可以。隐式类型转换。
   int c = {5.5};		//不可以，列表初始化防止隐式转换带来的窄化。
   int d{6.6};			//不可以，列表初始化防止隐式转换带来的窄化。
   ```

   什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：

   - 从浮点类型到整数类型的转换
   - 从 `long double` 到 `double`或 `float` 的转换，以及从 `double` 到 `float` 的转换，除非源是常量表达式且不发生溢出
   - 从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式
   - 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式

4. 它不会被认为是声明。
   - C++中规定“所有看起来像声明的语句都会被视为声明”，这导致`()`在一些场景下会被视为函数声明，而`{}`则不会
```c++
Widget w1(10);      // 调用有参构造。
Widget w2();        // 声明了一个无参，名为w2返回Widget的函数
Widget w3{};        // 调用无参构造


template<typename T>
void foo(){
    T x1(); 	//这是函数声明。声明了一个无参，叫x，返回T的函数
    T x2 = T();	//初始化x2，但是看起来不像是赋值。
    T x3{};		//看起来非常好。
}
```

# 为什么不使用列表初始化？

- 在类有`std::initializer_list`参数的构造函数时，`{}`会有麻烦：`{}`总会被认为是`std::initializer_list`，即使解析出错。
- `auto`会把列表初始化的型别推导为`std::initializer_list`, 值是`{}`内的内容。
  - 参见下方`i11`
  - 注意区别`i12`

- 一个有趣的地方：如果`{}`中没有元素，那么被调用的是默认构造函数，而不是一个空的`std::initializer_list`。如果你真的想传入一个空的`std::initializer_list`，那么这样：

```c++
Widget w4({});
Widget w5{{}};
```

- `std::vector<int>`会有二义性。我们有

```c++
std::vector<int> v1(10, 20);   //使用普通构造函数创建vector，里面有10个元素，初始值为20.
std::vector<int> v2{10, 20};   // 使用初始化列表构造函数，创建一个有两个元素的vector，元素分别为10和20
```

- 同样的情况存在于使用`make`方法进行智能指针的创建之时。`make`方法无法使用列表初始化



# 看一点有意思的事情

```c++
int i1;				//未定义值。undefined value
int i2 = 42;		//拷贝初始化 使用42
int i3(42);			//直接初始化 使用42
int i4 = int();		//拷贝初始化 使用0（默认值）
int i5{42};			//直接列表初始化 使用42
int i6{};			//直接列表初始化 使用0（默认值）
int i7 = {42};		//拷贝列表初始化 使用42
int i8 = {};		//拷贝列表初始化 使用0 （默认值）

auto i9 = 42;  		//使用42初始化，推导为int
auto i10{42};		//使用42初始化，推导为int。[除旧编译器外]
auto i11 = {42};	//使用42初始化std::initializer_list<int>。推导为std::initializer_list<int>
auto i12 = int{42};	//使用42初始化的int来初始化i12, 推导为int

int i13();			//这是函数声明
int i14(7,9);		//这是编译时错误
int i15 = (7,9);	//使用9。这是使用了逗号运算符。
int i16 = int(7,9);	//这是编译时错误

auto i17(7,9);		//这是编译时错误
auto i18 = (7,9);	//使用9，这是使用了逗号运算符。
auto i19 = int(7,9);//这是编译时错误。


//针对不可拷贝和/或不可移动的类型，在C++17以前 如下是不允许的
auto a = std::atomic<int>{9}; //不可拷贝，C++14编译错误。使用了已删除的拷贝构造函数。但是C++17使用了复制省略技术，可以通过编译。

```

- 逗号运算符
  - 整个逗号表达式的值为系列中最后一个表达式的值。
  - 从本质上讲，逗号的作用是将一系列运算按顺序执行。
- 视频中建议不要使用`()`进行初始化。尽可能使用花括号`{}`
- `i10`的原始语义是使用42初始化一个`std::initializer_list<int>`。已在C++14中修复。
- 注意`i11`的等号改变了`auto`推导的类型。初始化阶段使用等号可能会改变变量的类型。
- 剩余auto解释参见杂记3.

## C++17 复制省略技术

参见杂记3

# std::initializer_list

参见杂记3



# 初始化和赋值的区别

- 当对象在创建时获得了一个特定的值，我们说这个对象被**初始化（initialized）**。

- 而赋值的含义是把对象的当前值擦除，而以一个新值来替代。
- 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值

# 初始化器

看下面的几种初始化之前先看这个

https://zh.cppreference.com/w/cpp/language/initialization

# 默认初始化 default initialization

```c++
T 对象 //当不带初始化器而声明具有自动、静态或线程局部存储期的变量时；
new T //当以不带初始化器的 new 表达式创建具有动态存储期的对象时
```

如`[new] T object;`这样的都叫做默认（缺省）初始化。比如：

- `int a`;
- `double b`;
- `bool c`;
- ...

当我们不使用初始化器的时候，就会自动被编译器调用这种方式初始化。但是它有个问题。在不是类类型的时候，也就是是基本类型的时候，这里的对象值是脏值，也就是不确定值。（有的地方称之为未初始化，但我不确定）

- 如果 `T` 是类类型，[那么考虑各构造函数并实施针对空实参列表的重载决议](https://en.cppreference.com/w/cpp/language/overload_resolution.html)。调用所选的构造函数（即默认构造函数之一），以提供新对象的初始值;
  - 说白了就是调用默认构造函数。
  - 但是这块的重载决议太复杂了，看下链接吧。关键词搜索constructor
- 如果 `T` 是数组类型，那么该数组的每个元素都被默认初始化；
- 否则，不做任何事：具有自动存储期的对象（及其子对象）被初始化为不确定值。
  - 这句话翻译过来就是非类类型的参数都是不确定值。也就是脏数据。
  - 比如上面的`a`,`b`,`c`都是不确定值。
  - **注意一下，这里说的是自动储存期限。而且下面说了块作用域内。意思就是如果这个基本类型对象是个静态或全局变量，还是会被初始化为0**
    - 很好理解，因为存放的区域都不同。
  - 这时候建议给基本类型或内置类型成员使用`{}`进行值初始化。

```c++
int a; //全局
int b;
int c;
void func(){
    int d; //块作用域
    float e;
    double f;
    static int n; //块作用域但是静态
    static int t;
    static int o;
    cout << d << endl;
    cout << e << endl;
    cout << f << endl;
    cout << n << endl;
    cout << t << endl;
    cout << o << endl;
    
}

int main(){ 
    int x; //块作用域
    float y;
    double z;
    cout << a << endl;
    cout << b << endl;
    cout << c << endl;
    func();
    cout << x << endl;
    cout << y << endl;
    cout << z << endl;
    return 0;
}
/*
0 全局 正确零初始化
0
0
848103824 块作用域，脏值
4.59149e-41
6.92062e-310
0 块作用域但是静态，正确零初始化
0
0
848104048 块作用域 脏值
4.59149e-41
0
*/
```



**调用时机：**

- 当我们在块作用域内不使用任何初始值定义一个非静态变量时，
  - 如果类类型的局部静态变量（块作用域内）没有显式的初始值，它将执行值初始化。非类类型则进行零初始化。

- 当一个类本身含有类类型成员且使用合成的默认构造函数时；
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时；

# 值初始化 value initialization

那么如果在列表形式中，没有任何参数，也就是如

```c++
T ();
new T ();
class::class(...) : object() { ... };
T object {};
T {};
new T {};
class::class(...) : object{} { ... };
```

这样的初始化方法，我们称之为值初始化。

按我的理解，实质应该叫做“广义缺省初始化”。因为值初始化一般是三种处理方式：

- 如果`T`是类类型，且没有默认构造函数，或拥有由用户提供的或被删除的默认构造函数，那么对象是默认初始化。
  - 直接的默认初始化会导致自动储存期的基本类型成员不会被正确初始化。也就是脏值。

- 如果`T`是类类型，且拥有默认构造函数，而且默认构造函数既不被用户提供，也没有被删除，那么就使用零初始化。然后如果它拥有非平凡的默认构造函数，那么默认初始化它。
  - **后半句话的意思是，如果类T有默认构造。然后如果有一些数据成员是非静态类型，且这些类型中有的没有平凡的默认构造函数，则当前这个类T的默认构造不是平凡构造。所以说，如果该类T有一个数据成员，比如`string`，则首先类T被零初始化，然后由于类T的默认构造不是平凡的默认构造，所以会再次默认初始化它。也就相当于调用其数据成员的默认构造。（比如string会调用其默认构造初始化为空字符串）。**
    - 由于是先零初始化，再默认初始化。此处保证了自动存储期的基本类型成员可以被零初始化。因为针对自动存储期的基本类型成员，默认初始化不作任何事情。
    - **默认构造相当于空初始化器和空函数体。但是依旧会调用各个基类和各个非静态成员的默认构造。**

- 如果 `T` 是数组类型，那么值初始化数组的每个元素；
- 否则，零初始化对象。

以上部分出自官方文档，下面部分来自知乎回答。

>- 如果`T`有用户定义的缺省构造函数，直接调用；
>- 如果`T`有编译器生成的缺省构造函数，先0值初始化再调用；
>- 如果`T`根本不是类，直接0值初始化。
>

https://www.zhihu.com/question/36735960/answer/68902926

- **所有情况下，如果使用空花括号对 `{}` 且 `T` 是*聚合类型*，那么进行聚合初始化而非值初始化。巨大坑点！！！**
- 如果 `T` 是没有默认构造函数但带有接受 `std::initializer_list`的构造函数的类类型，那么进行列表初始化。

**调用时机**：

- 在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；
- 当我们不使用初始值定义一个局部静态变量时；
- 当我们通过书写形如`T()`的表达式显示地请求值初始化时；



## 加深对象构造和使用初始化器之间的关系理解

所以当我们遇到这样的表达式

```c++
T obj;
T obj(...);
int a;
```

要知道，它并不是调用构造函数的意思。而是通过某种初始化方式得到一个`T`类型对象。又恰好由于类型`T`是一个带有自定义构造器的类类型，因此对类型`T`对象的值初始化等于默认初始化。默认初始化一个类类型，会考虑各构造函数并找到最匹配的那一个，然后调用所选的构造函数，以提供新对象的初始值。所以我们说，这个值初始化过程会包含一次对`A`的构造器的调用。并不是说这个表达式就是调用构造器。

# 零初始化 zero initialization

**注意零初始化在语言中没有专用语法，因此下列语法不是零初始化语法。这些是可能会进行零初始化的其他初始化的例子。**

```c++
static T 对象
T () ;
T t = {} ;
T {} ; (C++11 起)
CharT 数组 [ n ] = " 短序列 ";	
```

**尤其注意非局部静态变量如果不能被常量初始化，那么它会被零初始化。但是类成员变量由于需要类外定义并初始化，所以一开始是零初始化，然后在类外定义的时候根据具体语法规则来进行对应的初始化**

![QQ截图20230405011410](/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011410.png)

![QQ截图20230405011403](/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011403.png)



> 在所有其他初始化前，对每个具有静态或线程局部 (C++11 起)[存储期](https://zh.cppreference.com/w/cpp/language/storage_duration)的，不进行[常量初始化](https://zh.cppreference.com/w/cpp/language/constant_initialization)的具名变量。

将一个对象的初始值设为零。

零初始化的效果是：

- 如果 `T` 是标量类型，那么对象的初始值是将整数字面量 0显式转换到 `T` 的值。

- 如果 `T` 是数组类型，那么零初始化每个元素。
- 如果 `T` 是引用类型，那么不做任何事。
- 如果 `T` 是非联合体类类型，那么：
  - 初始化所有填充位为零位
  - 零初始化所有非静态数据成员
  - 零初始化所有非虚基类子对象
  - 如果对象不是基类子对象，那么也零初始化所有虚基类子对象。
- 如果 `T` 是联合体类型，那么：
  - 初始化所有填充位为零位
  - 零初始化对象的首个非静态具名数据成员。

# 统一初始化 uniform initialization

个人理解统一初始化的背后其实就是值初始化。目的是让一切看起来更好。

https://blog.csdn.net/danshiming/article/details/116273447

#  常量初始化

目的是设置静态变量的初值为编译时常量。

如果静态或线程局部变量以常量被初始化，那么就会在其他所有初始化之前进行常量初始化以取代零初始化。

变量或临时对象 `obj `在满足以下所有条件时会以常量被初始化 ：

- 要么它有初始化器 （`(表达式列表)`,`{初始化器列表}`,`=表达式`），要么它的默认初始化会进行某些初始化，并且

  - 它的初始化完整表达式是常量表达式，或者在` obj `是对象时，该完整表达式也可以为` obj `和它的子对象调用constexpr构造函数，即使这些对象不是字面类类型。

- **常量初始化的效果与其所对应的初始化的效果相同，但保证它在任何其他静态或线程局部对象的初始化前完成，并可能在编译时进行。**

- 一般来说，常量初始化在编译时进行，并将预先计算的对象表示作为程序映像的一部分在 `.data` 段存储。如果变量既为 `const` 又被常量初始化，那么它会被存储于程序映像的只读段 `.rodata` 段。

  

# 非局部变量的静态初始化

针对静态变量而言。尤其要注意区分静态成员变量和静态局部变量的区别。单例的笔记中提到了。

所有具有静态存储期的非局部变量的初始化会作为程序启动的一部分在main 函数的执行之前进行（除非被延迟）。所有具有线程局部存储期的非局部变量的初始化会作为线程启动的一部分进行，按顺序早于线程函数的执行开始。对于这两种变量，初始化发生于两个截然不同的阶段：**静态初始化和动态初始化**。

动态初始化这里先不提。我们关注一下静态初始化：

有两种静态初始化的形式：

1. 如果可能，那么应用常量初始化。
2. 否则非局部静态及线程局域变量会被零初始化。

实践中：

- 常量初始化通常在编译期进行。预先被计算的对象表示会作为程序映像的一部分存储下来。如果编译器没有这样做，那么它仍然必须保证该初始化发生早于任何动态初始化。
- 零初始化的变量将被置于程序映像的 `.bss` 段，它不占据磁盘空间，并在加载程序时由操作系统以零填充。

**注意，静态成员变量虽然属于具有静态存储期的非局部变量，但是在默认初始化中，格外提到了*当不带初始化器而声明具有自动、静态或线程局部存储期的变量时*是默认初始化。**



## 个人理解

**`{}`这花括号本身叫做花括号初始化器列表(Brace-init-list)** [在这里](https://zh.cppreference.com/w/cpp/language/initialization)

- 个人理解。当是我们**使用花括号初始化器列表进行列表初始化**的时候，如果是聚合类型，看见`{}`是聚合初始化(aggregate initialization)

- 如果不是聚合类型
  - 如果有`std::initializer_list`构造函数，那么它在能匹配`std::initializer_list`构造函数的时候就尽可能使用这个构造函数。
  - 如果没有`std::initializer_list`构造函数，那么它叫做统一初始化（value initialization)。他会寻找其他匹配的构造函数参数来寻找合适的方式初始化对象。
    - 如果是类类型，
      - 如果构造函数是编译器合成的，则为零初始化（zero initialization）
      - 如果构造函数不是编译器合成的，则是值初始化 (value initialization)
    - 如果不是类类型，也就是内置类型，就是零初始化（zero initialization）

[CppCon 2018: Nicolai Josuttis “The Nightmare of Initialization in C++”](https://www.youtube.com/watch?v=7DTlWPgX6zs)

https://blog.csdn.net/qq_39583450/article/details/109624599

https://zh.cppreference.com/w/cpp/language/list_initialization

# 非常诡异的例子

```c++
struct test{
    test() = delete;
    int val;
    char b;
    float c;
    double d;
};
int main(){
    test obj{};
}
```

这段代码在C++11/14/17可以运行，但是20不可以。为什么。

首先我们看到`test obj{}`的时候可能会想到这是值初始化。但是看好了，`test`在C++20前。c++11后是聚合体。所以这是聚合初始化。

- 聚合体的定义在C++11-C++20间有这样一条：

  - >  没有用户提供、继承或 explicit 的构造函数。

  - > 首个声明被显式预置或显式弃置的时候，不是由用户提供的

  - 所以这里的`=delete`不是用户提供的。所以符合要求

- 聚合体的定义在C++20后被修改为

  - > 没有用户声明或继承的构造函数

  - `=delete`是用户声明的。所以不符合要求了



![initialization](/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/initialization.png)

图片来自[这里](https://pica.zhimg.com/v2-71ee7afb16ed13a42c7e17f74a4bec53_r.jpg)

# 延伸

## 什么时候会生成未初始化的变量

来自PVS这篇文章的[Program execution: uninitialized variables 章节](https://pvs-studio.com/en/blog/posts/cpp/1193/)

如果我们不考虑特殊函数和原始内存分配器，且如果类型是`is_trivially_constructible`的 (不知道这个定义的查看模板笔记) 情况下

- `T x;`
- `T x[N];`
- `T* p = new T;`
- `T* p = new T[N];`

会产生未初始化的变量/数组（或指向未初始化的变量/数组的指针）。