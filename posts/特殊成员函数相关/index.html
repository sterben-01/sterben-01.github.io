<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++ 特殊成员函数相关" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="拷贝构造" /><meta property="og:description" content="拷贝构造" /><link rel="canonical" href="/posts/%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/" /><meta property="og:url" content="/posts/%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-18T15:50:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++ 特殊成员函数相关" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-03T02:23:59-06:00","datePublished":"2022-07-18T15:50:00-05:00","description":"拷贝构造","headline":"C++ 特殊成员函数相关","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"},"url":"/posts/%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3/"}</script><title>C++ 特殊成员函数相关 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++ 特殊成员函数相关</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>C++ 特殊成员函数相关</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1658177400" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/07/18 </em> </span> <span> 更新于 <em class="" data-ts="1733214239" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2024/12/03 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9624 字"> <em>53 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="拷贝构造">拷贝构造</h1><h3 id="调用的是拷贝构造函数还是赋值运算符主要是看是否有新的对象实例产生"><span class="mr-2">调用的是拷贝构造函数还是赋值运算符，主要是看是否有新的对象实例产生。</span><a href="#调用的是拷贝构造函数还是赋值运算符主要是看是否有新的对象实例产生" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果产生了新的对象实例，那调用的就是拷贝构造函数；如果是对已有的对象赋值，调用的是拷贝赋值。</p><p>比如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre> <span class="n">P</span> <span class="n">a</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//这是拷贝构造。因为a还不存在。</span>
<span class="c1">//------------------------------------------------------</span>
 <span class="n">P</span> <span class="n">a</span><span class="p">;</span>
 <span class="n">a</span> <span class="o">=</span>  <span class="n">P</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//这是拷贝赋值。因为a已经存在了</span>
</pre></table></code></div></div><h3 id="拷贝构造函数必须以引用的方式传递参数这是因为在值传递的方式传递给一个函数的时候会调用拷贝构造函数生成函数的实参如果拷贝构造函数的参数仍然是以值的方式就会无限循环的调用下去直到函数的栈溢出"><span class="mr-2"><strong>拷贝构造函数必须以引用的方式传递参数</strong>。这是因为，在值传递的方式传递给一个函数的时候，会调用拷贝构造函数生成函数的实参。如果拷贝构造函数的参数仍然是以值的方式，就会无限循环的调用下去，直到函数的栈溢出。</span><a href="#拷贝构造函数必须以引用的方式传递参数这是因为在值传递的方式传递给一个函数的时候会调用拷贝构造函数生成函数的实参如果拷贝构造函数的参数仍然是以值的方式就会无限循环的调用下去直到函数的栈溢出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>拷贝构造有严格的函数签名限制：</p><blockquote><p>类 <code class="language-plaintext highlighter-rouge">T</code> 的复制构造函数是首个形参是 T&amp;、const T&amp;、volatile T&amp; 或 const volatile T&amp;，而且要么没有其他形参，要么剩余形参均有默认值的非模板构造函数</p></blockquote><h2 id="很多种情况都会调用拷贝构造一般来说有如下几种形式"><span class="mr-2">很多种情况都会调用拷贝构造。一般来说有如下几种形式</span><a href="#很多种情况都会调用拷贝构造一般来说有如下几种形式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>对象作为函数的参数，以值传递的方式传给函数。　<li>对象作为函数的返回值，以值的方式从函数返回<li>使用一个对象给另一个对象<strong>初始化</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">P</span> <span class="nf">p1</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span> <span class="c1">//使用一个对象给另一个对象初始化</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">P</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span> <span class="c1">//使用一个对象给另一个对象初始化</span>
<span class="n">P</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">P</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="c1">//使用一个临时对象给另一个对象初始化</span>
<span class="n">P</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">P</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//指针也不例外 这种声明使用10初始化一个匿名对象，并将新对象的地址赋给p1指针。</span>
</pre></table></code></div></div><p><strong>这里虽然使用了<code class="language-plaintext highlighter-rouge">=</code>，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的也是拷贝构造函数。</strong></p><p>这里的第一行和第二行可能会使用复制构造函数直接创建p1，也可能使用复制构造函数生成一个临时对象，然后将临时对象的内容赋给p1，<strong>这取决于具体的实现</strong></p><h2 id="举例"><span class="mr-2">举例：</span><a href="#举例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>示例代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(){}</span>
	<span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy Constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">Person</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Assign"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Person</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Person</span> <span class="nf">f1</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Person</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">Person</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// 1</span>
	<span class="n">Person</span> <span class="n">p2</span><span class="p">;</span>
	<span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>           <span class="c1">// 2</span>
	<span class="n">f</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>            <span class="c1">// 3</span>

	<span class="n">p2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span>        <span class="c1">// 4</span>

	<span class="n">Person</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">f1</span><span class="p">();</span> <span class="c1">// 5</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>下面是输出</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="s">"Copy Constructor"</span> 	<span class="c1">//1</span>
    
<span class="s">"Assign"</span>			<span class="c1">//2</span>
    
<span class="s">"Copy Constructor"</span>	<span class="c1">//3</span>
    
<span class="s">"Copy Constructor"</span> 	<span class="c1">//4</span>
<span class="s">"Assign"</span>
    
<span class="s">"Copy Constructor"</span> 	<span class="c1">//5</span>
</pre></table></code></div></div><p>分析如下：</p><ol><li>这是虽然使用了”=”，但是实际上使用对象p来创建一个新的对象p1。也就是产生了新的对象，所以调用的是拷贝构造函数。<li>首先声明一个对象p2，然后使用赋值运算符”=”，将p的值复制给p2，显然是调用赋值运算符，为一个已经存在的对象赋值 。<li>以值传递的方式将对象p2传入函数f内，调用拷贝构造函数构建一个函数f可用的实参。<li>这条语句拷贝构造函数和赋值运算符都调用了。函数f1以值的方式返回一个Person对象，在返回时会调用拷贝构造函数创建一个临时对象<code class="language-plaintext highlighter-rouge">tmp</code>作为返回值；返回后调用赋值运算符将临时对象<code class="language-plaintext highlighter-rouge">tmp</code>赋值给p2.<li>按照4的解释，应该是首先调用拷贝构造函数创建临时对象；然后再调用拷贝构造函数使用刚才创建的临时对象创建新的对象p3，也就是会调用两次拷贝构造函数。不过，编译器也没有那么傻，应该是直接调用拷贝构造函数使用返回值创建了对象p3。</ol><h2 id="关于拷贝赋值和拷贝构造在继承中的注意事项"><span class="mr-2">关于拷贝赋值和拷贝构造在继承中的注意事项</span><a href="#关于拷贝赋值和拷贝构造在继承中的注意事项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>继承中，子类的拷贝赋值和拷贝构造不会将父类的成员变量复制。为了防止遗漏，我们一般在子类直接调用父类的拷贝赋值或者拷贝构造。但是要注意语法和一些小细节</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">(){}</span>
        <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span><span class="n">m_a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span><span class="o">~</span><span class="n">A</span><span class="p">(){}</span>
        <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_a</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_a</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
	<span class="kt">int</span> <span class="n">m_a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">B</span><span class="p">(){}</span>
        <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">m_b</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
        <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">A</span><span class="p">(</span><span class="n">no</span><span class="p">),</span><span class="n">m_b</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span> <span class="c1">//这里用到了子类调用父类构造</span>
        <span class="o">~</span><span class="n">B</span><span class="p">(){}</span> 
        
        <span class="n">B</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span> <span class="c1">//这里是函数调用。</span>
            <span class="cm">/*
            我们函数调用可以不接受返回值。operator=的返回值的目的是返回一个自己用来进行下一步操作。是为了满足链式调用。当然也可以啥也不返回。
            所以隔壁的拷贝构造就没返回值。
            但是我们子类调用父类的拷贝赋值仅仅是把子类的父类部分调用父类的拷贝赋值来进行一个赋值。
            这里的例子就是子类的父类部分m_a使用父类的拷贝赋值给copy一遍。
            然后我们直接调用完了父类的拷贝赋值后，再自己赋值子类部分。
            时刻谨记 b1 = b2 就是b1.operator=(b2);
            */</span>
            <span class="n">m_b</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m_b</span><span class="p">;</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">m_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">m_a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们这里没有使用带指针对象的拷贝构造和拷贝赋值做为例子。</p><p>但是我们想要深拷贝的时候，拷贝赋值要注意先检测自我赋值。</p><p>其次要先删除掉调用方自己的对应内容，然后新开辟内存，然后复制数据。</p><h2 id="移动赋值和移动构造记得移动后需要把原来数据置空尤其是带有指针类型的"><span class="mr-2">移动赋值和移动构造记得移动后需要把原来数据置空。尤其是带有指针类型的</span><a href="#移动赋值和移动构造记得移动后需要把原来数据置空尤其是带有指针类型的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>但是不能删除。因为是转移所有权。也就是浅拷贝。删除了东西就没了。如果不置空的话会有两个问题。第一是可能会被误用。其次是如果是把一个临时对象移动构造或者是移动赋值给一个对象，临时对象的那一行过后临时对象会被析构。也就是指针指向的数据会被释放。所以你对象拿到的临时对象的对应指针数据也会被清除。</p><p>所以在有指针的时候需要格外注意。而且对应的析构函数也要进行判空，不然会多次删除。</p><p>移动构造在使用vector的情况下，一般是vector扩容的时候重新分配内存的时候使用，如果自定义类型有移动构造就会用移动构造。没有就是拷贝构造。</p><h1 id="拷贝构造-拷贝赋值-移动构造-移动赋值的例子此处拷贝为深拷贝">拷贝构造 拷贝赋值 移动构造 移动赋值的例子。此处拷贝为深拷贝。</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">x</span><span class="p">)){}</span>
        <span class="kt">int</span><span class="o">&amp;</span> <span class="n">getval</span><span class="p">(){</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//拷贝构造 深拷贝</span>
            <span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">.</span><span class="n">val</span><span class="p">);</span> <span class="c1">//以传入参数的值新开辟数据空间</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">//拷贝赋值 深拷贝</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span> <span class="c1">//检测自我赋值</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span> <span class="c1">//释放自身此时的资源。</span>
            <span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">);</span> <span class="c1">//以传入参数的值新开辟数据空间</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//移动构造</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"mv"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>     <span class="c1">//浅拷贝指针</span>
            <span class="n">obj</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">//因为是所有权转移，传入对象的数据指针必须被置空</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">//移动赋值</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"mv="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span> <span class="c1">//检测自我赋值</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span> <span class="c1">//先释放自身此时资源</span>
                <span class="k">delete</span> <span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">;</span> <span class="c1">//浅拷贝指针</span>
            <span class="n">rhs</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">//因为是所有权转移，传入对象的数据指针必须被置空</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="o">~</span><span class="n">myobj</span><span class="p">(){</span>
            <span class="k">delete</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>
        
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">c</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">d</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">e</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">getval</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="移动构造函数的设计">移动构造函数的设计</h1><ul><li>参数：<ul><li>参数为<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>类型，因为是移动操作<li>参数不可设置为<code class="language-plaintext highlighter-rouge">const</code>，因为需要改变入参</ul><li>在移动构造函数后添加<code class="language-plaintext highlighter-rouge">noexcept</code>关键字，确保移动构造函数不会抛出异常。尤其是针对可能会有<code class="language-plaintext highlighter-rouge">vector</code>容器储存该类对象时。<li>内容：<ul><li>在参数初始化列表中将参数的资源移动给自己（先执行）。<ul><li>把入参的资源移动给自己。</ul><li>然后在函数体内处理入参所拥有的资源：<ul><li>一般来说，对象应该置为0或默认值。<li><strong>指针必须置空避免不小心释放不应释放的资源。因为被移动过的对象在生命周期结束的时候依旧会调用析构。如果不给原对象指针置空，则新对象接管资源后资源也会被无意置空！</strong><li>这样之后就达到了资源移动的目的（后执行）</ul></ul><li>注意要点：<ul><li><strong>移动构造函数不分配任何内存，只是简单的资源移动而已</strong><li><strong>移动构造会构造对象。所以如果使用一个对象通过移动构造来构造一个新对象。我们依旧会有两个对象。只不过只有一个对象拥有有效值而已。最后析构函数还是会被执行两次。因为虽然内容（资源）移动走了，但是壳子（对象本身）还在。所以析构函数依旧会被调用。</strong> （杂记中搜索关键词“壳子”）</ul></ul><h1 id="移动赋值的设计">移动赋值的设计</h1><ul><li>参数：<ul><li>参数为<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>类型，因为是移动操作<li>参数不可设置为<code class="language-plaintext highlighter-rouge">const</code>，因为需要改变</ul><li>在函数后添加<code class="language-plaintext highlighter-rouge">noexcept</code>关键字，确保移动赋值运算符函数不会抛出异常。原因同上<li>与拷贝赋值运算符一样，函数返回自身引用<li>内容：<ul><li><strong>在函数执行前，应该检测自我赋值的情况</strong><li>先释放自身资源，再拷贝参数<code class="language-plaintext highlighter-rouge">rhs</code>的资源，最后再将<code class="language-plaintext highlighter-rouge">rhs</code>置为空。原因同上</ul><li>赋值运算符的重载调用的时候一定要把<code class="language-plaintext highlighter-rouge">this</code>先安全的析构掉（释放自身资源），绝不是构造。另外一个十分重要的点在于虚表指针的初始化时机，C++没规定虚表指针的初始化是什么时候，但是绝对不可能发生在赋值时。</ul><p>https://blog.csdn.net/qq_41453285/article/details/104419356</p><p>通常来讲，我们可以给成员函数设计一个移动版本一个拷贝版本。也就是一个入参类型为<code class="language-plaintext highlighter-rouge">const&amp;</code>，另一个为<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>。<code class="language-plaintext highlighter-rouge">push_back</code>就是这样设计的</p><h1 id="注意编译器并不是在任何场合都会生成默认移动构造函数或默认移动赋值">注意编译器并不是在任何场合都会生成默认移动构造函数或默认移动赋值</h1><ul><li>针对移动构造和移动赋值，有更严格的要求需要满足，编译期才会为我们生成默认移动构造或默认移动赋值：<ul><li>编译器只会针对满足如下情况的类生成移动构造和移动赋值<ul><li>没有用户定义的移动构造/移动赋值<li>没有用户声明的拷贝构造/拷贝赋值<li>没有用户声明的析构函数</ul></ul><li>所以会有0/3/5法则。</ul><h1 id="特殊成员函数默认生成的条件">特殊成员函数默认生成的条件</h1><p>同时翻看 effective modern C++ 条款17</p><ul><li><p>六种特殊的成员函数可以声明为类似 <code class="language-plaintext highlighter-rouge">X() = default</code> 让编译器自动生成， 或者声明为 <code class="language-plaintext highlighter-rouge">X() = delete</code> 阻止编译器自动生成相应的函数定义。</p><li><p><code class="language-plaintext highlighter-rouge">X::X()</code> 默认构造函数 如果没有声明（包括 <code class="language-plaintext highlighter-rouge">=delete</code>）,编译器将会自动生成定义。但是如果用户声明了其他形式的构造函数如<code class="language-plaintext highlighter-rouge">X(int x)</code> , 编译器将不会自动生成，除非用户手动定义。</p><li><p>拷贝构造<code class="language-plaintext highlighter-rouge">X(const X&amp;)</code> 和 拷贝赋值<code class="language-plaintext highlighter-rouge">X&amp; operator=(const X&amp;)</code> 如果用户没有提供，<strong>且没有提供移动构造或移动赋值</strong>，在需要的时候编译器会自动生成，内容为对成员的值拷贝，如果是指针成员将是“浅复制”。</p><ul><li><p><strong>注意还有一些其他限制。这个建议去网站看文档。比较细碎。比如拥有不可拷贝的成员时。</strong></p><li><p><strong>注意拷贝构造和拷贝赋值不会抑制互相的生成，但是其生成会被弃用deprecated。同时，用户定义的析构函数也会导致其弃用</strong>：</p><ul><li><blockquote><p>当 <code class="language-plaintext highlighter-rouge">T</code> 拥有用户定义的析构函数或用户定义的复制构造函数时，隐式定义的复制赋值运算符的生成被弃用。</p></blockquote><li><blockquote><p>当 <code class="language-plaintext highlighter-rouge">T</code> 拥有用户定义的析构函数或用户定义的复制赋值运算符时，隐式定义的复制构造函数的生成会被弃用。</p></blockquote></ul><li><p><strong>再次重申，弃用不是<code class="language-plaintext highlighter-rouge">=delete</code>。而是deprecated。g++不会提示报错，但是clang会。可能委员会认为如果被设置为<code class="language-plaintext highlighter-rouge">=delete</code>会对大量代码导致遗留问题。</strong></p><li><p>每个类都有自己的拷贝构造或拷贝赋值。只不过他们要么可以用要么被=delete了。<a href="https://youtu.be/9BM5LAvNtus">来自</a></p></ul><li><p><strong>对除构造函数之外的特殊成员函数的声明（哪怕是<code class="language-plaintext highlighter-rouge">=default</code>或<code class="language-plaintext highlighter-rouge">delete</code>），将会阻止编译器生成默认的移动构造和移动赋值。这将会导致该类无法使用移动语义</strong></p><ul><li><strong>这里是压根不生成（声明）移动构造和移动赋值。压根没有，而不是<code class="language-plaintext highlighter-rouge">=delete</code></strong><li>针对移动构造和移动赋值，有更严格的要求需要满足，编译器才会为我们生成默认移动构造或默认移动赋值：<ul><li>没有用户定义的移动构造/移动赋值<li>没有用户声明的拷贝构造/拷贝赋值<li>没有用户声明的析构函数</ul><li>注意和拷贝操作不同。移动操作的两种函数不是互相独立的。也就是移动构造和移动赋值会互相抑制编译器的提供。— effective modern C++ 条款17。</ul><li><p><strong>如果只声明了移动构造或移动赋值，则编译器隐式生成的默认拷贝构造和默认拷贝赋值将会声明为<code class="language-plaintext highlighter-rouge">delete</code>, 也就是该类是仅移动的。</strong></p><li><p><strong>如果一个本来会隐式声明且定义为弃置的拷贝构造被用户显式预置(=default)，那么这个复制构造函数被定义为弃置。</strong></p><ul><li>也就是说如果某类有一个不可拷贝的成员，你还给这个类的拷贝构造用了<code class="language-plaintext highlighter-rouge">=default</code>，那么没有用，还是会被编译器换成<code class="language-plaintext highlighter-rouge">=delete</code>。当然了，如果这时候你没有对这个类成员进行会调用拷贝构造的操作，GCC不会报错，但是clang会有warning。</ul></ul><h1 id="035-法则">0/3/5 法则</h1><h2 id="3之法则"><span class="mr-2">3之法则</span><a href="#3之法则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果某个类需要用户定义的<strong>析构函数、用户定义的拷贝构造函数或用户定义的拷贝赋值运算符</strong>，那么它几乎肯定需要全部三者。</p><p>原因：</p><ul><li>通常，若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员（析构时需要手动去释放指针指向的内存）。<li>所以，若存在自定义（且正确）的析构函数，但使用合成的拷贝构造函数，那么拷贝过去的也只是指针，此时两个对象的指针变量同时指向同一块内存，指向同一块内存的后果很有可能是在两个对象中的析构函数中先后被释放两次。所以需要额外的拷贝控制函数去控制相应资源的拷贝。<li>所以这类例子的共同点就是：一个对象拥有额外的资源（指针指向的内存），但另一个对象使用合成的拷贝构造函数也同时拥有这块资源。当一方对象被销毁后，析构函数释放了资源，这时另一个对象便失去了这块资源（但程序员还不知道）。</ul><h2 id="5之法则"><span class="mr-2">5之法则</span><a href="#5之法则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>因为用户定义的析构函数、拷贝构造函数或拷贝赋值运算符的存在会阻止移动构造函数和移动赋值运算符的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数。</strong></p><h2 id="0之法则"><span class="mr-2">0之法则</span><a href="#0之法则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果不需要手动定义， 就不要定义，一切让它默认。</p><h2 id="整理"><span class="mr-2">整理</span><a href="#整理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>图片<a href="https://www.sandordargo.com/blog/2024/11/27/non-movable-classes">来自这里</a></p><h1 id="注意移动操作的含义">注意移动操作的含义</h1><p><strong>移动是一种特殊的拷贝操作。也就是移动是比拷贝更”先进“的操作。</strong>因为根据函数重载决议规则，如果我们没有提供移动构造或移动赋值，当我们使用右值进行“移动”操作时，则会匹配到拷贝构造或拷贝赋值。<strong>所以如果想显式表达某个类不能移动，则应该声明拷贝操作为<code class="language-plaintext highlighter-rouge">=delete</code>而不是放在那里不管。如果不写，我们的“移动”操作会变成拷贝操作。如果写了，则会报错。</strong></p><h1 id="构造函数中使用move-或-forward移动参数的陷阱">构造函数中使用move 或 forward移动参数的陷阱</h1><h2 id="不要对入参为常量左值引用的对象使用move它会被拷贝而不是移动"><span class="mr-2">不要对入参为常量左值引用的对象使用move。它会被拷贝而不是移动</span><a href="#不要对入参为常量左值引用的对象使用move它会被拷贝而不是移动" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">x</span><span class="p">)){</span> <span class="c1">//构造</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//拷贝构造</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"copy const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">//拷贝赋值</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"copy= const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//移动构造</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"mv"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="n">obj</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">3939</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span> <span class="c1">//移动赋值</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"mv="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
                <span class="k">delete</span> <span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
            <span class="n">rhs</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> 
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

        <span class="p">}</span>
        <span class="o">~</span><span class="n">myobj</span><span class="p">(){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"dest"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">delete</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span><span class="o">*</span> <span class="n">val</span><span class="p">;</span>
        
<span class="p">};</span>

</pre></table></code></div></div><p>上面是一个写了所有特殊成员函数的类。我们继续看</p><ul><li>第一个版本。我们值传递。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//版本1 值传递</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">temp</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj</span> <span class="n">out</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出什么？</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="c1">//构造temp对象</span>
<span class="n">copy</span> <span class="k">const</span> <span class="c1">//值传递导致的拷贝至构造函数中。</span>
<span class="n">mv</span> <span class="c1">//构造函数中使用move把拷贝的对象转换为右值然后移动构造的inner</span>
<span class="n">dest</span><span class="c1">//拷贝进来的参数析构</span>
<span class="mi">20</span>
<span class="n">dest</span> <span class="c1">//testobj里的myobj析构</span>
<span class="n">dest</span><span class="c1">//外部myobj析构</span>
</pre></table></code></div></div><p><strong>这个20会正常输出。外部的temp对象是拷贝传值。被move变成右值的是值传递导致的拷贝的那个对象。</strong></p><p><strong><em>值传递有另一种情况</em></strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//版本1 值传递</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">temp</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj</span> <span class="n">out</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span> <span class="c1">//这里我们也用move</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="c1">//构造temp对象</span>
<span class="n">mv</span> <span class="c1">//右值触发移动构造传入函数参数</span>
<span class="n">mv</span> <span class="c1">//右值触发移动构造从函数入参构建inner</span>
<span class="n">dest</span>
<span class="n">dest</span>
<span class="n">dest</span>
</pre></table></code></div></div><ul><li>第二个版本。左值引用传递。<ul><li>这个版本有个毛病。输入右值不行。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//左值引用</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">temp</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj</span> <span class="n">out</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="c1">//testobj out(myobj(20)); 不行。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="c1">//temp对象构建</span>
<span class="n">mv</span> <span class="c1">//引用传递不发生拷贝，这里的move变成右值的是temp对象本身。所以触发移动构造testobj内的inner</span>
<span class="mi">3939</span> <span class="c1">//外部对象已经被移动。输出3939</span>
<span class="n">dest</span>
<span class="n">dest</span>
</pre></table></code></div></div><p>这里我们发现由于是左值引用传递，所以temp对象发生了移动。</p><ul><li><strong>第三个版本。常量左值引用传递。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//常量左值引用</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">temp</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj</span> <span class="n">out</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="c1">//temp对象构建</span>
<span class="n">copy</span> <span class="k">const</span> <span class="c1">//引用传递不发生拷贝。这里的拷贝是从构造函数入参中拷贝至myobj的inner对象。</span>
<span class="mi">20</span><span class="c1">//外部不移动</span>
<span class="n">dest</span>
<span class="n">dest</span>
</pre></table></code></div></div><ul><li>为什么会拷贝？<ul><li>常量左值引用既然是常量就不可能对该参数修改。这是简单的理解。<li>深层次的理解是这样的。我们<code class="language-plaintext highlighter-rouge">move</code>会把一个左值变成右值。我们<code class="language-plaintext highlighter-rouge">obj</code>传进来的时候是<code class="language-plaintext highlighter-rouge">const &amp;</code>, 如果<code class="language-plaintext highlighter-rouge">move</code>就会变成<code class="language-plaintext highlighter-rouge">const &amp;&amp;</code>。<li>这时候有一个问题。我们没有<code class="language-plaintext highlighter-rouge">const&amp;&amp;</code>开头的函数。我们也知道<code class="language-plaintext highlighter-rouge">const&amp;</code>可以接受一切参数包括<code class="language-plaintext highlighter-rouge">const&amp;&amp;</code>。（杂记）<strong>所以这时候会去匹配<code class="language-plaintext highlighter-rouge">const&amp;</code>的拷贝构造。所以最后会发生拷贝。</strong><li><code class="language-plaintext highlighter-rouge">const&amp;&amp;</code>函数毫无意义。首先移动语义在有意义的时候一定要保证把被移动对象和资源进行分离。加了<code class="language-plaintext highlighter-rouge">const</code>无法对参数进行修改。其次，入参为右值的时候我们有<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>接受。常量右值的时候会被<code class="language-plaintext highlighter-rouge">const&amp;</code>接受。所以<code class="language-plaintext highlighter-rouge">const&amp;&amp;</code>没有意义。</ul><p>https://www.nextptr.com/tutorial/ta1211389378/beware-of-using-stdmove-on-a-const-lvalue</p><li>第四个版本 右值引用传递。<ul><li>这个版本也有毛病。左值不行。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//右值引用</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">temp</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj</span> <span class="n">out</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span> <span class="c1">//move换成右值</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">temp</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="c1">//构造temp</span>
<span class="n">mv</span> <span class="c1">//引用传递不拷贝。这个move是把temp对象转换为右值后触发拷贝构造</span>
<span class="mi">3939</span><span class="c1">//temp已被移动。</span>
<span class="n">dest</span>
<span class="n">dest</span>
</pre></table></code></div></div><p>这里我们发现结果和左值引用是一致的。</p><p><strong>那么如果我们直接传入临时对象会发生什么呢？</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">testobj</span> <span class="nf">out</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>


<span class="k">const</span> <span class="c1">//构造临时对象。临时对象必须得有啊不然传的是啥？</span>
<span class="n">mv</span> <span class="c1">//move把临时对象换成右值，触发移动构造。</span>
<span class="n">dest</span>
<span class="n">dest</span>

</pre></table></code></div></div><h2 id="构造函数中使用forward的正确方式"><span class="mr-2">构造函数中使用forward的正确方式</span><a href="#构造函数中使用forward的正确方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对于完美转发我们已经在杂记中介绍了。但是我们当时只展示了函数的完美转发。</p><p>我们必须要记住完美转发的核心要素之一，重中之重也就是完美转发依靠于万能引用。因为只有万能引用才能触发引用坍缩。</p><p><strong>但是格外注意万能引用的陷阱之一：如果不涉及型别推导，那么就算是<code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>也不是万能引用。（格外注意！！！！）</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">T</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="o">:</span> <span class="n">inner</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">// cannot bind rvalue reference of type ‘myobj&amp;&amp;’ to lvalue of type ‘myobj’</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">var</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">testobj</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">var</span><span class="p">);</span> <span class="c1">//cannot bind rvalue reference of type ‘myobj&amp;&amp;’ to lvalue of type ‘myobj’</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的就是<strong>错误例子</strong>。在这里，<code class="language-plaintext highlighter-rouge">T</code>是类模板参数。因为我们使用的时候已经显式制定了<code class="language-plaintext highlighter-rouge">T</code>为<code class="language-plaintext highlighter-rouge">myobj</code>。这就代表了<code class="language-plaintext highlighter-rouge">T</code>不涉及型别推导。所以<code class="language-plaintext highlighter-rouge">T</code>在这里不是万能引用，而是右值引用。不涉及万能引用的时候自然不涉及引用坍缩，也就不涉及完美转发。</p><p>什么是正确例子呢？我们知道必须要让含有完美转发的函数涉及到万能引用也就是型别推导。所以就需要成员函数模板。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">&gt;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">Arg</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>这个时候函数的入参的模板参数会涉及到型别推导。至于该类是否是类模板，则不重要。只是看是否有需求罢了。</p><h2 id="构造函数中-想要触发蕴含的某个其他对象的移动构造则必须使用move或forward"><span class="mr-2">构造函数中 想要触发蕴含的某个其他对象的移动构造，则必须使用move或forward</span><a href="#构造函数中-想要触发蕴含的某个其他对象的移动构造则必须使用move或forward" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们延续上面的例子。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="c1">//testobj(myobj&amp;&amp; obj):inner(move(obj)){}</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">((</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//我们这里不使用move</span>
<span class="p">};</span>

</pre></table></code></div></div><p>我们发现，我们这里使用了<code class="language-plaintext highlighter-rouge">move</code>。如果不用<code class="language-plaintext highlighter-rouge">move</code>会发生什么呢？</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">testobj</span> <span class="nf">our</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="k">const</span> <span class="c1">//构造临时对象</span>
<span class="n">copy</span> <span class="k">const</span> <span class="c1">//哇哦，发生了拷贝。</span>
<span class="n">dest</span>
<span class="n">dest</span>
</pre></table></code></div></div><p>为什么会拷贝？我们不是传入了临时对象吗？</p><p><strong>我们一定知道：具名的右值引用是左值。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">){</span>
    <span class="c1">//这里rhs是具名右值引用。是左值。所以如果这时候有函数接受左值或右值引用形式的rhs，则会匹配至左值</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>这也是为什么存在完美转发。这就是另一个要点！在构造函数中，如果想要显式对某一个对象进行移动，仍需要使用<code class="language-plaintext highlighter-rouge">move</code></strong></p><p>如果我们这里不使用<code class="language-plaintext highlighter-rouge">move</code>，则此时右值引用接住的临时对象会变为具名对象，会变成左值。传入后就会匹配拷贝构造。</p><p>为了正确的传递其右值特性，或强制转换为右值，就需要使用<code class="language-plaintext highlighter-rouge">forward</code>或<code class="language-plaintext highlighter-rouge">move</code>。</p><p>所以我们可以这样使用<code class="language-plaintext highlighter-rouge">move</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span><span class="c1">//使用move</span>
<span class="p">};</span>

</pre></table></code></div></div><p>或使用<code class="language-plaintext highlighter-rouge">forward</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">&gt;</span>
    <span class="n">testobj</span><span class="p">(</span><span class="n">Arg</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)){}</span> <span class="c1">//使用forward</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="同样的想要从头移到尾则外部调用和内部构造函数中都要使用move"><span class="mr-2">同样的，想要从头移到尾，则外部调用和内部构造函数中都要使用<code class="language-plaintext highlighter-rouge">move</code></span><a href="#同样的想要从头移到尾则外部调用和内部构造函数中都要使用move" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ano</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">ano</span><span class="p">(</span><span class="n">myobj</span> <span class="n">ano</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ano</span><span class="p">)){};</span> <span class="c1">// 注意此时入参是值传递而不是右值引用。</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">ano</span> <span class="n">pro</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在调用过程中，我们会触发两次移动构造。第一次是传入函数中。第二次是使用入参初始化类成员的时候。只要有一个地方没有<code class="language-plaintext highlighter-rouge">move</code>就会触发拷贝构造</p><p>更深入的可以看看<a href="https://www.youtube.com/watch?v=PNRju6_yn3o&amp;t=182s">视频</a></p><h1 id="具体在构造函数中我们应该传值传递两个版本还是完美转发呢">具体在构造函数中，我们应该传值，传递两个版本还是完美转发呢？</h1><ul><li>方案1：写出两个版本。<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>和<code class="language-plaintext highlighter-rouge">const &amp;</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj2</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj2</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">obj</span><span class="p">){</span> <span class="c1">//针对左值。记住，针对入参为常量左值引用，不要move</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called testobj2"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">testobj2</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called&amp;&amp; testobj2"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">test2L</span><span class="p">(){</span> <span class="c1">//左值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test2L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj2</span> <span class="n">v1</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test2L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">test2R</span><span class="p">(){</span> <span class="c1">//右值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test2R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj2</span> <span class="n">v1</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj1</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test2R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
----------
start test2L
const 构建对象
copy const 引用传递不拷贝。此处是拷贝构造至类内的inner对象
called testobj2
end test2L
dest
dest
----------
start test2R
const 构建对象
mv 引用传递不拷贝。又因为是右值所以触发了移动构造至类内的inner对象
called&amp;&amp; testobj2
end test2R
dest
dest
----------
*/</span>
</pre></table></code></div></div><ul><li>方案2：使用完美转发</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj1</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Arg</span><span class="p">&gt;</span>
    <span class="n">testobj1</span><span class="p">(</span><span class="n">Arg</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)){</span> <span class="c1">//完美转发应该怎么写，上面提到了。</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called testobj1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">test1L</span><span class="p">(){</span> <span class="c1">//左值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test1L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj1</span> <span class="n">v1</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test1L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">test1R</span><span class="p">(){</span> <span class="c1">//右值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test1R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj1</span> <span class="n">v1</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj1</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test1R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
start test1L
const 构建对象
copy const 完美转发发现是左值，调用拷贝构造
called testobj1
end test1L
dest
dest
----------
start test1R
const 构建对象
mv 完美转发发现是右值，调用移动构造
called testobj1
end test1R
dest
dest
*/</span>
</pre></table></code></div></div><ul><li>方案3 值传递</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testobj3</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">myobj</span> <span class="n">inner</span><span class="p">;</span>
    <span class="n">testobj3</span><span class="p">(</span><span class="n">myobj</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span><span class="n">inner</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">)){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called testobj3"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">test3L</span><span class="p">(){</span> <span class="c1">//左值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test3L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj3</span> <span class="n">v1</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test3L"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">test3R</span><span class="p">(){</span> <span class="c1">//右值入参</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start test3R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">testobj3</span> <span class="n">v1</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">obj1</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"end test3R"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
----------
start test3L
const 构建对象
copy const 值传递发生一次多余拷贝，拷贝至函数入参。此时是临时对象
mv 调用移动构造
called testobj3
dest
end test3L
dest
dest
----------
start test3R
const 构建对象
mv 右值传递发生一次多余移动。移动至函数入参。此时是临时对象
mv 调用移动构造
called testobj3
dest
end test3R
dest
dest
*/</span>
</pre></table></code></div></div><p><strong>额外注意为何值传递传递右值的时候是多了一次移动而不是多了一次拷贝？</strong></p><p><strong>因为传递至函数参数，相当于进行了一次以入参为值的直接初始化。也就是临时对象是直接初始化出来的。在杂记中我们提到了直接初始化会考虑全部的构造函数寻找最佳匹配，所以如果满足移动构造就会使用移动构造</strong>。</p><ul><li>最后我们发现了，写两种版本和完美转发效果相同。但是使用值传递会在左值的时候多一次拷贝，右值的时候多一次移动。尤其是拷贝或移动开销较大的时候应该避免。<strong>所以既可以写两种版本，也可以使用完美转发。</strong></ul><h1 id="拷贝移动构造赋值只要写了就需要写出完整的">拷贝/移动构造/赋值只要写了，就需要写出完整的</h1><p>无论成员变量是什么类型的，堆的还是栈的，都需要写出来。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copy const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//20</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//20</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面是我们提供的，一切正常。</p><p>要么就是不写：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//20</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//20</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>但是绝对不可以这样：</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"copy const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//20</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//乱七八糟</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>我们知道编译器默认生成的是浅拷贝。但是那是因为你没写才生成默认拷贝构造。你要是写了编译器就不会生成。那如果你不写完整那就是连浅拷贝都没有。这里我们的拷贝构造就是连浅拷贝都没有。所以<code class="language-plaintext highlighter-rouge">val</code>是垃圾值。</strong></ul><h1 id="类静态成员变量不需要写入拷贝构造或拷贝赋值和析构函数">类静态成员变量不需要写入拷贝构造或拷贝赋值和析构函数</h1><p>本来静态成员变量就是类的所有对象共有的。也不能在类内初始化。所以写入拷贝构造或拷贝赋值是无意义的。</p><p>同样，静态成员变量生存周期是至程序结束。所以析构函数并不关心他们。</p><h1 id="重新梳理赋值运算符的语义">重新梳理赋值运算符的语义</h1><p>赋值运算符<code class="language-plaintext highlighter-rouge">operator=</code>算作运算符重载里。</p><ul><li>如果这个<code class="language-plaintext highlighter-rouge">operator=</code>的形参恰好接受一个 <code class="language-plaintext highlighter-rouge">T</code>、<code class="language-plaintext highlighter-rouge">T&amp;</code>、<code class="language-plaintext highlighter-rouge">const T&amp;</code>、<code class="language-plaintext highlighter-rouge">volatile T&amp;</code> 或 <code class="language-plaintext highlighter-rouge">const volatile T&amp; </code>类型的形参，且它不是模板函数也不是静态成员函数，那么它就是拷贝赋值运算符<li>如果这个<code class="language-plaintext highlighter-rouge">operator=</code>的形参恰好接受一个 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>、<code class="language-plaintext highlighter-rouge">const T&amp;&amp;</code>、<code class="language-plaintext highlighter-rouge">volatile T&amp;&amp;</code> 或<code class="language-plaintext highlighter-rouge"> const volatile T&amp;&amp; </code>类型的形参，且它不是模板函数也不是静态成员函数，那么它就是移动赋值运算符</ul><p>所以一个类可以有多个<code class="language-plaintext highlighter-rouge">operator=</code>重载。他们都是赋值运算符。但是如果不符合上面的要求，则不能称之为拷贝赋值或移动赋值。</p><p>所以operator=的返回值压根没有明确要求。包括拷贝赋值和移动赋值。</p><p><strong>拷贝赋值运算符也不是强制返回<code class="language-plaintext highlighter-rouge">T&amp;</code>的。如果你不想链式调用，完全可以写成这样</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myclass</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="n">myclass</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">myclass</span><span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"copy assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myclass</span> <span class="n">obj</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
    <span class="n">myclass</span> <span class="n">obj2</span><span class="p">(</span><span class="mi">300</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">obj2</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">a.operator=(b)</code>压根不是返回值作用于<code class="language-plaintext highlighter-rouge">a</code>。是先修改了<code class="language-plaintext highlighter-rouge">a</code>然后同时返回自己而已。目的就是链式调用。所以<code class="language-plaintext highlighter-rouge">a = b</code>这个表达式，返回值压根就没用上。</p><h1 id="非常好的资料">非常好的资料</h1><p>https://youtu.be/9BM5LAvNtus</p><h1 id="各种成员函数是否应该是explicit的">各种成员函数是否应该是explicit的</h1><p>https://quuxplusone.github.io/blog/2024/06/25/most-stl-ctors-arent-explicit-but-yours-still-should-be/</p><h1 id="移动赋值和-use-after-move">移动赋值和 use-after-move</h1><p>本文参考资料来自<a href="https://pvs-studio.com/en/blog/posts/cpp/1156/">这里的<em>Errors in object lifetime: use-after-move</em>章节</a></p><p>每一个vector都有我们可选的分配器对象。这点我们在PMR介绍过。</p><p>标准库要求分配器类型定义<code class="language-plaintext highlighter-rouge">propagate_on_container_move_assignment</code>属性，该属性会影响移动分配的行为。如果我们写<code class="language-plaintext highlighter-rouge">A = std::move(B)</code>，我们有三个选项：</p><ol><li><code class="language-plaintext highlighter-rouge">propagate_on_container_move_assignment{} == true</code> 是的，这不是常量，而是一个结构，如false_type / true_type）。<code class="language-plaintext highlighter-rouge">A</code>被释放，分配器被移动（再次使用移动分配，因此我们需要在这里注意一些保证），然后从<code class="language-plaintext highlighter-rouge">B</code>中获取内容，最后将<code class="language-plaintext highlighter-rouge">B</code>置空<li><code class="language-plaintext highlighter-rouge">propagate_on_container_move_assignment{} == false</code>并且<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>中的分配器相同 (<code class="language-plaintext highlighter-rouge"> A.get_allocator() == B.get_allocator() </code>)。<code class="language-plaintext highlighter-rouge">A</code>被释放，分配器保持原位。 内容从<code class="language-plaintext highlighter-rouge">A</code>转移到<code class="language-plaintext highlighter-rouge">B</code>。<li><code class="language-plaintext highlighter-rouge">propagate_on_container_move_assignment{} == false</code>并且<code class="language-plaintext highlighter-rouge">A.get_allocator() != B.get_allocator()</code>。这是最有趣的部分开始的地方：<code class="language-plaintext highlighter-rouge">A</code>不能拿走分配器或数据。唯一的选择是分别移动每个元素。但是，清空和释放<code class="language-plaintext highlighter-rouge">B</code>不是必要的。我们需要做的就是移动元素。在这种情况下，我们还可以得到一个由移出的元素组成的完整vector。</ol><p><strong>在第三种情况下，vector的 libc++ 实现中，不会对其调用<code class="language-plaintext highlighter-rouge">clear()</code>，但是libstdc++会。</strong></p><p>libc++:</p><p><a href="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005312.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005312.png" alt="微信图片_20241022005312" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005316.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005316.png" alt="微信图片_20241022005316" class="lazyload" data-proofer-ignore></a></p><p>libstdc++:</p><p><a href="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005322.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005322.png" alt="微信图片_20241022005322" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005319.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-19-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241022005319.png" alt="微信图片_20241022005319" class="lazyload" data-proofer-ignore></a></p><p>我们从图中可以看到libc++和libstdc++的源码实现差别。但是注意，就算不对B调用clear，也不代表B的元素是有效的。经过移动后，B的元素仅仅是可访问的。所以说它没有破坏语义也没有颠覆我们先前的认知。我们用个人的例子试一下，会得到如下结果</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre>  <span class="p">{</span>
    <span class="n">VectorString</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span>
    <span class="p">};</span>
    <span class="n">VectorString</span> <span class="n">vv</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"---"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">vv</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cm">/*
libstdc++
---
myobj move constructor
myobj move constructor
myobj move constructor
myobj move constructor
myobj destructor
myobj destructor
myobj destructor
myobj destructor
0
myobj destructor
myobj destructor
myobj destructor
myobj destructor

libc++
---
myobj move constructor
myobj move constructor
myobj move constructor
myobj move constructor
4
myobj destructor
myobj destructor
myobj destructor
myobj destructor
myobj destructor
myobj destructor
myobj destructor
myobj destructor
*/</span>
</pre></table></code></div></div><p>可以看出明显差别。</p><p>所以我们针对移动对象的状态保证有四个级别：</p><ol><li>仅析构。被移动的对象被销毁并且不再使用。如果决定向其对象添加移动语义，则应提供这项基本保证，以便整个析构函数自动调用机制不会出现任何超出人预期外的问题<li>析构和赋值。这种情况下指的某个对象被移动后，可以通过为对象分配新值来重用它（然后正常使用它）。可以移动但不能重新分配的对象非常罕见。因此，通常这种保证与前一种保证相结合。<li>有效但是未指明效果。我们可以使用已经被移动的对象，比如调用不需要先决条件的成员函数。但是里面有什么？天知道<li>有效且定义明确。这是我们想要的。</ol><h1 id="copy-and-swap">copy and swap</h1><p>https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom</p><p>move and swap基本是一个意思</p><h1 id="延伸">延伸</h1><h2 id="如何确保一个类不可被拷贝或移动"><span class="mr-2">如何确保一个类不可被拷贝或移动</span><a href="#如何确保一个类不可被拷贝或移动" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://www.sandordargo.com/blog/2024/11/27/non-movable-classes</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++%20%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%20-%20Sterben_01&url=%2Fposts%2F%25E7%2589%25B9%25E6%25AE%258A%25E6%2588%2590%25E5%2591%2598%25E5%2587%25BD%25E6%2595%25B0%25E7%259B%25B8%25E5%2585%25B3%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++%20%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%20-%20Sterben_01&u=%2Fposts%2F%25E7%2589%25B9%25E6%25AE%258A%25E6%2588%2590%25E5%2591%2598%25E5%2587%25BD%25E6%2595%25B0%25E7%259B%25B8%25E5%2585%25B3%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E7%2589%25B9%25E6%25AE%258A%25E6%2588%2590%25E5%2591%2598%25E5%2587%25BD%25E6%2595%25B0%25E7%259B%25B8%25E5%2585%25B3%2F&text=C++%20%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%9D%82%E8%AE%B0/" class="btn btn-outline-primary" prompt="上一篇"><p>C++ 杂记</p></a> <a href="/posts/OS27/" class="btn btn-outline-primary" prompt="下一篇"><p>王道操作系统笔记-内存（24）-- 内存管理6</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
