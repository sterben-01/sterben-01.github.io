<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="初始化" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="聚合初始化" /><meta property="og:description" content="聚合初始化" /><link rel="canonical" href="/posts/%E5%88%9D%E5%A7%8B%E5%8C%96/" /><meta property="og:url" content="/posts/%E5%88%9D%E5%A7%8B%E5%8C%96/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-20T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="初始化" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-03T03:43:10-05:00","datePublished":"2022-07-20T01:55:00-05:00","description":"聚合初始化","headline":"初始化","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E5%88%9D%E5%A7%8B%E5%8C%96/"},"url":"/posts/%E5%88%9D%E5%A7%8B%E5%8C%96/"}</script><title>初始化 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>初始化</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>初始化</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1658300100" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/07/20 </em> </span> <span> 更新于 <em class="" data-ts="1756888990" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/09/03 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7768 字"> <em>43 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="聚合初始化">聚合初始化</h1><blockquote><p>从 初始化器列表初始化聚合体。是<a href="https://zh.cppreference.com/w/cpp/language/list_initialization">列表初始化</a>的一种形式。</p></blockquote><p><code class="language-plaintext highlighter-rouge">(aggregate initialization)</code>。聚合类型可以进行直接列表初始化。<strong>没有构造函数也可以初始化其中的参数</strong>。但是聚合类型有如下限制</p><blockquote><h2 id="聚合aggregate"><span class="mr-2"><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">聚合</a>（Aggregate）</span><a href="#聚合aggregate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>聚合</strong>属于以下类型之一：</p><ul><li><strong>数组类型</strong>（array types）<li><strong>类类型</strong>，并满足下列条件：<ul><li><strong>没有用户声明的构造函数</strong>（no user-declared constructors） （至 C++11 之前）<li><strong>没有用户提供的、继承的或显式的构造函数</strong>（no user-provided, inherited, or explicit constructors） （自 C++11 起，至 C++20 之前）<li><strong>没有用户声明或继承的构造函数</strong>（no user-declared or inherited constructors） （自 C++20 起）<li><strong>没有私有或受保护的直接非静态数据成员</strong>（no private or protected direct non-static data members）<li><strong>没有基类</strong>（no base classes） （至 C++17 之前）<li><strong>没有虚拟基类</strong>（no virtual base classes）<li><strong>没有私有或受保护的直接基类</strong>（no private or protected direct base classes） （自 C++17 起）<li><strong>没有虚成员函数</strong>（no virtual member functions）<li><strong>没有默认成员初始化器</strong>（no default member initializers） （自 C++11 起，至 C++14 之前）</ul></ul><h2 id="元素element"><span class="mr-2">元素（Element）</span><a href="#元素element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>聚合的元素</strong>为：</p><ul><li>对于<strong>数组</strong>：按下标递增顺序的数组元素。<li>对于<strong>类</strong>：<ul><li><strong>至 C++17 之前</strong>：按声明顺序的<strong>非静态数据成员</strong>（不包括匿名位域，anonymous bit-fields）。<li><strong>自 C++17 起</strong>：先是按声明顺序的<strong>直接基类</strong>，随后是按声明顺序的<strong>直接非静态数据成员</strong>，且这些成员<strong>既不是匿名位域，也不是匿名联合（anonymous union）的成员</strong>。</ul></ul></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="k">struct</span> <span class="nc">obj</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">_objval</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">_val</span><span class="p">;</span>
    <span class="n">obj</span> <span class="n">inclass_obj</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">_val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inclass_obj</span><span class="p">.</span><span class="n">_objval</span><span class="p">(</span><span class="n">y</span><span class="p">){}</span> <span class="c1">// 错误。这是构造函数初始化列表。用来初始化的。这里的inclass_obj._objval(y)是赋值操作。不允许。详细说就是，初始化列表只能初始化对象。这里是给一个对象的某个变量赋值。这是错误的。</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">_val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inclass_obj</span><span class="p">(</span><span class="n">y</span><span class="p">){}</span> 	<span class="c1">// 错误 obj类没有有参构造函数。</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">_val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inclass_obj</span><span class="p">(){}</span> 	<span class="c1">// 可以 obj类有默认无参构造函数。</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">_val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">inclass_obj</span><span class="p">{</span><span class="n">y</span><span class="p">}{}</span> 	<span class="c1">// 可以 这里的inclass_obj{y}叫做聚合初始化。注意后面的{}是test构造函数的{}。不要搞混</span>
    
<span class="p">};</span>
</pre></table></code></div></div><p>针对第一行错误代码，我们可以让<code class="language-plaintext highlighter-rouge">obj</code>自带一个有参构造。然后使用有参构造对<code class="language-plaintext highlighter-rouge">obj</code>进行初始化。</p><ul><li>这东西真正牛逼的在这呢。如果聚合体中间有嵌套，你可以不用使用花 括号分割</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Aggregate</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Aggregate</span> <span class="n">aggr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="聚合初始化的例子-和-构造函数的重载决议"><span class="mr-2">聚合初始化的例子 和 构造函数的重载决议</span><a href="#聚合初始化的例子-和-构造函数的重载决议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>看一段代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">A1</span><span class="p">{</span>
    <span class="k">explicit</span> <span class="n">A1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">x_</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">B</span><span class="p">{</span>
    <span class="n">B</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">A1</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这样都正常，但是如果我们给<code class="language-plaintext highlighter-rouge">B b</code>换成：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
<span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">B</span> <span class="n">b</span><span class="p">{</span><span class="n">B</span><span class="p">{}};</span>
</pre></table></code></div></div><p>会提示：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">'</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">'</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">19</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span> <span class="n">warning</span><span class="o">:</span> <span class="n">converting</span> <span class="n">to</span> <span class="err">'</span><span class="n">A1</span><span class="err">'</span> <span class="n">from</span> <span class="n">initializer</span> <span class="n">list</span> <span class="n">would</span> <span class="n">use</span> <span class="k">explicit</span> <span class="n">constructor</span> <span class="err">'</span><span class="n">A1</span><span class="o">::</span><span class="n">A1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">'</span>
   <span class="mi">19</span> <span class="o">|</span>     <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
      <span class="o">|</span>             <span class="o">^</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">7</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span> <span class="n">note</span><span class="o">:</span> <span class="err">'</span><span class="n">A1</span><span class="o">::</span><span class="n">A1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">'</span> <span class="n">declared</span> <span class="n">here</span>
    <span class="mi">7</span> <span class="o">|</span>     <span class="k">explicit</span> <span class="nf">A1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
      <span class="o">|</span>              <span class="o">^~</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">19</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span> <span class="n">note</span><span class="o">:</span> <span class="n">in</span> <span class="n">C</span><span class="o">++</span><span class="mi">11</span> <span class="n">and</span> <span class="n">above</span> <span class="n">a</span> <span class="k">default</span> <span class="n">constructor</span> <span class="n">can</span> <span class="n">be</span> <span class="k">explicit</span>
   <span class="mi">19</span> <span class="o">|</span>     <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
      <span class="o">|</span>             <span class="o">^</span>
<span class="n">ASM</span> <span class="n">generation</span> <span class="n">compiler</span> <span class="n">returned</span><span class="o">:</span> <span class="mi">0</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">'</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">'</span><span class="o">:</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">19</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span> <span class="n">warning</span><span class="o">:</span> <span class="n">converting</span> <span class="n">to</span> <span class="err">'</span><span class="n">A1</span><span class="err">'</span> <span class="n">from</span> <span class="n">initializer</span> <span class="n">list</span> <span class="n">would</span> <span class="n">use</span> <span class="k">explicit</span> <span class="n">constructor</span> <span class="err">'</span><span class="n">A1</span><span class="o">::</span><span class="n">A1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">'</span>
   <span class="mi">19</span> <span class="o">|</span>     <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
      <span class="o">|</span>             <span class="o">^</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">7</span><span class="o">:</span><span class="mi">14</span><span class="o">:</span> <span class="n">note</span><span class="o">:</span> <span class="err">'</span><span class="n">A1</span><span class="o">::</span><span class="n">A1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="err">'</span> <span class="n">declared</span> <span class="n">here</span>
    <span class="mi">7</span> <span class="o">|</span>     <span class="k">explicit</span> <span class="nf">A1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">:</span> <span class="n">x_</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{}</span>
      <span class="o">|</span>              <span class="o">^~</span>
<span class="o">&lt;</span><span class="n">source</span><span class="o">&gt;:</span><span class="mi">19</span><span class="o">:</span><span class="mi">13</span><span class="o">:</span> <span class="n">note</span><span class="o">:</span> <span class="n">in</span> <span class="n">C</span><span class="o">++</span><span class="mi">11</span> <span class="n">and</span> <span class="n">above</span> <span class="n">a</span> <span class="k">default</span> <span class="n">constructor</span> <span class="n">can</span> <span class="n">be</span> <span class="k">explicit</span>
   <span class="mi">19</span> <span class="o">|</span>     <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
      <span class="o">|</span>             <span class="o">^</span>
<span class="n">Execution</span> <span class="n">build</span> <span class="n">compiler</span> <span class="n">returned</span><span class="o">:</span> <span class="mi">0</span>
</pre></table></code></div></div><p>为啥呢？我们先看一下<a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">聚合初始化的细节</a> (简略版)：</p><blockquote><ol><li><p>先确定聚合中<strong>被显式初始化的元素</strong></p><li><p>被显示初始化的元素规则…[此处不展开]</p><li><p><strong>被隐式初始化的元素</strong>规则：</p><ol><li><p>对于<strong>非 union 的聚合</strong>，每个<strong>未被显式初始化</strong>的元素按如下方式初始化：</p><ul><li>如果该元素有<strong>默认成员初始化器</strong>（default member initializer），则从该初始化器进行初始化。（自 C++11 起）<li>否则，如果该元素<strong>不是引用</strong>，则从一个<strong>空的初始化列表</strong>进行拷贝初始化。（the element is <a href="https://en.cppreference.com/w/cpp/language/copy_initialization.html">copy-initialized</a> from an empty initializer list.）<li>否则（即该元素是引用且没有默认成员初始化器），程序是不良形式。</ul><li><p>如果聚合是一个 <code class="language-plaintext highlighter-rouge">union</code> 且初始化列表<strong>为空</strong>，则：</p><ul><li>如果有任何变体成员具有默认成员初始化器，则该成员由其默认成员初始化器进行初始化。（自 C++11 起）<li>否则，<code class="language-plaintext highlighter-rouge">union</code> 的<strong>第一个成员</strong>（如果有）从一个<strong>空初始化列表</strong>进行拷贝初始化。（the element is <a href="https://en.cppreference.com/w/cpp/language/copy_initialization.html">copy-initialized</a> from an empty initializer list.）</ul></ol></ol></blockquote><p>所以我们的代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">{};</span>
</pre></table></code></div></div><p>因为我们没有显式初始化<code class="language-plaintext highlighter-rouge">A1</code>，且<code class="language-plaintext highlighter-rouge">A1</code>不是引用，所以<code class="language-plaintext highlighter-rouge">A1</code>是从一个<strong>空初始化列表</strong>进行<strong>拷贝</strong>初始化（复制列表初始化）</p><p>所以就是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">A1</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{};</span>
</pre></table></code></div></div><p>这个地方意味着a是被值初始化。我们查看值初始化的定义，发现a会被默认初始化。这里会尝试找到最匹配的构造函数。但是我们在构造函数重载决议中找到了这一点：</p><blockquote><h4 id="通过构造函数初始化"><span class="mr-2">通过构造函数初始化</span><a href="#通过构造函数初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当类类型的对象被<a href="https://en.cppreference.com/w/cpp/language/direct_initialization.html">直接初始化</a>或<a href="https://en.cppreference.com/w/cpp/language/default_initialization.html">默认初始化（包括</a><a href="https://en.cppreference.com/w/cpp/language/list_initialization.html">复制列表</a>初始化上下文中的默认初始化）(C++11 起)时，候选函数均为被初始化类的构造函数。参数列表为初始化器的表达式列表。</p><p>否则，候选函数均为被初始化类的<a href="https://en.cppreference.com/w/cpp/language/converting_constructor.html">转换构造函数</a>。参数列表为初始化器的表达式。</p><p><strong>对于复制列表初始化上下文中的默认初始化，如果选择到了explicit标记的构造函数，则初始化格式不正确。</strong>（自 C++11 起）</p></blockquote><p>所以我们发现</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">A1</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{};</span>
</pre></table></code></div></div><p>这个代码格式不正确，所以有问题。</p><p>来自<a href="https://stackoverflow.com/questions/72712318/converting-to-a-from-initializer-list-would-use-explicit-constructor-aaint">这里</a></p><h1 id="列表初始化花大括号初始化">列表初始化（花/大括号初始化）</h1><blockquote><p>从 <em>花括号初始化器列表</em> 列表初始化对象。</p></blockquote><p><strong>带等号和不带等号一般不做区分。<code class="language-plaintext highlighter-rouge">int c{5};</code>是直接列表初始化 ，<code class="language-plaintext highlighter-rouge">int d = {5};</code>是拷贝列表初始化。 两种形式一般不做区分。</strong></p><p>首先第一点：c++不允许在一个类内使用圆括号初始化另一个类。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> 	<span class="c1">//拷贝初始化 OK</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 	<span class="c1">//直接初始化。ERROR。</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>	<span class="c1">//默认类型使用的列表初始化。其实还是调用了对应的构造函数进行了直接初始化。也叫直接列表初始化</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">};</span> <span class="c1">//和上面那种一般不做区分。一般也不用。但是这个叫做拷贝列表初始化。</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">test_val1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">test_val2</span><span class="p">;</span>
    <span class="nl">public:</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">test_val1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">test_val2</span><span class="p">(</span><span class="n">y</span><span class="p">){};</span>
    <span class="k">struct</span> <span class="nc">obj</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">_objval</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">_faf</span><span class="p">;</span>
        <span class="n">obj</span><span class="p">(){}</span>
        <span class="n">obj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span> <span class="n">_objval</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>		<span class="c1">//注意我们obj有自定义构造函数。所以不是聚合体。</span>
    <span class="p">};</span>
    <span class="n">obj</span> <span class="n">inclass_obj1</span><span class="p">;</span> 		<span class="c1">//obj对象使用无参构造函数</span>
    <span class="n">obj</span> <span class="nf">inclass_obj2</span><span class="p">();</span> 	<span class="c1">//这是返回obj类型的函数</span>
    <span class="n">obj</span> <span class="nf">inclass_obj3</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 	<span class="c1">//这里表面是使用了obj的有参构造，但是不允许这种行为。因为有二义性。编译器认为这是个返回obj类型的形参为5的函数。但是形参为5是啥玩意？所以一个类内不允许使用圆括号初始化另一个类。也就是不允许使用直接初始化</span>
    <span class="c1">//替代方案：</span>
    <span class="n">obj</span> <span class="n">inclass_obj4</span> <span class="o">=</span> <span class="p">{</span><span class="n">test_val1</span><span class="p">};</span> <span class="c1">// 列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造  //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数</span>
    <span class="n">obj</span> <span class="n">inclass_obj5</span><span class="p">{</span><span class="n">test_val2</span><span class="p">};</span> <span class="c1">//列表初始化(其实还是调用了对应的构造函数) OK //* 注意这里使用了类的有参构造函数。没有使用拷贝构造 //!注意这不是聚合初始化。聚合初始化不能有用户定义的构造函数</span>
    <span class="n">obj</span> <span class="n">inclass_obj6</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//该处的初始化方式是隐式调用obj(int)构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化。</span>
    <span class="n">obj</span> <span class="n">inclass_obj7</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//显式调用有参构造函数生成一个临时的匿名对象，再调用拷贝构造函数完成初始化 OK</span>

<span class="p">};</span>
</pre></table></code></div></div><h1 id="为什么使用列表初始化">为什么使用列表初始化？</h1><ol><li><p>可以使用初始化列表接受任意长度。不想细说了，查查就可以。用得少。除了容器类。</p><li><p>所有场合都可用，比如：</p><ul><li>它能表达一组值，来初始化STL容器：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span> <span class="c1">//当然这也可以。</span>
</pre></table></code></div></div><ul><li>它能用来给类的非static成员设定默认值（而<code class="language-plaintext highlighter-rouge">()</code>就不行）上面提到了。：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="p">...</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// 可以</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 可以</span>
    <span class="kt">int</span> <span class="nf">z</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// 不行</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>它和<code class="language-plaintext highlighter-rouge">()</code>都能用于初始化一个uncopyable的对象（而<code class="language-plaintext highlighter-rouge">=</code>就不行）：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>   <span class="c1">// 可以</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">// 可以</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ai3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 不行</span>
</pre></table></code></div></div><ul><li>包括替换<code class="language-plaintext highlighter-rouge">make_pair</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_map</span><span class="p">;</span>
<span class="n">my_map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span> <span class="c1">//使用make_pair</span>
<span class="n">my_map</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">});</span> <span class="c1">//使用uniform_initialization</span>
</pre></table></code></div></div><li><p>使用列表初始化初始<strong>内置类型</strong>的变量时，防止类型窄化，避免精度丢失的隐式类型转换。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">4.4</span><span class="p">;</span>		<span class="c1">//可以。隐式类型转换。</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mf">5.5</span><span class="p">};</span>		<span class="c1">//不可以，列表初始化防止隐式转换带来的窄化。</span>
<span class="kt">int</span> <span class="n">d</span><span class="p">{</span><span class="mf">6.6</span><span class="p">};</span>			<span class="c1">//不可以，列表初始化防止隐式转换带来的窄化。</span>
</pre></table></code></div></div><p>什么是类型窄化，列表初始化通过禁止下列转换，对隐式转化加以限制：</p><ul><li>从浮点类型到整数类型的转换<li>从 <code class="language-plaintext highlighter-rouge">long double</code> 到 <code class="language-plaintext highlighter-rouge">double</code>或 <code class="language-plaintext highlighter-rouge">float</code> 的转换，以及从 <code class="language-plaintext highlighter-rouge">double</code> 到 <code class="language-plaintext highlighter-rouge">float</code> 的转换，除非源是常量表达式且不发生溢出<li>从整数类型到浮点类型的转换，除非源是其值能完全存储于目标类型的常量表达式<li>从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是其值能完全存储于目标类型的常量表达式</ul><li><p>它不会被认为是声明。</p><ul><li>C++中规定“所有看起来像声明的语句都会被视为声明”，这导致<code class="language-plaintext highlighter-rouge">()</code>在一些场景下会被视为函数声明，而<code class="language-plaintext highlighter-rouge">{}</code>则不会 ```c++ Widget w1(10); // 调用有参构造。 Widget w2(); // 声明了一个无参，名为w2返回Widget的函数 Widget w3{}; // 调用无参构造</ul></ol><p>template<typename T=""> void foo(){ T x1(); //这是函数声明。声明了一个无参，叫x，返回T的函数 T x2 = T(); //初始化x2，但是看起来不像是赋值。 T x3{}; //看起来非常好。 }</typename></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>
# 为什么不使用列表初始化？

- 在类有`std::initializer_list`参数的构造函数时，`{}`会有麻烦：`{}`总会被认为是`std::initializer_list`，即使解析出错。
- `auto`会把列表初始化的型别推导为`std::initializer_list`, 值是`{}`内的内容。
  - 参见下方`i11`
  - 注意区别`i12`

- 一个有趣的地方：如果`{}`中没有元素，那么被调用的是默认构造函数，而不是一个空的`std::initializer_list`。如果你真的想传入一个空的`std::initializer_list`，那么这样：

```c++
Widget w4({});
Widget w5;
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code>会有二义性。我们有</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>   <span class="c1">//使用普通构造函数创建vector，里面有10个元素，初始值为20.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>   <span class="c1">// 使用初始化列表构造函数，创建一个有两个元素的vector，元素分别为10和20</span>
</pre></table></code></div></div><ul><li>同样的情况存在于使用<code class="language-plaintext highlighter-rouge">make</code>方法进行智能指针的创建之时。<code class="language-plaintext highlighter-rouge">make</code>方法无法使用列表初始化</ul><h1 id="看一点有意思的事情">看一点有意思的事情</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i1</span><span class="p">;</span>				<span class="c1">//未定义值。undefined value</span>
<span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>		<span class="c1">//拷贝初始化 使用42</span>
<span class="kt">int</span> <span class="nf">i3</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>			<span class="c1">//直接初始化 使用42</span>
<span class="kt">int</span> <span class="n">i4</span> <span class="o">=</span> <span class="kt">int</span><span class="p">();</span>		<span class="c1">//拷贝初始化 使用0（默认值）</span>
<span class="kt">int</span> <span class="n">i5</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>			<span class="c1">//直接列表初始化 使用42</span>
<span class="kt">int</span> <span class="n">i6</span><span class="p">{};</span>			<span class="c1">//直接列表初始化 使用0（默认值）</span>
<span class="kt">int</span> <span class="n">i7</span> <span class="o">=</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>		<span class="c1">//拷贝列表初始化 使用42</span>
<span class="kt">int</span> <span class="n">i8</span> <span class="o">=</span> <span class="p">{};</span>		<span class="c1">//拷贝列表初始化 使用0 （默认值）</span>

<span class="k">auto</span> <span class="n">i9</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  		<span class="c1">//使用42初始化，推导为int</span>
<span class="k">auto</span> <span class="n">i10</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>		<span class="c1">//使用42初始化，推导为int。[除旧编译器外]</span>
<span class="k">auto</span> <span class="n">i11</span> <span class="o">=</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>	<span class="c1">//使用42初始化std::initializer_list&lt;int&gt;。推导为std::initializer_list&lt;int&gt;</span>
<span class="k">auto</span> <span class="n">i12</span> <span class="o">=</span> <span class="kt">int</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>	<span class="c1">//使用42初始化的int来初始化i12, 推导为int</span>

<span class="kt">int</span> <span class="nf">i13</span><span class="p">();</span>			<span class="c1">//这是函数声明</span>
<span class="kt">int</span> <span class="nf">i14</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>		<span class="c1">//这是编译时错误</span>
<span class="kt">int</span> <span class="n">i15</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>	<span class="c1">//使用9。这是使用了逗号运算符。</span>
<span class="kt">int</span> <span class="n">i16</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>	<span class="c1">//这是编译时错误</span>

<span class="k">auto</span> <span class="nf">i17</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>		<span class="c1">//这是编译时错误</span>
<span class="k">auto</span> <span class="n">i18</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span>	<span class="c1">//使用9，这是使用了逗号运算符。</span>
<span class="k">auto</span> <span class="n">i19</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">);</span><span class="c1">//这是编译时错误。</span>


<span class="c1">//针对不可拷贝和/或不可移动的类型，在C++17以前 如下是不允许的</span>
<span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">9</span><span class="p">};</span> <span class="c1">//不可拷贝，C++14编译错误。使用了已删除的拷贝构造函数。但是C++17使用了复制省略技术，可以通过编译。</span>

</pre></table></code></div></div><ul><li>逗号运算符<ul><li>整个逗号表达式的值为系列中最后一个表达式的值。<li>从本质上讲，逗号的作用是将一系列运算按顺序执行。</ul><li>视频中建议不要使用<code class="language-plaintext highlighter-rouge">()</code>进行初始化。尽可能使用花括号<code class="language-plaintext highlighter-rouge">{}</code><li><code class="language-plaintext highlighter-rouge">i10</code>的原始语义是使用42初始化一个<code class="language-plaintext highlighter-rouge">std::initializer_list&lt;int&gt;</code>。已在C++14中修复。<li>注意<code class="language-plaintext highlighter-rouge">i11</code>的等号改变了<code class="language-plaintext highlighter-rouge">auto</code>推导的类型。初始化阶段使用等号可能会改变变量的类型。<li>剩余auto解释参见杂记3.</ul><h2 id="c17-复制省略技术"><span class="mr-2">C++17 复制省略技术</span><a href="#c17-复制省略技术" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>参见杂记3</p><h1 id="stdinitializer_list">std::initializer_list</h1><p>参见杂记3</p><h1 id="初始化和赋值的区别">初始化和赋值的区别</h1><ul><li><p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化（initialized）</strong>。</p><li>而赋值的含义是把对象的当前值擦除，而以一个新值来替代。<li>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值</ul><h1 id="初始化器">初始化器</h1><p>看下面的几种初始化之前先看这个</p><p>https://zh.cppreference.com/w/cpp/language/initialization</p><h1 id="默认初始化-default-initialization">默认初始化 default initialization</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="err">对象</span> <span class="c1">//当不带初始化器而声明具有自动、静态或线程局部存储期的变量时；</span>
<span class="k">new</span> <span class="n">T</span> <span class="c1">//当以不带初始化器的 new 表达式创建具有动态存储期的对象时</span>
</pre></table></code></div></div><p>如<code class="language-plaintext highlighter-rouge">[new] T object;</code>这样的都叫做默认（缺省）初始化。比如：</p><ul><li><code class="language-plaintext highlighter-rouge">int a</code>;<li><code class="language-plaintext highlighter-rouge">double b</code>;<li><code class="language-plaintext highlighter-rouge">bool c</code>;<li>…</ul><p>当我们不使用初始化器的时候，就会自动被编译器调用这种方式初始化。但是它有个问题。在不是类类型的时候，也就是是基本类型的时候，这里的对象值是脏值，也就是不确定值。（有的地方称之为未初始化，但我不确定）</p><ul><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是类类型，<a href="https://en.cppreference.com/w/cpp/language/overload_resolution.html">那么考虑各构造函数并实施针对空实参列表的重载决议</a>。调用所选的构造函数（即默认构造函数之一），以提供新对象的初始值;<ul><li>说白了就是调用默认构造函数。<li>但是这块的重载决议太复杂了，看下链接吧。关键词搜索constructor</ul><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是数组类型，那么该数组的每个元素都被默认初始化；<li>否则，不做任何事：具有自动存储期的对象（及其子对象）被初始化为不确定值。<ul><li>这句话翻译过来就是非类类型的参数都是不确定值。也就是脏数据。<li>比如上面的<code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>,<code class="language-plaintext highlighter-rouge">c</code>都是不确定值。<li><strong>注意一下，这里说的是自动储存期限。而且下面说了块作用域内。意思就是如果这个基本类型对象是个静态或全局变量，还是会被初始化为0</strong><ul><li>很好理解，因为存放的区域都不同。</ul><li>这时候建议给基本类型或内置类型成员使用<code class="language-plaintext highlighter-rouge">{}</code>进行值初始化。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//全局</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span> <span class="c1">//块作用域</span>
    <span class="kt">float</span> <span class="n">e</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">f</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="c1">//块作用域但是静态</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">o</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span> 
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="c1">//块作用域</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">func</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
0 全局 正确零初始化
0
0
848103824 块作用域，脏值
4.59149e-41
6.92062e-310
0 块作用域但是静态，正确零初始化
0
0
848104048 块作用域 脏值
4.59149e-41
0
*/</span>
</pre></table></code></div></div><p><strong>调用时机：</strong></p><ul><li>当我们在块作用域内不使用任何初始值定义一个非静态变量时，<ul><li>如果类类型的局部静态变量（块作用域内）没有显式的初始值，它将执行值初始化。非类类型则进行零初始化。</ul><li>当一个类本身含有类类型成员且使用合成的默认构造函数时；<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时；</ul><h1 id="值初始化-value-initialization">值初始化 value initialization</h1><p>那么如果在列表形式中，没有任何参数，也就是如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="p">();</span>
<span class="k">new</span> <span class="nf">T</span> <span class="p">();</span>
<span class="k">class</span><span class="o">::</span><span class="k">class</span><span class="p">(...)</span> <span class="o">:</span> <span class="n">object</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="n">T</span> <span class="n">object</span> <span class="p">{};</span>
<span class="n">T</span> <span class="p">{};</span>
<span class="k">new</span> <span class="n">T</span> <span class="p">{};</span>
<span class="k">class</span><span class="o">::</span><span class="k">class</span><span class="p">(...)</span> <span class="o">:</span> <span class="n">object</span><span class="p">{}</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</pre></table></code></div></div><p>这样的初始化方法，我们称之为值初始化。</p><p>按我的理解，实质应该叫做“广义缺省初始化”。因为值初始化一般是三种处理方式：</p><ul><li>如果<code class="language-plaintext highlighter-rouge">T</code>是类类型，且没有默认构造函数，或拥有由用户提供的或被删除的默认构造函数，那么对象是默认初始化。<ul><li>直接的默认初始化会导致自动储存期的基本类型成员不会被正确初始化。也就是脏值。</ul><li>如果<code class="language-plaintext highlighter-rouge">T</code>是类类型，且拥有默认构造函数，而且默认构造函数既不被用户提供，也没有被删除，那么就使用零初始化。然后如果它拥有非平凡的默认构造函数，那么默认初始化它。<ul><li><strong>后半句话的意思是，如果类T有默认构造。然后如果有一些数据成员是非静态类型，且这些类型中有的没有平凡的默认构造函数，则当前这个类T的默认构造不是平凡构造。所以说，如果该类T有一个数据成员，比如<code class="language-plaintext highlighter-rouge">string</code>，则首先类T被零初始化，然后由于类T的默认构造不是平凡的默认构造，所以会再次默认初始化它。也就相当于调用其数据成员的默认构造。（比如string会调用其默认构造初始化为空字符串）。</strong><ul><li>由于是先零初始化，再默认初始化。此处保证了自动存储期的基本类型成员可以被零初始化。因为针对自动存储期的基本类型成员，默认初始化不作任何事情。<li><strong>默认构造相当于空初始化器和空函数体。但是依旧会调用各个基类和各个非静态成员的默认构造。</strong></ul></ul><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是数组类型，那么值初始化数组的每个元素；<li>否则，零初始化对象。</ul><p>以上部分出自官方文档，下面部分来自知乎回答。</p><blockquote><ul><li>如果<code class="language-plaintext highlighter-rouge">T</code>有用户定义的缺省构造函数，直接调用；<li>如果<code class="language-plaintext highlighter-rouge">T</code>有编译器生成的缺省构造函数，先0值初始化再调用；<li>如果<code class="language-plaintext highlighter-rouge">T</code>根本不是类，直接0值初始化。</ul></blockquote><p>https://www.zhihu.com/question/36735960/answer/68902926</p><ul><li><strong>所有情况下，如果使用空花括号对 <code class="language-plaintext highlighter-rouge">{}</code> 且 <code class="language-plaintext highlighter-rouge">T</code> 是<em>聚合类型</em>，那么进行聚合初始化而非值初始化。巨大坑点！！！</strong><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是没有默认构造函数但带有接受 <code class="language-plaintext highlighter-rouge">std::initializer_list</code>的构造函数的类类型，那么进行列表初始化。</ul><p><strong>调用时机</strong>：</p><ul><li>在数组初始化的过程中，如果提供的初始值数量少于数组的大小，剩下的元素会进行值初始化；<li>当我们不使用初始值定义一个局部静态变量时；<li>当我们通过书写形如<code class="language-plaintext highlighter-rouge">T()</code>的表达式显示地请求值初始化时；</ul><h2 id="加深对象构造和使用初始化器之间的关系理解"><span class="mr-2">加深对象构造和使用初始化器之间的关系理解</span><a href="#加深对象构造和使用初始化器之间的关系理解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>所以当我们遇到这样的表达式</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">obj</span><span class="p">;</span>
<span class="n">T</span> <span class="nf">obj</span><span class="p">(...);</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</pre></table></code></div></div><p>要知道，它并不是调用构造函数的意思。而是通过某种初始化方式得到一个<code class="language-plaintext highlighter-rouge">T</code>类型对象。又恰好由于类型<code class="language-plaintext highlighter-rouge">T</code>是一个带有自定义构造器的类类型，因此对类型<code class="language-plaintext highlighter-rouge">T</code>对象的值初始化等于默认初始化。默认初始化一个类类型，会考虑各构造函数并找到最匹配的那一个，然后调用所选的构造函数，以提供新对象的初始值。所以我们说，这个值初始化过程会包含一次对<code class="language-plaintext highlighter-rouge">A</code>的构造器的调用。并不是说这个表达式就是调用构造器。</p><h1 id="零初始化-zero-initialization">零初始化 zero initialization</h1><p><strong>注意零初始化在语言中没有专用语法，因此下列语法不是零初始化语法。这些是可能会进行零初始化的其他初始化的例子。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">T</span> <span class="err">对象</span>
<span class="n">T</span> <span class="p">()</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">;</span>
<span class="n">T</span> <span class="p">{}</span> <span class="p">;</span> <span class="p">(</span><span class="n">C</span><span class="o">++</span><span class="mi">11</span> <span class="err">起</span><span class="p">)</span>
<span class="n">CharT</span> <span class="err">数组</span> <span class="p">[</span> <span class="n">n</span> <span class="p">]</span> <span class="o">=</span> <span class="s">" 短序列 "</span><span class="p">;</span>	
</pre></table></code></div></div><p><strong>尤其注意非局部静态变量如果不能被常量初始化，那么它会被零初始化。但是类成员变量由于需要类外定义并初始化，所以一开始是零初始化，然后在类外定义的时候根据具体语法规则来进行对应的初始化</strong></p><p><a href="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011410.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011410.png" alt="QQ截图20230405011410" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011403.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/QQ%E6%88%AA%E5%9B%BE20230405011403.png" alt="QQ截图20230405011403" class="lazyload" data-proofer-ignore></a></p><blockquote><p>在所有其他初始化前，对每个具有静态或线程局部 (C++11 起)<a href="https://zh.cppreference.com/w/cpp/language/storage_duration">存储期</a>的，不进行<a href="https://zh.cppreference.com/w/cpp/language/constant_initialization">常量初始化</a>的具名变量。</p></blockquote><p>将一个对象的初始值设为零。</p><p>零初始化的效果是：</p><ul><li><p>如果 <code class="language-plaintext highlighter-rouge">T</code> 是标量类型，那么对象的初始值是将整数字面量 0显式转换到 <code class="language-plaintext highlighter-rouge">T</code> 的值。</p><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是数组类型，那么零初始化每个元素。<li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是引用类型，那么不做任何事。<li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是非联合体类类型，那么：<ul><li>初始化所有填充位为零位<li>零初始化所有非静态数据成员<li>零初始化所有非虚基类子对象<li>如果对象不是基类子对象，那么也零初始化所有虚基类子对象。</ul><li>如果 <code class="language-plaintext highlighter-rouge">T</code> 是联合体类型，那么：<ul><li>初始化所有填充位为零位<li>零初始化对象的首个非静态具名数据成员。</ul></ul><h1 id="统一初始化-uniform-initialization">统一初始化 uniform initialization</h1><p>个人理解统一初始化的背后其实就是值初始化。目的是让一切看起来更好。</p><p>https://blog.csdn.net/danshiming/article/details/116273447</p><h1 id="常量初始化">常量初始化</h1><p>目的是设置静态变量的初值为编译时常量。</p><p>如果静态或线程局部变量以常量被初始化，那么就会在其他所有初始化之前进行常量初始化以取代零初始化。</p><p>变量或临时对象 <code class="language-plaintext highlighter-rouge">obj </code>在满足以下所有条件时会以常量被初始化 ：</p><ul><li><p>要么它有初始化器 （<code class="language-plaintext highlighter-rouge">(表达式列表)</code>,<code class="language-plaintext highlighter-rouge">{初始化器列表}</code>,<code class="language-plaintext highlighter-rouge">=表达式</code>），要么它的默认初始化会进行某些初始化，并且</p><ul><li>它的初始化完整表达式是常量表达式，或者在<code class="language-plaintext highlighter-rouge"> obj </code>是对象时，该完整表达式也可以为<code class="language-plaintext highlighter-rouge"> obj </code>和它的子对象调用constexpr构造函数，即使这些对象不是字面类类型。</ul><li><p><strong>常量初始化的效果与其所对应的初始化的效果相同，但保证它在任何其他静态或线程局部对象的初始化前完成，并可能在编译时进行。</strong></p><li><p>一般来说，常量初始化在编译时进行，并将预先计算的对象表示作为程序映像的一部分在 <code class="language-plaintext highlighter-rouge">.data</code> 段存储。如果变量既为 <code class="language-plaintext highlighter-rouge">const</code> 又被常量初始化，那么它会被存储于程序映像的只读段 <code class="language-plaintext highlighter-rouge">.rodata</code> 段。</p></ul><h1 id="非局部变量的静态初始化">非局部变量的静态初始化</h1><p>针对静态变量而言。尤其要注意区分静态成员变量和静态局部变量的区别。单例的笔记中提到了。</p><p>所有具有静态存储期的非局部变量的初始化会作为程序启动的一部分在main 函数的执行之前进行（除非被延迟）。所有具有线程局部存储期的非局部变量的初始化会作为线程启动的一部分进行，按顺序早于线程函数的执行开始。对于这两种变量，初始化发生于两个截然不同的阶段：<strong>静态初始化和动态初始化</strong>。</p><p>动态初始化这里先不提。我们关注一下静态初始化：</p><p>有两种静态初始化的形式：</p><ol><li>如果可能，那么应用常量初始化。<li>否则非局部静态及线程局域变量会被零初始化。</ol><p>实践中：</p><ul><li>常量初始化通常在编译期进行。预先被计算的对象表示会作为程序映像的一部分存储下来。如果编译器没有这样做，那么它仍然必须保证该初始化发生早于任何动态初始化。<li>零初始化的变量将被置于程序映像的 <code class="language-plaintext highlighter-rouge">.bss</code> 段，它不占据磁盘空间，并在加载程序时由操作系统以零填充。</ul><p><strong>注意，静态成员变量虽然属于具有静态存储期的非局部变量，但是在默认初始化中，格外提到了<em>当不带初始化器而声明具有自动、静态或线程局部存储期的变量时</em>是默认初始化。</strong></p><h2 id="个人理解"><span class="mr-2">个人理解</span><a href="#个人理解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong><code class="language-plaintext highlighter-rouge">{}</code>这花括号本身叫做花括号初始化器列表(Brace-init-list)</strong> <a href="https://zh.cppreference.com/w/cpp/language/initialization">在这里</a></p><ul><li><p>个人理解。当是我们<strong>使用花括号初始化器列表进行列表初始化</strong>的时候，如果是聚合类型，看见<code class="language-plaintext highlighter-rouge">{}</code>是聚合初始化(aggregate initialization)</p><li><p>如果不是聚合类型</p><ul><li>如果有<code class="language-plaintext highlighter-rouge">std::initializer_list</code>构造函数，那么它在能匹配<code class="language-plaintext highlighter-rouge">std::initializer_list</code>构造函数的时候就尽可能使用这个构造函数。<li>如果没有<code class="language-plaintext highlighter-rouge">std::initializer_list</code>构造函数，那么它叫做统一初始化（value initialization)。他会寻找其他匹配的构造函数参数来寻找合适的方式初始化对象。<ul><li>如果是类类型，<ul><li>如果构造函数是编译器合成的，则为零初始化（zero initialization）<li>如果构造函数不是编译器合成的，则是值初始化 (value initialization)</ul><li>如果不是类类型，也就是内置类型，就是零初始化（zero initialization）</ul></ul></ul><p><a href="https://www.youtube.com/watch?v=7DTlWPgX6zs">CppCon 2018: Nicolai Josuttis “The Nightmare of Initialization in C++”</a></p><p>https://blog.csdn.net/qq_39583450/article/details/109624599</p><p>https://zh.cppreference.com/w/cpp/language/list_initialization</p><h1 id="非常诡异的例子">非常诡异的例子</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">test</span><span class="p">{</span>
    <span class="n">test</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span> <span class="n">obj</span><span class="p">{};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码在C++11/14/17可以运行，但是20不可以。为什么。</p><p>首先我们看到<code class="language-plaintext highlighter-rouge">test obj{}</code>的时候可能会想到这是值初始化。但是看好了，<code class="language-plaintext highlighter-rouge">test</code>在C++20前。c++11后是聚合体。所以这是聚合初始化。</p><ul><li><p>聚合体的定义在C++11-C++20间有这样一条：</p><ul><li><blockquote><p>没有用户提供、继承或 explicit 的构造函数。</p></blockquote><li><blockquote><p>首个声明被显式预置或显式弃置的时候，不是由用户提供的</p></blockquote><li>所以这里的<code class="language-plaintext highlighter-rouge">=delete</code>不是用户提供的。所以符合要求</ul><li><p>聚合体的定义在C++20后被修改为</p><ul><li><blockquote><p>没有用户声明或继承的构造函数</p></blockquote><li><code class="language-plaintext highlighter-rouge">=delete</code>是用户声明的。所以不符合要求了</ul></ul><p><a href="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/initialization.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-27-%E5%88%9D%E5%A7%8B%E5%8C%96.assets/initialization.png" alt="initialization" class="lazyload" data-proofer-ignore></a></p><p>图片来自<a href="https://pica.zhimg.com/v2-71ee7afb16ed13a42c7e17f74a4bec53_r.jpg">这里</a></p><h1 id="延伸">延伸</h1><h2 id="什么时候会生成未初始化的变量"><span class="mr-2">什么时候会生成未初始化的变量</span><a href="#什么时候会生成未初始化的变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>来自PVS这篇文章的<a href="https://pvs-studio.com/en/blog/posts/cpp/1193/">Program execution: uninitialized variables 章节</a></p><p>如果我们不考虑特殊函数和原始内存分配器，且如果类型是<code class="language-plaintext highlighter-rouge">is_trivially_constructible</code>的 (不知道这个定义的查看模板笔记) 情况下</p><ul><li><code class="language-plaintext highlighter-rouge">T x;</code><li><code class="language-plaintext highlighter-rouge">T x[N];</code><li><code class="language-plaintext highlighter-rouge">T* p = new T;</code><li><code class="language-plaintext highlighter-rouge">T* p = new T[N];</code></ul><p>会产生未初始化的变量/数组（或指向未初始化的变量/数组的指针）。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%88%9D%E5%A7%8B%E5%8C%96%20-%20Sterben_01&url=%2Fposts%2F%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%88%9D%E5%A7%8B%E5%8C%96%20-%20Sterben_01&u=%2Fposts%2F%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E5%2588%259D%25E5%25A7%258B%25E5%258C%2596%2F&text=%E5%88%9D%E5%A7%8B%E5%8C%96%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/EffectiveMC++/" class="btn btn-outline-primary" prompt="上一篇"><p>Effective Modern C++ 笔记</p></a> <a href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" class="btn btn-outline-primary" prompt="下一篇"><p>操作系统相关</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
