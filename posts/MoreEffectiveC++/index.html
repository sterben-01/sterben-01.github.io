<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="More Effective C++ 笔记" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="基础议题 条款4：非必要不提供默认构造" /><meta property="og:description" content="基础议题 条款4：非必要不提供默认构造" /><link rel="canonical" href="/posts/MoreEffectiveC++/" /><meta property="og:url" content="/posts/MoreEffectiveC++/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-27T00:55:00-06:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="More Effective C++ 笔记" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-14T18:24:39-05:00","datePublished":"2023-02-27T00:55:00-06:00","description":"基础议题 条款4：非必要不提供默认构造","headline":"More Effective C++ 笔记","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/MoreEffectiveC++/"},"url":"/posts/MoreEffectiveC++/"}</script><title>More Effective C++ 笔记 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>More Effective C++ 笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>More Effective C++ 笔记</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1677480900" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/02/27 </em> </span> <span> 更新于 <em class="" data-ts="1684106679" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/05/14 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4195 字"> <em>23 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="基础议题">基础议题</h1><h2 id="条款4非必要不提供默认构造"><span class="mr-2">条款4：非必要不提供默认构造</span><a href="#条款4非必要不提供默认构造" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这一点可能和我们之前的认知有差异。但是也是正确的。原因是在语义上或者是设计上，针对某一些类型，如果我们不能提供一个初值来初始化一个对象，那么通过默认构造实例化出来的这个对象会是无意义的。</p><p>当然了，还有很多类型是允许有默认对象的，比如空的容器之类的。</p><ul><li>所以，如果类型展示出：从无到有生成对象是合理的 的语义，则应该有默认构造。<li>但是如果类型展示出：必须有外来信息才能生成对象 的语义，则不应该有默认构造。</ul><p>但是为了表现出这种清晰的语义，会有诸多限制。</p><ul><li>当然，需要注意有些函数或容器强调参数或元素必须是可默认构造的。<li>同时，在继承环境下，如果基类不是可默认构造的，那么就需要显式调用基类的构造。非常头疼。</ul><h1 id="操作符">操作符</h1><h2 id="条款8"><span class="mr-2">条款8</span><a href="#条款8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>查看memory3</p><h1 id="效率">效率</h1><h2 id="条款17-考虑使用-缓式评估"><span class="mr-2">条款17 考虑使用 缓式评估</span><a href="#条款17-考虑使用-缓式评估" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>缓式评估就行copy on write 写时复制一样。当我们调用拷贝构造的时候并不一定拷贝的副本立刻被使用，有可能从不使用或者是从不更改。所以此时可以单独的做一个标记，当真的对副本进行修改的时候再进行构造动作。</p><h2 id="条款18-分期偿还预期的计算成本超急评估"><span class="mr-2">条款18 分期偿还预期的计算成本（超急评估）</span><a href="#条款18-分期偿还预期的计算成本超急评估" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>其实就是和17反过来。如果某些大概率或一定会使用的数据，尤其当这些数据使用频繁的时候，尝试设计一种数据结构进行预加载，当做一种缓存。</p><h2 id="条款21-考虑利用重载来避免隐式类型转换造成的临时对象"><span class="mr-2">条款21 考虑利用重载来避免隐式类型转换造成的临时对象。</span><a href="#条款21-考虑利用重载来避免隐式类型转换造成的临时对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>我们在这一条中讨论的不是是否禁止隐式类型转换，主要是讨论如何降低开销。</strong></p><p>假设我们有这样的简朴的代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myclass</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">myclass</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">myclass</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myclass</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">a</span><span class="o">+</span><span class="mi">20</span><span class="p">;</span>
    <span class="mi">20</span><span class="o">+</span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码会一共构造五次。第一次是<code class="language-plaintext highlighter-rouge">a</code>，第二次是<code class="language-plaintext highlighter-rouge">20</code>的隐式类型转换。第三次是<code class="language-plaintext highlighter-rouge">a+20</code>的返回值。第四次是<code class="language-plaintext highlighter-rouge">20</code>的隐式类型转换，第五次是<code class="language-plaintext highlighter-rouge">20+a</code>的返回值。</p><p>我们此时可以<strong>多</strong>写出两个重载的版本。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">myclass</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">myclass</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">myclass</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span>  <span class="n">rhs</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">myclass</span><span class="p">(</span><span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>之后，执行代码就只会构造三次。分别是<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">a+20</code>和<code class="language-plaintext highlighter-rouge">20+a</code>。没有隐式转换造成的临时对象的开销。</p><h2 id="条款22-针对操作符考虑同时提供复合形式或-和单独形式-"><span class="mr-2">条款22 针对操作符，考虑同时提供复合形式(+=或-=)和单独形式（+，-）</span><a href="#条款22-针对操作符考虑同时提供复合形式或-和单独形式-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>主要原因是如<code class="language-plaintext highlighter-rouge">+=</code>和<code class="language-plaintext highlighter-rouge">-=</code>形式的符合操作符是直接作用于自身，所以返回的是<code class="language-plaintext highlighter-rouge">T&amp;</code>形式。但是单独形式的操作符一般都是<code class="language-plaintext highlighter-rouge">const T</code>形式。所以显然前者效率较高。</p><p>同时，应该以复合形式为基础，实现单独形式 。也就是在<code class="language-plaintext highlighter-rouge">operator+</code>内部使用<code class="language-plaintext highlighter-rouge">operator+=</code>。因为这样只需要更改<code class="language-plaintext highlighter-rouge">operator+=</code>就可以改变其行为。</p><h2 id="条款26-限制某个class所能产生的对象数量"><span class="mr-2">条款26 限制某个class所能产生的对象数量</span><a href="#条款26-限制某个class所能产生的对象数量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>主要讲了单例模式 和 对象数量计数器。需要计算数量的对象可以继承自对象数量计数器基类。行为有一点像侵入式智能指针。</p><p>计数器基类大概长这样<strong>（利用了CRTP）</strong>：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">counts</span><span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">increase</span><span class="p">(){</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">decrease</span><span class="p">(){</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">get</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="n">counts</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">myobj</span> <span class="o">:</span> <span class="n">counts</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">{</span> <span class="c1">//这是一种CRTP。</span>
    <span class="c1">//具体内容  </span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">myobjanother</span> <span class="o">:</span> <span class="n">counts</span><span class="o">&lt;</span><span class="n">myobjanother</span><span class="o">&gt;</span><span class="p">{</span>
  <span class="c1">//具体内容  </span>
<span class="p">};</span>

</pre></table></code></div></div><p>既可以手动分离处理加减，也可以直接在计数器基类的构造或析构函数中计算加减。一个是手动一个是自动而已。</p><h2 id="条款27-要求或禁止对象产生在堆中"><span class="mr-2">条款27 要求或禁止对象产生在堆中</span><a href="#条款27-要求或禁止对象产生在堆中" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="要求对象产生在堆中"><span class="mr-2">要求对象产生在堆中</span><a href="#要求对象产生在堆中" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>将对象的析构函数声明为<code class="language-plaintext highlighter-rouge">protected</code>。如果有继承，则必须要同时声明为<code class="language-plaintext highlighter-rouge">virtual</code>。<ul><li>因为外部无法访问对象的析构函数，则编译器禁止在栈上创建对象<li>声明为<code class="language-plaintext highlighter-rouge">protected</code>而不是<code class="language-plaintext highlighter-rouge">private</code>的目的是让子类可以访问析构函数。<li>注意子类也应该将析构函数声明为<code class="language-plaintext highlighter-rouge">protected</code>，否则子类对象会被允许创建在栈上。<li>注意杂记4中提到的自动储存期限。所以子类如果在栈上，则子类的父类部分也在栈上。子类在堆上，则子类的父类部分也在堆上。<li><strong>格外注意。如果将析构函数声明为<code class="language-plaintext highlighter-rouge">protected</code>或<code class="language-plaintext highlighter-rouge">private</code>，仅意味着不可在外部调用析构函数。但是在该类的成员函数中依旧可以调用析构函数，这意味着在该类的成员函数中，我们依旧可以将对象创建在栈上。</strong></ul><li>声明一个<code class="language-plaintext highlighter-rouge">destroy</code>函数，用于调用析构函数。<ul><li><code class="language-plaintext highlighter-rouge">destroy</code>函数是否为<code class="language-plaintext highlighter-rouge">virtual</code>不重要，因为<code class="language-plaintext highlighter-rouge">delete</code>会调用对应的<code class="language-plaintext highlighter-rouge">virtual</code>析构函数。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">myclass</span><span class="p">{</span>

    <span class="n">myclass</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"myclass const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(){</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">myclassmemberfunction</span><span class="p">(){</span> <span class="c1">//成员函数</span>
        <span class="n">myclass</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">//可以创建在栈上。因为成员函数可以访问到本类的所有成员</span>
    <span class="p">}</span>

    <span class="k">protected</span><span class="o">:</span> <span class="c1">//protected</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">myclass</span><span class="p">(){</span> <span class="c1">//虚函数</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"myclass dest"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nc">derive</span><span class="o">:</span> <span class="k">public</span> <span class="n">myclass</span><span class="p">{</span>
    <span class="n">derive</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"derive const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(){</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">derivememberfunction</span><span class="p">(){</span> <span class="c1">//成员函数</span>
        <span class="n">derive</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">//可以创建在栈上。因为成员函数可以访问到本类的所有成员</span>
    <span class="p">}</span>
    <span class="k">protected</span><span class="o">:</span> <span class="c1">//protected</span>
    <span class="o">~</span><span class="n">derive</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"derive dest"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">myclass</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myclass</span><span class="p">();</span>

    <span class="n">p</span><span class="o">-&gt;</span><span class="n">myclassmemberfunction</span><span class="p">();</span> <span class="c1">//成员函数</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>

    <span class="n">derive</span><span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">derive</span><span class="p">();</span>
    <span class="n">pp</span><span class="o">-&gt;</span><span class="n">derivememberfunction</span><span class="p">();</span> <span class="c1">//成员函数</span>
    <span class="n">pp</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>

    <span class="n">myclass</span><span class="o">*</span> <span class="n">ppp</span> <span class="o">=</span> <span class="k">new</span> <span class="n">derive</span><span class="p">();</span>
    <span class="n">ppp</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="p">();</span>

    <span class="n">myclass</span> <span class="n">pppp</span><span class="p">;</span> 	<span class="c1">//禁止</span>
    <span class="n">derive</span> <span class="n">ppppp</span><span class="p">;</span>	<span class="c1">//禁止</span>



    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="禁止对象产生在堆中"><span class="mr-2">禁止对象产生在堆中</span><a href="#禁止对象产生在堆中" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>非常简单。只需要把<code class="language-plaintext highlighter-rouge">operator new</code> 和<code class="language-plaintext highlighter-rouge"> operator delete</code>声明为<code class="language-plaintext highlighter-rouge">private</code>即可。<ul><li>也可以同时把<code class="language-plaintext highlighter-rouge">operator new[]</code> 和<code class="language-plaintext highlighter-rouge"> operator delete[]</code>声明为<code class="language-plaintext highlighter-rouge">private</code></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myclass</span><span class="p">{</span>

    <span class="n">myclass</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"myclass const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">myclass</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"myclass dest"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span> <span class="c1">//私有</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span> <span class="c1">//私有</span>

<span class="p">};</span>


<span class="k">struct</span> <span class="nc">derive</span><span class="o">:</span> <span class="k">public</span> <span class="n">myclass</span><span class="p">{</span>
    <span class="n">derive</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"derive const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">derive</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"derive dest"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">derive</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">derive</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">derive</span><span class="p">();</span> <span class="c1">//错误</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="条款28-智能指针"><span class="mr-2">条款28 智能指针</span><a href="#条款28-智能指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>都在智能指针章节。</p><h2 id="条款29-引用计数"><span class="mr-2">条款29 引用计数</span><a href="#条款29-引用计数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>大概和智能指针的引用计数理论一致。额外的就是COW相关的实现。还有就是<code class="language-plaintext highlighter-rouge">operator[]</code>的语义，这部分写在effSTL的map的<code class="language-plaintext highlighter-rouge">[]</code>部分了。</p><h2 id="条款-30-代理类"><span class="mr-2">条款 30 代理类</span><a href="#条款-30-代理类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>STL的例子是<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code>参考effective STL 19条</p><p>书里的例子是尝试用别的方法实现重载<code class="language-plaintext highlighter-rouge">operator[][]</code>的语义。因为压根没有<code class="language-plaintext highlighter-rouge">operator[][]</code>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">arr2</span><span class="p">{</span>
    <span class="k">struct</span> <span class="nc">arr1</span><span class="p">{</span> <span class="c1">//代理类</span>
        <span class="n">arr1</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">arr1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">pivot</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">pivot2</span><span class="p">(</span><span class="n">y</span><span class="p">){};</span>  <span class="c1">//假设每个arr1拥有两个元素</span>
        <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">pivot2</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
        <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span> <span class="c1">//返回实际元素的引用，满足赋值要求。</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"arr1 []"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">pivot</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="k">return</span> <span class="n">pivot2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">arr1</span><span class="o">&gt;</span> <span class="n">arrs</span><span class="p">{</span><span class="n">arr1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">arr1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">arr1</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)};</span><span class="c1">//我们假设arr2拥有三个arr1</span>
    <span class="n">arr2</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">arr1</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span> <span class="c1">//代理operator[]，直接返回对应下标的arr1对象的引用。满足赋值要求</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"arr2 []"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">arrs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">arr2</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="k">operator</span><span class="p">[](</span><span class="mi">2</span><span class="p">)).</span><span class="k">operator</span><span class="p">[](</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//等同于上面</span>


    <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//赋值也没问题</span>

    <span class="n">arr2</span><span class="o">::</span><span class="n">arr1</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//单独提取出第一维对象也没问题。</span>
    <span class="c1">//第一个operator[]返回的是arr1对象。所以如果再次链式调用operator[]就会自然匹配到arr1的那个而不是arr2的</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们想模拟二维数组的语义，但是这里模拟的还是有问题。图一乐就行</p><p><code class="language-plaintext highlighter-rouge">obj[2][1]</code>的语义是<code class="language-plaintext highlighter-rouge">(obj.operator[](2)).operator[](1);</code></p><p>我们核心想法是让第一层<code class="language-plaintext highlighter-rouge">arr2</code>储存一堆的<code class="language-plaintext highlighter-rouge">arr1</code>。然后<code class="language-plaintext highlighter-rouge">arr2</code>的<code class="language-plaintext highlighter-rouge">operator[]</code>会返回对应的<code class="language-plaintext highlighter-rouge">arr1</code>对象。此时，如果链式调用，<strong>第二个<code class="language-plaintext highlighter-rouge">operator[]</code>自然会是<code class="language-plaintext highlighter-rouge">arr1</code>的。因为当前的operator<code class="language-plaintext highlighter-rouge">[]</code>是作用在<code class="language-plaintext highlighter-rouge">arr2</code>的<code class="language-plaintext highlighter-rouge">operator[]</code>返回的<code class="language-plaintext highlighter-rouge">arr1</code>上面的那个</strong></p><h3 id="让operator可以区分左值和右值不是真正区分而是区分行为"><span class="mr-2">让operator[]可以区分左值和右值（不是真正区分，而是区分行为）</span><a href="#让operator可以区分左值和右值不是真正区分而是区分行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一般来说，左值是写入行为，右值是读取行为。这个例子只能用书里的。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">String</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//代理类用于区分operator[]的读写操作</span>
    <span class="k">class</span> <span class="nc">CharProxy</span> <span class="p">{</span> <span class="c1">// proxies for string chars</span>
    <span class="nl">public:</span>
        <span class="n">CharProxy</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// creation</span>
        <span class="n">CharProxy</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CharProxy</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// 拷贝赋值。左值运用的场景，这种适用于 s1[3] = s2[8]的场景</span>
        <span class="n">CharProxy</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// 拷贝赋值。左值运用的场景，这种适用于 s2[5] = 'x'的场景</span>
        <span class="k">operator</span> <span class="kt">char</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">//右值运用的场景。</span>
    <span class="nl">private:</span>
        <span class="n">String</span><span class="o">&amp;</span> <span class="n">theString</span><span class="p">;</span> <span class="c1">//用于操作String,并在适当时机开辟新内存并复制</span>
        <span class="kt">int</span> <span class="n">charIndex</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="n">CharProxy</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// string类的 operator[]重载</span>
    <span class="n">CharProxy</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">);</span> <span class="c1">// string类的 operator[]重载</span>
    <span class="p">...</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">CharProxy</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">RCPtr</span><span class="o">&lt;</span><span class="n">StringValue</span><span class="o">&gt;</span> <span class="n">value</span><span class="p">;</span><span class="c1">//见条款29</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li><p>就像书里的例子。<code class="language-plaintext highlighter-rouge">s2[5] = 'x';</code>由于下标访问运算符重载为返回一个代理对象，所以此时的赋值会调用代理类对象的赋值。也就是<code class="language-plaintext highlighter-rouge">CharProxy&amp; operator=(char c);</code>这个函数。这时候<code class="language-plaintext highlighter-rouge">s2[5]</code>的语义是左值。</p><li><p>针对<code class="language-plaintext highlighter-rouge">s1[3] = s2[8]</code>这个场景，虽然我们知道<code class="language-plaintext highlighter-rouge">s2[8]</code>没有写入，应该是个右值。但是注意，因为书中String实现了写时复制，所以<code class="language-plaintext highlighter-rouge">operator[]</code>本身是无成本的。因为代理对象只保有数据的引用。随后直到调用了左侧的代理对象的<code class="language-plaintext highlighter-rouge">CharProxy&amp; operator=(const CharProxy&amp; rhs); </code>这个函数，这时候才开始相应的动作。所以这里我们本身无法区分左值和右值，但是我们可以从行为上区分左值和右值。</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">String</span><span class="o">::</span><span class="n">CharProxy</span><span class="o">&amp;</span> <span class="n">String</span><span class="o">::</span><span class="n">CharProxy</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CharProxy</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">theString</span><span class="p">.</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">isShared</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">theString</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringValue</span><span class="p">(</span><span class="n">theString</span><span class="p">.</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">theString</span><span class="p">.</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">charIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">theString</span><span class="p">.</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">rhs</span><span class="p">.</span><span class="n">charIndex</span><span class="p">];</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>针对如<code class="language-plaintext highlighter-rouge">cout &lt;&lt; s1[2];</code>这种场景，非常明确<code class="language-plaintext highlighter-rouge">s1[2]</code>的行为是右值行为，也就是读取行为。所以说压根没有必要做出任何的额外成本动作</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">String</span><span class="o">::</span><span class="n">CharProxy</span><span class="o">::</span><span class="k">operator</span> <span class="kt">char</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
<span class="k">return</span> <span class="n">theString</span><span class="p">.</span><span class="n">value</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">charIndex</span><span class="p">];</span> <span class="c1">//单纯的返回一个字符。这个data的类型是一个char*数组。所以这个下标访问是内置的。</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>潜在的问题是代理类非常复杂，常常会造成语义的改变。因为目标对象和代理对象的行为常常有细微差异。比如在上文的例子中<code class="language-plaintext highlighter-rouge">char* p = &amp;s[2]</code>就无法通过。<ul><li>因为取出来的地址的类型是代理类类型。无法赋值给<code class="language-plaintext highlighter-rouge">char</code>类。由于我们目标类的<code class="language-plaintext highlighter-rouge">operator[]</code>返回的是代理类对象，所以这时候我们必须重载代理类的取地址运算符<code class="language-plaintext highlighter-rouge">operator&amp;</code></ul><li><p>但是这不能解决所有问题。假设有一个类<code class="language-plaintext highlighter-rouge">A</code>引用了上面的这个蕴含代理类的目标对象，那么直接针对这个<code class="language-plaintext highlighter-rouge">A</code>使用目标对象的<code class="language-plaintext highlighter-rouge">operator[]</code>依旧返回的是代理类对象。此时如果我们想进行函数调用，那么就会出现问题。因为取回来的并不是类<code class="language-plaintext highlighter-rouge">A</code>对象，代理类对象并没有这个特定的成员函数。所以需要在所有的函数上都进行重载让他们也适用于代理类对象。</p><li><p>同时，我不知道为啥上面的目标类的<code class="language-plaintext highlighter-rouge">operator[]</code>一定要返回代理类的对象而不是代理类的引用。则此时在赋值方面会出现问题。</p><li>最后一个问题是隐式类型转换。隐式类型转换中，每一个步骤都只能执行一次。也就是每个步骤都只能进行一个层次的转换。比如<code class="language-plaintext highlighter-rouge">a</code>可以由<code class="language-plaintext highlighter-rouge">int</code>构造，<code class="language-plaintext highlighter-rouge">b</code>可以由<code class="language-plaintext highlighter-rouge">a</code>构造。那么如果一个函数接受一个<code class="language-plaintext highlighter-rouge">b</code>类对象，可以传入<code class="language-plaintext highlighter-rouge">a</code>，但是传入<code class="language-plaintext highlighter-rouge">int</code>就不可以。</ul><h2 id="条款31-让函数根据一个以上的参数类型来决定如何虚化"><span class="mr-2">条款31 让函数根据一个以上的参数类型来决定如何虚化</span><a href="#条款31-让函数根据一个以上的参数类型来决定如何虚化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>主要讲述的是multi-dispatch。</p><p>我们知道，一般来说多态是单个参数的。也就是依靠调用方的多态来决定调用哪个类的函数。那么如何实现多重派发呢（也就是同时根据调用方和入参来进行多态调用）？</p><p>第一个方法是虚函数+RTTI。</p><p>这个办法非常简陋。也就是先设计一层虚函数，然后再对应的虚函数内使用typeid判断，随后执行对应的函数。这种做法效率非常的低，并且伴随着一大堆的cast</p><p>第二个方法就是只使用虚函数</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">banana</span><span class="p">;</span> <span class="c1">//前向声明</span>
<span class="k">struct</span> <span class="nc">apple</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">kiwi</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">fruit</span><span class="p">{</span> <span class="c1">//抽象基类</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">fruit</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//通过该函数决定每一个类的二次派发。</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">banana</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">apple</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">kiwi</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">banana</span><span class="o">:</span><span class="n">fruit</span><span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">fruit</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//通过该函数决定每一个类的二次派发。</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">blend</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">//注意切记不可写反写成this-&gt;blend(obj)。会造成递归调用。</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">banana</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"banana blend banana"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">apple</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"banana blend apple"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">kiwi</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"banana blend kiwi"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">apple</span><span class="o">:</span><span class="n">fruit</span><span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">fruit</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">blend</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">banana</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"apple blend banana"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">apple</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"apple blend apple"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">kiwi</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"apple blend kiwi"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">kiwi</span><span class="o">:</span><span class="n">fruit</span><span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">blend</span><span class="p">(</span><span class="n">fruit</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">blend</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">banana</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"kiwi blend banana"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">apple</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"kiwi blend apple"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">blend</span><span class="p">(</span><span class="n">kiwi</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"kiwi blend kiwi"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">fruit</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">banana</span><span class="p">();</span>

    <span class="n">fruit</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="k">new</span> <span class="n">kiwi</span><span class="p">();</span>
    <span class="n">o</span><span class="o">-&gt;</span><span class="n">blend</span><span class="p">(</span><span class="n">k</span><span class="p">);</span> <span class="c1">//kiwi blend banana</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们看到我们通过两层虚函数来实现两层派发。具体原理是<code class="language-plaintext highlighter-rouge">o-&gt;blend(k)</code>的<code class="language-plaintext highlighter-rouge">o</code>是第一层派发。通过<code class="language-plaintext highlighter-rouge">o</code>的动态类型决定进入对应的类。由于此时我们传入的指针类型是fruit。由于只能子转父，不能父转子，所以必须要有<code class="language-plaintext highlighter-rouge">void blend(fruit* obj)</code>这个东西帮助我们进行第二层派发。<code class="language-plaintext highlighter-rouge">o</code>的动态类型此时是<code class="language-plaintext highlighter-rouge">banana</code>，所以此时进入了<code class="language-plaintext highlighter-rouge">banana</code>的<code class="language-plaintext highlighter-rouge">blend</code>函数。在这个函数中，我们的<code class="language-plaintext highlighter-rouge">obj-&gt;(this)</code>的<code class="language-plaintext highlighter-rouge">obj</code>就是第二层派发。根据<code class="language-plaintext highlighter-rouge">obj</code>的动态类型决定进入对应的类的<code class="language-plaintext highlighter-rouge">blend</code>函数。此时<code class="language-plaintext highlighter-rouge">obj</code>的动态类型是<code class="language-plaintext highlighter-rouge">kiwi</code>。所以此时是调用了<code class="language-plaintext highlighter-rouge">kiwi</code>类的<code class="language-plaintext highlighter-rouge">blend</code>函数。同时我们知道，每个类的<code class="language-plaintext highlighter-rouge">this</code>指针的“类型”都是本类类型。因为它永远指向自己。所以此时<code class="language-plaintext highlighter-rouge">this</code>的类型是<code class="language-plaintext highlighter-rouge">banana</code>。所以最后我们调用了<code class="language-plaintext highlighter-rouge">kiwi</code>类的<code class="language-plaintext highlighter-rouge">banana</code>为参数的函数。</p><p>问题在于这种方案非常的不符合设计理念。因为只要我们增加了一个对应的水果，就要修改每个类型。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=More%20Effective%20C++%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01&url=%2Fposts%2FMoreEffectiveC%2B%2B%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=More%20Effective%20C++%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01&u=%2Fposts%2FMoreEffectiveC%2B%2B%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FMoreEffectiveC%2B%2B%2F&text=More%20Effective%20C++%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 class A { public: virtual std::string clsname() { return &quot;A&quot;; } std::string clsname2() { return &quot;A&quot;; } void test() { std::cout &amp;lt;&amp;lt; &quot;A, &quot; &amp;lt;&amp;lt; clsname()...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/EffectiveC++/" class="btn btn-outline-primary" prompt="上一篇"><p>Effective C++ 笔记</p></a> <a href="/posts/ModernC++Design/" class="btn btn-outline-primary" prompt="下一篇"><p>Modern C++ Design 笔记</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
