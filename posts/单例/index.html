<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="单例模式" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="单例模式" /><meta property="og:description" content="单例模式" /><link rel="canonical" href="/posts/%E5%8D%95%E4%BE%8B/" /><meta property="og:url" content="/posts/%E5%8D%95%E4%BE%8B/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-20T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="单例模式" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-05T00:07:09-05:00","datePublished":"2022-08-20T01:55:00-05:00","description":"单例模式","headline":"单例模式","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E5%8D%95%E4%BE%8B/"},"url":"/posts/%E5%8D%95%E4%BE%8B/"}</script><title>单例模式 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>单例模式</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>单例模式</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1660978500" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/20 </em> </span> <span> 更新于 <em class="" data-ts="1680671229" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/04/05 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3686 字"> <em>20 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="单例模式">单例模式</h1><h2 id="优点"><span class="mr-2">优点：</span><a href="#优点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>只有一个实例所以不需要每次都创建和销毁，可以在启动的时候就创建对象然后永久驻留在内存中。</p><h2 id="缺点"><span class="mr-2">缺点：</span><a href="#缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>有的实现方式是线程不安全的。</p><h2 id="懒汉式"><span class="mr-2">懒汉式：</span><a href="#懒汉式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>懒汉式的意思是，<strong>只有类被实例化的时候才会创建这个单例实例</strong>。意思就是你不能在类里面放一个静态实例了，那样就是饿汉式了。普通的懒汉式是线程不安全的。</p><h3 id="线程不安全版本"><span class="mr-2">线程不安全版本：</span><a href="#线程不安全版本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
	<span class="nl">private:</span>
		<span class="n">Student</span><span class="p">()</span> <span class="o">:</span><span class="n">age</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>									<span class="c1">//私有化构造</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lan_han construct!this age="</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="o">~</span><span class="n">Student</span><span class="p">()</span> <span class="p">{</span>											<span class="c1">//私有化析构</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lan_han destory!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
		<span class="p">};</span>

		<span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">);</span>								<span class="c1">//私有化拷贝构造</span>
		<span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">);</span>						<span class="c1">//私有化拷贝赋值</span>
		<span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
		<span class="k">static</span> <span class="n">Student</span><span class="o">*</span> <span class="n">myInstance</span><span class="p">;</span>								<span class="c1">// 这里是单例对象指针，不是一个实例化对象了。因为是懒汉式，只有用到的时候才会实例化。</span>

	<span class="k">public</span><span class="o">:</span>
		<span class="k">static</span> <span class="n">Student</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span>							<span class="c1">//静态函数，返回一个单例实例的指针。</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">myInstance</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>							<span class="c1">//!此处线程不安全。因为可能有多个线程同时到达这一行后时间片切换，其他线程可能已经实例化单例，切换回去后其余线程又会new出来实例。</span>
			<span class="p">{</span>
				<span class="n">myInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>							
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">myInstance</span><span class="p">;</span><span class="c1">//返回对象指针</span>
		<span class="p">}</span>
		<span class="kt">void</span> <span class="nf">printAge</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">private</span><span class="o">:</span>
		<span class="c1">// 定义一个内部类</span>
		<span class="k">class</span> <span class="nc">CGarbo</span> <span class="p">{</span>
		<span class="nl">public:</span>
			<span class="n">CGarbo</span><span class="p">()</span> <span class="p">{};</span>
			<span class="c1">// 定义一个内部类的静态对象</span>
			<span class="k">static</span> <span class="n">CGarbo</span> <span class="n">m_garbo</span><span class="p">;</span>													

			<span class="o">~</span><span class="n">CGarbo</span><span class="p">()</span><span class="c1">//对象程序结束析构时对主类指针释放内存</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">myInstance</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">delete</span> <span class="n">myInstance</span><span class="p">;</span>
					<span class="n">myInstance</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">};</span>
<span class="p">};</span>
<span class="c1">//记得要初始化静态对象，里面只是定义了他，没有分配内存空间</span>
<span class="n">Student</span><span class="o">*</span> <span class="n">Student</span><span class="o">::</span><span class="n">myInstance</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>						<span class="c1">//为静态对象分配内存</span>
<span class="n">Student</span><span class="o">::</span><span class="n">CGarbo</span> <span class="n">Student</span><span class="o">::</span><span class="n">CGarbo</span><span class="o">::</span><span class="n">m_garbo</span><span class="p">;</span>					<span class="c1">//为静态对象分配内存，类的私有静态变量可以通过作用域访问运算符直接访问</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Student</span><span class="o">*</span> <span class="n">stu_1</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
	<span class="n">stu_1</span><span class="o">-&gt;</span><span class="n">printAge</span><span class="p">();</span>

	<span class="n">Student</span><span class="o">*</span> <span class="n">stu_2</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
	<span class="n">stu_2</span><span class="o">-&gt;</span><span class="n">printAge</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>代码步骤：</p><ul><li>私有化构造，析构，拷贝赋值，拷贝构造。<li>类内放置一个静态的对象指针。<li>类内放置一个静态的成员函数，用作接口来使用户调用，来实例化单例。<li>类内放置一个辅助内部类用于回收单例实例资源。<ul><li>辅助类内部有一个静态辅助类实例。<li>类外初始化该辅助类实例。<li><strong>由于单例的意义是，从程序开始到结束，只有一个实例而且一般不提前销毁。静态变量符合该需求。所以开始时初始化，结束时静态对象被析构。静态对象析构的同时判断单例实例是否已经被销毁，如果没有被销毁则去销毁单例实例。</strong></ul><li>类外初始化单例的静态对象指针。<li>注意，这个版本线程不安全。<ul><li>首先判断我们类外初始化的静态变量是否是nullptr，如果是的话证明该单例从未被实例化过，则可以new出实例然后返回指针。<li>因为可能有多个线程同时到达这一行后时间片切换，其他线程可能已经实例化单例，切换回去后其余线程又会new出来实例。所以不安全。<li><strong>所以，我们直观地想到，加锁不就完了吗？对，但是不全对。</strong></ul></ul><h3 id="线程安全版本"><span class="mr-2">线程安全版本：</span><a href="#线程安全版本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们只需要修改一下获取实例的代码部分即可：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">Student</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span>							<span class="c1">//静态函数，返回一个单例实例的指针。</span>
<span class="p">{</span>	
    <span class="n">my_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>									<span class="c1">//加锁</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">myInstance</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>							<span class="c1">//此时线程安全。</span>
    <span class="p">{</span>
        <span class="n">myInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>							
    <span class="p">}</span>
    <span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>									<span class="c1">//解锁</span>
    <span class="k">return</span> <span class="n">myInstance</span><span class="p">;</span><span class="c1">//返回对象指针</span>
<span class="p">}</span>

</pre></table></code></div></div><p>但是我们发现一个问题，也就是我们使用实例也是通过<code class="language-plaintext highlighter-rouge">getinstance</code>来的。也就是我们如果每次想要新建一个指针来获取到指向实例的指针，都需要调用<code class="language-plaintext highlighter-rouge">getInstance</code>。然后每次都加锁释放锁是非常非常浪费资源的。</p><p>我们同时发现，出现线程不安全的时机几乎只是一开始创建的时候。所以我们发明了双检锁</p><h3 id="线程安全版本双检锁"><span class="mr-2">线程安全版本，双检锁：</span><a href="#线程安全版本双检锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们只需要修改获取示例代码的部分即可：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">Student</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span>							<span class="c1">//静态函数，返回一个单例实例的指针。</span>
<span class="p">{</span>	
    <span class="k">if</span> <span class="p">(</span><span class="n">myInstance</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>							<span class="c1">//先判断是否为空</span>
    <span class="p">{</span>
        <span class="n">my_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>								<span class="c1">//确定空后再加锁</span>
        <span class="k">if</span><span class="p">(</span><span class="n">myInstance</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">){</span>						<span class="c1">//再次判断是否为空</span>
            <span class="n">myInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Student</span><span class="p">();</span>					<span class="c1">//实例化</span>
        <span class="p">}</span>	
        <span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>								<span class="c1">//解锁</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">myInstance</span><span class="p">;</span><span class="c1">//返回对象指针</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们分析一下这段代码。首先，我们外层的判断目的是为了在已经实例化后，直接返回对象指针。<strong>意思就是，我们已经实例化后，不需要加锁去检查是否已经实例化了。再次加锁就是浪费资源。</strong>所以如果已经实例化了，我们再次调用的时候发现非空就可以直接返回对象指针了。</p><p>然后内层的原因就是，我们会有多个线程想去实例化单例。这时候加锁，实例化，解锁。第二个等候锁的线程拿到锁后，发现已经为非空了，此时可以直接返回。所以线程安全。</p><p><strong>但是，双检锁依旧可能失效，原因就是指令重排。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">myInstance</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="p">();</span>	
</pre></table></code></div></div><p>这一行代码，背后是三件事：</p><ol><li>为单例对象分配空间<li>调用单例对象的构造函数来构造对象。<li>让<code class="language-plaintext highlighter-rouge">myInstance</code> 指向分配的空间。</ol><p><strong>但是编译器并不保证这三者的顺序。2和3可能会被交换顺序。</strong></p><p><strong>所以有可能发生下面的事情：线程A先分配了空间，然后交换了2和3导致直接让指针指向了分配的空间，这时时间片到期！此时分配的空间并没有实际构造出单例的实例！然后线程B进来了！它直接判断了现在指针是否为空，非常可惜，此时指针不为空。所以线程B直接返回了一个指向空内存的指针。</strong></p><p>解决这个的办法有很多，比如<code class="language-plaintext highlighter-rouge">pthread_once</code>，内存屏障（<code class="language-plaintext highlighter-rouge">atomic</code> + <code class="language-plaintext highlighter-rouge">std::memory_order_acquire</code>)，volatile（非跨平台）等等。</p><p>但是这种内存屏障的代码会非常复杂，有没有什么其他的方式允许我们实现一个线程安全的单例模式呢？</p><h2 id="饿汉式"><span class="mr-2">饿汉式：</span><a href="#饿汉式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>饿汉式的意思就是，一开始就有一个实例被创建出来，而不是等待类被实例化的时候才创建。意思就是你要在类里面放一个该类的静态实例。这样程序一旦启动就会有实例创建。<strong>线程安全</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Student</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Student</span><span class="p">()</span> <span class="o">:</span><span class="n">age</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>                                            <span class="c1">//私有化构造</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"e_han construct! age="</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>             
    <span class="p">};</span>

    <span class="o">~</span><span class="n">Student</span><span class="p">()</span> <span class="p">{</span>                                                    <span class="c1">//私有化析构</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"e_han destory!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">};</span>

    
    <span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">);</span>                                        <span class="c1">//私有拷贝构造</span>
    <span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">);</span>                             <span class="c1">//私有拷贝赋值</span>
    <span class="k">static</span> <span class="n">Student</span> <span class="n">myInstance</span><span class="p">;</span>                                      <span class="c1">//单例对象在这里！</span>


    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Student</span><span class="o">*</span> <span class="nf">getInstance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">myInstance</span><span class="p">;</span>                                         <span class="c1">//返回单例实例的指针，此处是取地址</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">printAge</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Student</span> <span class="n">Student</span><span class="o">::</span><span class="n">myInstance</span><span class="p">;</span>                                        <span class="c1">//为静态对象分配内存</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Student</span><span class="o">*</span> <span class="n">stu_1</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
    <span class="n">stu_1</span><span class="o">-&gt;</span><span class="n">printAge</span><span class="p">();</span>
    <span class="c1">//对象是全局一开始就建立好的，两个函数获取到的是同一个对象（地址相同）</span>
    <span class="n">Student</span><span class="o">*</span> <span class="n">stu_2</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
    <span class="n">stu_2</span><span class="o">-&gt;</span><span class="n">printAge</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这个就简单很多，因为不涉及到<code class="language-plaintext highlighter-rouge">new</code>所以也不涉及资源回收。而且是线程安全的。</p><p>但是潜在问题在于 <strong>no-local</strong> static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 <code class="language-plaintext highlighter-rouge">getInstance()</code> 方法会返回一个未定义的实例，比如一个全局变量的构造函数中调用了此方法。</p><h2 id="meyers-singleton-也是懒汉式的一种"><span class="mr-2">Meyers Singleton （也是懒汉式的一种）</span><a href="#meyers-singleton-也是懒汉式的一种" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Student</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">Student</span><span class="p">()</span> <span class="o">:</span><span class="n">age</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span> 									<span class="c1">//私有构造</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Student construct! age="</span> <span class="o">&lt;&lt;</span> <span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">};</span>
    <span class="o">~</span><span class="n">Student</span><span class="p">()</span> <span class="p">{</span> 											<span class="c1">//私有析构</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Student destory!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
    <span class="p">};</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>								<span class="c1">//禁用拷贝构造</span>
    <span class="n">Student</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>					<span class="c1">//禁用拷贝赋值</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">()</span>				<span class="c1">//注意是返回单例实例对象的引用</span>
    <span class="p">{</span>   
        <span class="k">static</span> <span class="n">Student</span> <span class="n">myInstance</span><span class="p">;</span>              <span class="c1">//注意这里，这里是局部静态变量而不是类成员变量。局部静态变量的生存周期是从声明起至程序结束。 		</span>
        <span class="k">return</span> <span class="n">myInstance</span><span class="p">;</span>					<span class="c1">//返回实例对象</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">printAge</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu_1</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>	<span class="c1">//注意这里要用引用去接。</span>
    <span class="n">stu_1</span><span class="p">.</span><span class="n">printAge</span><span class="p">();</span>
    <span class="n">Student</span><span class="o">&amp;</span> <span class="n">stu_2</span> <span class="o">=</span> <span class="n">Student</span><span class="o">::</span><span class="n">getInstance</span><span class="p">();</span>
    <span class="n">stu_2</span><span class="p">.</span><span class="n">printAge</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>注意。这里私有析构会造成如果实例化对象，编译时会提示对象无法析构</strong>。<li><strong>这里禁用拷贝构造。这样的话调用拷贝构造的时候编译器会提示错误。</strong><ul><li><strong>如果提供了拷贝构造的定义，就算是私有，也可以调用成功。因为调用的函数是类的成员函数，尽管是静态。</strong></ul></ul><p><strong>在c++11后，当变量在初始化的时候，如果多线程并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</strong></p><ul><li>具体原因可以参考这里。https://stackoverflow.com/questions/17712001/how-is-meyers-implementation-of-a-singleton-actually-a-singleton</ul><p><strong>类内的函数内的变量是局部变量，不算做类的成员，也不占用类的大小。静态也是这样。而且局部静态变量的生存周期是从声明（但是必须程序执行到该对象的声明处）起至程序结束。在这里就是从函数调用开始到程序结束。所以正是利用了这个特性既保证了线程安全，又是懒汉式，又是全局生存周期。</strong></p><h2 id="如果针对这种单例模式我们返回对象会发生什么也就是局部静态变量的拷贝"><span class="mr-2">如果针对这种单例模式，我们返回对象会发生什么？也就是局部静态变量的拷贝</span><a href="#如果针对这种单例模式我们返回对象会发生什么也就是局部静态变量的拷贝" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>静态局部对象会正常拷贝。</p><p>假设我们把单例模式的所有函数都设置为public。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="n">Student</span> <span class="nf">getInstance</span><span class="p">()</span>				
<span class="p">{</span>   
    <span class="k">static</span> <span class="n">Student</span> <span class="n">myInstance</span><span class="p">;</span>  <span class="c1">//除第一次外，其余调用编译器会忽略</span>
    <span class="k">return</span> <span class="n">myInstance</span><span class="p">;</span>	<span class="c1">//正常拷贝。调用拷贝构造    		</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们知道，局部静态变量只允许也只会被初始化一次。如果发现已经被初始化了则会跳过。所以<code class="language-plaintext highlighter-rouge">static Student myInstance;</code>只有在第一次经过的时候会初始化。剩下的调用中会忽略这一行。但是<code class="language-plaintext highlighter-rouge">return myInstance; </code>会正常拷贝。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Student stu_1 = Student::getInstance();
</pre></table></code></div></div><p>如果我们用值去接。则这个过程会拷贝构造两次。有编译器优化就是一次。</p><p>第一次是作为临时对象拷贝出函数。第二次是临时对象拷贝至外部对象。然后临时对象销毁。</p><h3 id="其他实现方式"><span class="mr-2">其他实现方式：</span><a href="#其他实现方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>https://www.cnblogs.com/liyuan989/p/4264889.html</p><h3 id="类的私有静态变量可以通过作用域访问运算符直接访问"><span class="mr-2">类的私有静态变量可以通过作用域访问运算符直接访问</span><a href="#类的私有静态变量可以通过作用域访问运算符直接访问" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="main函数结束也会为栈对象调用析构但是不会为堆对象调用"><span class="mr-2">main函数结束也会为栈对象调用析构，但是不会为堆对象调用。</span><a href="#main函数结束也会为栈对象调用析构但是不会为堆对象调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="单例模式可以把构造函数设置为protected以允许子类继承"><span class="mr-2">单例模式可以把构造函数设置为protected以允许子类继承</span><a href="#单例模式可以把构造函数设置为protected以允许子类继承" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="现在的-c-standard-已经强制要求局部静态对象在第一次被使用时才被构造出来"><span class="mr-2">现在的 C++ Standard 已经强制要求局部静态对象在第一次被使用时才被构造出来。</span><a href="#现在的-c-standard-已经强制要求局部静态对象在第一次被使用时才被构造出来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="局部静态变量只允许也只会被初始化一次如果发现已经被初始化了则会跳过"><span class="mr-2">局部静态变量只允许也只会被初始化一次。如果发现已经被初始化了则会跳过。</span><a href="#局部静态变量只允许也只会被初始化一次如果发现已经被初始化了则会跳过" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>在<strong>块作用域</strong>声明且带有 <code class="language-plaintext highlighter-rouge">static</code> 或 <code class="language-plaintext highlighter-rouge">thread_local</code> (C++11 起) 说明符的变量拥有静态或线程 (C++11 起)存储期，但在控制首次经过它的声明时才会被初始化（除非它被<a href="https://zh.cppreference.com/w/cpp/language/zero_initialization">零初始化</a>或<a href="https://zh.cppreference.com/w/cpp/language/constant_initialization">常量初始化</a>，这可以在首次进入块前进行）。在其后所有的调用中，声明都会被跳过。</p><p>如果初始化<a href="https://zh.cppreference.com/w/cpp/language/throw">抛出异常</a>，那么不认为变量被初始化，且控制下次经过该声明时将再次尝试初始化。</p><p>如果初始化递归地进入正在初始化的变量的块，那么行为未定义。</p><p>如果多个线程试图同时初始化同一静态局部变量，那么初始化严格发生一次（类似的行为也可对任意函数以 <a href="https://zh.cppreference.com/w/cpp/thread/call_once">std::call_once</a> 来达成）。 <strong>注意：此功能特性的通常实现均使用双检查锁定模式的变体，这使得对已初始化的局部静态变量检查的运行时开销减少为单次非原子的布尔比较。</strong></p></blockquote><p><strong>注意，块作用域（block scope）不是类作用域（class scope）。只有块作用域声明且带有<code class="language-plaintext highlighter-rouge">static</code>的才叫局部静态变量。静态类成员变量不是局部静态变量。</strong></p><p><strong>静态成员变量的生存周期是从程序开始到程序结束。和全局变量，全局静态变量一致。而静态局部变量是在控制首次经过它的声明时才会被初始化，然后到程序结束为止。</strong></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20-%20Sterben_01&url=%2Fposts%2F%25E5%258D%2595%25E4%25BE%258B%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20-%20Sterben_01&u=%2Fposts%2F%25E5%258D%2595%25E4%25BE%258B%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E5%258D%2595%25E4%25BE%258B%2F&text=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/HTTP/" class="btn btn-outline-primary" prompt="上一篇"><p>HTTP</p></a> <a href="/posts/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" class="btn btn-outline-primary" prompt="下一篇"><p>深度探索 C++ 对象模型 笔记</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
