<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="计算机网络 - 传输层1" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="计算机网络 - 传输层1" /><meta property="og:description" content="计算机网络 - 传输层1" /><link rel="canonical" href="/posts/NET1/" /><meta property="og:url" content="/posts/NET1/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-23T08:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络 - 传输层1" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-09T01:06:35-05:00","datePublished":"2022-06-23T08:55:00-05:00","description":"计算机网络 - 传输层1","headline":"计算机网络 - 传输层1","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/NET1/"},"url":"/posts/NET1/"}</script><title>计算机网络 - 传输层1 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络 - 传输层1</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计算机网络 - 传输层1</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1655992500" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/06/23 </em> </span> <span> 更新于 <em class="" data-ts="1681020395" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/04/09 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="24874 字"> <em>138 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="计算机网络---传输层1">计算机网络 - 传输层1</h1><h2 id="传输层"><span class="mr-2">传输层</span><a href="#传输层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="传输层的功能"><span class="mr-2">传输层的功能</span><a href="#传输层的功能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>传输层提供<strong>进程与进程</strong>之间的逻辑通信。使用网络层的服务为应用层提供通信服务<li><p>复用和分用</p><ul><li>复用：应用层所有的应用进程都可以通过传输层传输到网络层。 - 分用：传输层从网络层收到的数据可以交付给不同的应用进程。</ul><li>对收到的报文进行差错检测</ol><h2 id="tcp"><span class="mr-2">TCP</span><a href="#tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="三次握手"><span class="mr-2">三次握手<a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623022220.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623022220.png" alt="QQ截图20220623022220" class="lazyload" data-proofer-ignore></a></span><a href="#三次握手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong><code class="language-plaintext highlighter-rouge">ACK不消耗seq</code></strong>，所以如果自己的上一个包是<code class="language-plaintext highlighter-rouge">ACK</code>的话（报文不携带数据），这次的<code class="language-plaintext highlighter-rouge">seq</code>还是上次的<code class="language-plaintext highlighter-rouge">seq</code></p><p><strong>图里说的上一次自己是ACK则这次seq就是上一次的seq，指的是纯ACK包。也就是报文不传输数据的时候</strong></p><p>这里<code class="language-plaintext highlighter-rouge">ack = seq + 1</code> 里面的1其实是接收到的数据的大小。 但是握手阶段不存在这个数据，为了更好理解为何握手/挥手阶段<code class="language-plaintext highlighter-rouge">seq/ack</code>还是要<code class="language-plaintext highlighter-rouge">+1</code>，我们统一给她一个解释：这个握手阶段除了<code class="language-plaintext highlighter-rouge">ack</code>以外的包所搭载的数据叫ghost byte，大小为1。第二种解释是数据大小依旧为0。但是FIN/SYN按照一个字节算。所以+1</p><p><code class="language-plaintext highlighter-rouge">ack</code>确认号是我们下一次希望收到的发送数据的第一个字节的序号 。<strong>当丢包发生的时候。<code class="language-plaintext highlighter-rouge">ack</code>确认号就是接收方所期待的序号最小的没拿到的数据包。</strong>所以这种确认机制可以实现累计确认。</p><p>所以在<strong>握手阶段</strong> 我们客户端首次发送的<code class="language-plaintext highlighter-rouge">seq = x</code>，则我们下一次希望收到的发送数据的第一个字节的序号 应为<code class="language-plaintext highlighter-rouge">x+1</code> 所以服务器发回的<code class="language-plaintext highlighter-rouge">ack = x + 1</code></p><p>所以<code class="language-plaintext highlighter-rouge">ack</code>计算方式是 <code class="language-plaintext highlighter-rouge">ack(out) = seq(last_time_in) + size_of_received_data + (in)SYN/FIN(1)</code></p><p>` seq<code class="language-plaintext highlighter-rouge">序列号是本次所发送数据的第一个字节的序号。假如我们发送 </code>1 2 3<code class="language-plaintext highlighter-rouge"> 所以</code>seq<code class="language-plaintext highlighter-rouge">为</code>1<code class="language-plaintext highlighter-rouge"> 接着我们发送</code>4 5 6 <code class="language-plaintext highlighter-rouge">所以</code>seq<code class="language-plaintext highlighter-rouge">为</code>4 <code class="language-plaintext highlighter-rouge">也就是</code>上一次序号+上一次自己的数据量 = 1 + 3 = 4`</p><p><code class="language-plaintext highlighter-rouge">seq</code>的计算方式是 <code class="language-plaintext highlighter-rouge">seq(out) = 上一次自己的seq + 上一次自己的size_of_data + 上一次自己的SYN/FIN(1)</code></p><p><strong>一般来讲，对方发回的<code class="language-plaintext highlighter-rouge">ack</code>就是自己下一次的<code class="language-plaintext highlighter-rouge">seq</code></strong> 。</p><p>因为采用了延迟确认，客户端连续多次发送数据后，服务器传回的<code class="language-plaintext highlighter-rouge">ack</code>将会是最后一次接收到的客户端报文的<code class="language-plaintext highlighter-rouge">seq + 收到的data</code>。如下图。最后一次接收到的<code class="language-plaintext highlighter-rouge">seq</code>是5121，证明5121之前的数据包都拿到了，大小是1024。所以截止至客户端新发送数据之前，服务器回复的每一次<code class="language-plaintext highlighter-rouge">ack</code>都是<code class="language-plaintext highlighter-rouge">5121+1024 = 6145</code></p><p><strong>注意大小写。小写<code class="language-plaintext highlighter-rouge">ack</code>是序号，大写<code class="language-plaintext highlighter-rouge">ACK</code>指的是这个包是不是<code class="language-plaintext highlighter-rouge">ACK</code>包</strong></p><p>所以说<code class="language-plaintext highlighter-rouge">ACK = 1</code>代表是确认包，所以里面会带有<code class="language-plaintext highlighter-rouge">ack</code>确认序号。也就是希望对面继续发送的数据的第一个字节的序号。</p><h3 id="序列号seq解决乱序问题ack应答码解决丢包问题"><span class="mr-2">序列号<code class="language-plaintext highlighter-rouge">seq</code>解决乱序问题。<code class="language-plaintext highlighter-rouge">ack</code>应答码解决丢包问题</span><a href="#序列号seq解决乱序问题ack应答码解决丢包问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623195418.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623195418.png" alt="QQ截图20220623195418" class="lazyload" data-proofer-ignore></a></p><h3 id="延迟确认"><span class="mr-2">延迟确认</span><a href="#延迟确认" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>简单的说，Delay Ack就是延时发送ACK，在收到数据包的时候，会检查是否需要发送ACK，如果需要的话，进行快速ACK还是延时ACK，在无法使用快速确认的条件下，就会使用Delay Ack。</p><p>TCP在何时发送ACK的时候有如下规定：</p><p>1.当有响应数据发送的时候，ACK会随着数据一块发送</p><p>2.如果没有响应数据，ACK就会有一个延迟，以等待是否有响应数据一块发送，但是这个延迟一般在40ms~500ms之间，一般情况下在40ms左右，如果在40ms内有数据发送，那么ACK会随着数据一块发送，对于这个延迟的需要注意一下，这个延迟并不是指的是收到数据到发送ACK的时间延迟，而是内核会启动一个定时器，每隔200ms就会检查一次，比如定时器在0ms启动，200ms到期，180ms的时候data来到，那么200ms的时候没有响应数据，ACK仍然会被发送，这个时候延迟了20ms.</p><p>3.如果在等待发送ACK期间，第二个数据又到了，这时候就要立即发送ACK！</p><p>优点：减少了数据段的个数，提高了发送效率</p><p>缺点：过多的delay会拉长RTT</p><h3 id="累计确认"><span class="mr-2">累计确认</span><a href="#累计确认" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>累计确认指的是TCP当前的ack应答码一定是保证了这个应答码之前的所有数据已经全部收到了。</strong></p><ul><li>所以在丢包的时候，我们回复的ack应答码是丢失的数据的第一个字节（接收方所期待的序号最小的没拿到的数据包）。<li>所以如果没有丢包而是丢了ACK应答报文，则由于滑动窗口的存在，所以我们可以用这种累计确认（下一次应答）来进行确认，而且不会进行数据重发。</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034441.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034441.png" alt="QQ截图20220805034441" class="lazyload" data-proofer-ignore></a></p><h3 id="四次挥手-主动关闭的一方才有timewait"><span class="mr-2">四次挥手 （主动关闭的一方才有timewait）</span><a href="#四次挥手-主动关闭的一方才有timewait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623024124-16559727402733.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220623024124-16559727402733.png" alt="QQ截图20220623024124" class="lazyload" data-proofer-ignore></a></p><ul><li>当客户端发送链接释放报文段之后，客户端停止发送数据。主动关闭TCP链接。也就是第一次FIN。之后客户端进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_1</code> 状态。<strong>（此时仅仅表示客户端不需要发送数据了，但还可以接受数据）</strong><li>服务器接受到客户端发送的释放报文段后，回送一个ack报文段。客户到服务器的这个方向的连接也就被释放了。此时是<strong>半关闭状态</strong>。服务端进入 <code class="language-plaintext highlighter-rouge">CLOSED_WAIT</code> 状态。（<strong>此时表示为服务端知道了客户端不发送了，但是服务端可能还要发送</strong>）<li>客户端收到服务端的 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文后，之后进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_2</code> 状态。<li>服务器发送/处理完剩余数据后，也发送链接释放报文段。主动关闭TCP链接。也就是第二次FIN。之后服务端进入 <code class="language-plaintext highlighter-rouge">LAST_ACK</code> 状态。（<strong>服务端处理完剩下的数据后，才发送FIN表示我也完事儿了。可以彻底关闭</strong>）<li>客户端接受到后，回送一个ack报文段。进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态。服务器收到了 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文后，就进入了 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态，至此服务端已经完成连接的关闭。<li>再等到时间等待计时器设置的2MSL（最长报文段寿命）后，客户端进入 <code class="language-plaintext highlighter-rouge">CLOSED</code> 状态，链接彻底关闭。</ul><p>如果客户端发送的确认报文段</p><h3 id="注意事项"><span class="mr-2">注意事项</span><a href="#注意事项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>主动关闭连接的，才有 <code class="language-plaintext highlighter-rouge">TIME_WAIT 状态</code>。<li><strong>四次挥手之所以为四次就是因为可以半关闭状态。也就是服务器可能还要发送一些数据给客户端。理论上四次挥手也可以换成三次。如果服务器在收到客户端的 <code class="language-plaintext highlighter-rouge">FIN</code> 时没有更多数据或根本没有数据要发送，则可以将 ack 和 fin 合并为一个包。</strong> 或者，因为延迟确认的特性，可以把ACK,FIN（第二次和第三次挥手)和要发的数据一起发过去，这样也是三次挥手。<li>需要三次握手而不是两次握手的原因之一是：为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。<ul><li>假设客户端先发了一个序列号为90的<code class="language-plaintext highlighter-rouge">SYN</code>请求报文, 但是它在网络中某个节点被阻塞了, 然后客户端又发送了另一个新的<code class="language-plaintext highlighter-rouge">SYN</code>请求报文, 序列号为100, 但是旧的请求报文比新的先到达服务端, 然后服务端回返回一个<code class="language-plaintext highlighter-rouge">SYN ACK</code>报文, 其中<code class="language-plaintext highlighter-rouge">ACK</code>确认号为91, 这显然是错的, 客户端收到该<code class="language-plaintext highlighter-rouge">ACK</code>报文之后, 发现确认号为91而不是101, 判定这是一个历史连接, 客户端就发送一个<code class="language-plaintext highlighter-rouge">RST</code>报文回去告知服务端, 终止这次连接。</ul><li><strong>在连接建立后，所有传送的报文段都必须把ACK置为1。</strong><li>TCP <strong>不会为没有数据的<code class="language-plaintext highlighter-rouge">ACK</code></strong>包进行重传。<strong>当没有数据的<code class="language-plaintext highlighter-rouge">ACK</code> 包丢失了，就由对方重传对应的报文</strong>。<li>握手阶段的前两次不可以携带数据。第三次<code class="language-plaintext highlighter-rouge">ACK</code>可以携带数据。也就是<code class="language-plaintext highlighter-rouge">SYN=1</code>的报文段不可以携带数据。<li>挥手阶段的FIN包可以携带数据</ol><h2 id="挥手比握手多一次的原因就是握手阶段前两次无法发送数据所以响应和发送syn和ack可以要连起来挥手阶段一方关闭连接了另一方还可能发送所以响应和发送fin和ack是分开的"><span class="mr-2">挥手比握手多一次的原因就是，握手阶段，前两次无法发送数据，所以响应和发送（SYN和ACK）可以要连起来。挥手阶段一方关闭连接了另一方还可能发送。所以响应和发送（FIN和ACK）是分开的</span><a href="#挥手比握手多一次的原因就是握手阶段前两次无法发送数据所以响应和发送syn和ack可以要连起来挥手阶段一方关闭连接了另一方还可能发送所以响应和发送fin和ack是分开的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="握手丢失会发生什么"><span class="mr-2">握手丢失会发生什么？</span><a href="#握手丢失会发生什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第一次握手丢失了会发生什么--客户端超时重传syn超过次数断开"><span class="mr-2">第一次握手丢失了，会发生什么？ – 客户端超时重传SYN，超过次数断开。</span><a href="#第一次握手丢失了会发生什么--客户端超时重传syn超过次数断开" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code class="language-plaintext highlighter-rouge">SYN_SENT</code> 状态。</p><p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文。</p><p>不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。<strong>重传的 SYN 报文的序列号都是一样的</strong></p><p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p><p>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code class="language-plaintext highlighter-rouge">tcp_syn_retries</code>内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p><p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p><p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p><p>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。</p><p><strong>当第一次握手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824195815.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824195815.png" alt="QQ截图20220824195815" class="lazyload" data-proofer-ignore></a></p><ul><li>当客户端超时重传 3 次 SYN 报文后，由于 ` tcp_syn_retries <code class="language-plaintext highlighter-rouge">为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（</code>SYN-ACK `报文），那么客户端就会断开连接</ul><h3 id="第二次握手丢失了会发生什么--客户端超时重传syn服务端超时重传syn-ack超过次数断开"><span class="mr-2">第二次握手丢失了，会发生什么？ – 客户端超时重传SYN,服务端超时重传SYN-ACK，超过次数断开</span><a href="#第二次握手丢失了会发生什么--客户端超时重传syn服务端超时重传syn-ack超过次数断开" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code class="language-plaintext highlighter-rouge">SYN_RCVD</code> 状态。</p><p>第二次握手的 <code class="language-plaintext highlighter-rouge">SYN-ACK</code> 报文其实有两个目的 ：</p><ul><li>第二次握手里的 ACK， 是对第一次握手的确认报文；<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</ul><p>所以，如果第二次握手丢了，就会发送比较有意思的事情，具体会怎么样呢？</p><p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p><p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p><p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p><p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code class="language-plaintext highlighter-rouge">tcp_synack_retries</code>内核参数决定，默认值是 5。</p><p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p><ul><li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code class="language-plaintext highlighter-rouge">tcp_syn_retries</code>内核参数决定；<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code class="language-plaintext highlighter-rouge">tcp_synack_retries</code> 内核参数决定。</ul><p><strong>当第二次握手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824195907.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824195907.png" alt="QQ截图20220824195907" class="lazyload" data-proofer-ignore></a></p><ul><li>当客户端超时重传 1 次<code class="language-plaintext highlighter-rouge"> SYN</code> 报文后，由于 ` tcp_syn_retries<code class="language-plaintext highlighter-rouge"> 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（</code>SYN-ACK` 报文），那么客户端就会断开连接。<li>当服务端超时重传 2 次 <code class="language-plaintext highlighter-rouge">SYN-ACK</code> 报文后，由于 <code class="language-plaintext highlighter-rouge">tcp_synack_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code class="language-plaintext highlighter-rouge">ACK</code> 报文），那么服务端就会断开连接。</ul><h3 id="第三次握手丢失了会发生什么--服务端超时重传syn-ack超过次数断开因为客户端的纯ack不带数据的ack是不会重传的如果此时客户端发送数据则服务器会发送rst表示断开连接"><span class="mr-2">第三次握手丢失了，会发生什么？ – 服务端超时重传SYN-ACK，超过次数断开。因为客户端的纯ACK（不带数据的ACK）是不会重传的。如果此时客户端发送数据，则服务器会发送RST表示断开连接。</span><a href="#第三次握手丢失了会发生什么--服务端超时重传syn-ack超过次数断开因为客户端的纯ack不带数据的ack是不会重传的如果此时客户端发送数据则服务器会发送rst表示断开连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code class="language-plaintext highlighter-rouge">ESTABLISH</code> 状态。</p><p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p><p><strong>当第三次握手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824200047.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824200047.png" alt="QQ截图20220824200047" class="lazyload" data-proofer-ignore></a></p><ul><li>服务端超时重传 2 次 SYN-ACK 报文后，由于 <code class="language-plaintext highlighter-rouge">tcp_synack_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（<code class="language-plaintext highlighter-rouge">ACK</code> 报文），那么服务端就会断开连接。</ul><h2 id="挥手丢失会发生什么"><span class="mr-2">挥手丢失会发生什么？</span><a href="#挥手丢失会发生什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="第一次挥手丢失了会发生什么-客户端超时重传fin超过次数直接close"><span class="mr-2">第一次挥手丢失了，会发生什么？ –客户端超时重传FIN，超过次数直接close</span><a href="#第一次挥手丢失了会发生什么-客户端超时重传fin超过次数直接close" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code class="language-plaintext highlighter-rouge">FIN_WAIT_1</code> 状态。</p><p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code class="language-plaintext highlighter-rouge">FIN_WAIT2</code>状态。</p><p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 <code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code> 参数控制。</p><p>当客户端重传 FIN 报文的次数超过 <code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code> 后，就不再发送 FIN 报文，直接进入到 <code class="language-plaintext highlighter-rouge">close</code> 状态。</p><p><strong>当第一次挥手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824203900.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824203900.png" alt="QQ截图20220824203900" class="lazyload" data-proofer-ignore></a></p><ul><li>当客户端超时重传 3 次 <code class="language-plaintext highlighter-rouge">FIN</code> 报文后，由于 <code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code> 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code class="language-plaintext highlighter-rouge">ACK</code>报文），那么客户端就会断开连接。</ul><h3 id="第二次挥手丢失了会发生什么-客户端超时重传fin超过次数直接close因为服务器的纯ack不会重传"><span class="mr-2">第二次挥手丢失了，会发生什么？– 客户端超时重传FIN，超过次数直接close。因为服务器的纯ACK不会重传</span><a href="#第二次挥手丢失了会发生什么-客户端超时重传fin超过次数直接close因为服务器的纯ack不会重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code class="language-plaintext highlighter-rouge">CLOSE_WAIT</code> 状态。</p><p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p><p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code class="language-plaintext highlighter-rouge">FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204227.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204227.png" alt="QQ截图20220824204227" class="lazyload" data-proofer-ignore></a></p><p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以<code class="language-plaintext highlighter-rouge">FIN_WAIT2</code> 状态不可以持续太久，而 <code class="language-plaintext highlighter-rouge">tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</p><p><strong>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。</strong></p><p><strong>但是注意，如果主动关闭方使用 shutdown 函数关闭连接且指定只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code class="language-plaintext highlighter-rouge">FIN_WAIT2</code> 状态（<code class="language-plaintext highlighter-rouge">tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204236.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204236.png" alt="QQ截图20220824204236" class="lazyload" data-proofer-ignore></a></p><p><strong>当第二次挥手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204001.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204001.png" alt="QQ截图20220824204001" class="lazyload" data-proofer-ignore></a></p><ul><li>当客户端超时重传 2 次 <code class="language-plaintext highlighter-rouge">FIN</code> 报文后，由于 <code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（<code class="language-plaintext highlighter-rouge">ACK</code> 报文），那么客户端就会断开连接。</ul><h3 id="第三次挥手丢失了会发生什么-服务端超时重传fin超过次数直接close"><span class="mr-2">第三次挥手丢失了，会发生什么？– 服务端超时重传FIN，超过次数直接close</span><a href="#第三次挥手丢失了会发生什么-服务端超时重传fin超过次数直接close" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code class="language-plaintext highlighter-rouge">CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p><p><strong>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</strong></p><p>服务端处于<code class="language-plaintext highlighter-rouge"> CLOSE_WAIT </code>状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 <code class="language-plaintext highlighter-rouge">LAST_ACK</code> 状态，等待客户端返回 ACK 来确认连接关闭。</p><p>如果客户端迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code class="language-plaintext highlighter-rouge">tcp_orphan_retrie</code>s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p><p><strong>当第三次挥手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204407.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204407.png" alt="QQ截图20220824204407" class="lazyload" data-proofer-ignore></a></p><ul><li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 tcp_orphan_retries 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。<li>客户端因为是通过 close 函数关闭连接的，处于 FIN_WAIT_2 状态是有时长限制的，如果 tcp_fin_timeout 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</ul><h3 id="第四次挥手丢失了会发生什么-服务端超时重传fin超过次数断开因为客户端的纯ack不会重传"><span class="mr-2">第四次挥手丢失了，会发生什么？– 服务端超时重传FIN，超过次数断开。因为客户端的纯ACK不会重传。</span><a href="#第四次挥手丢失了会发生什么-服务端超时重传fin超过次数断开因为客户端的纯ack不会重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态。</p><p>在 Linux 系统，<code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态会持续 2MSL 后才会进入关闭状态。</p><p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于<code class="language-plaintext highlighter-rouge"> LAST_ACK</code> 状态。</p><p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code> 参数控制。</p><p><strong>当第四次挥手一直丢失时，发生的过程如下图</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204725.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220824204725.png" alt="QQ截图20220824204725" class="lazyload" data-proofer-ignore></a></p><ul><li>当服务端重传第三次挥手报文达到 2 时，由于 tcp_orphan_retries 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。<li>客户端在收到第三次挥手后，就会进入 TIME_WAIT 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</ul><h2 id="关于-time_wait"><span class="mr-2">关于 TIME_WAIT</span><a href="#关于-time_wait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="为什么需要-time_wait-状态"><span class="mr-2">为什么需要 TIME_WAIT 状态？</span><a href="#为什么需要-time_wait-状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li><p>防止历史连接中的数据，被后面相同四元组的连接错误的接收。</p><p>服务端在关闭连接之前发送的报文，被网络延迟了。接着，服务端以相同的四元组重新打开了新连接，前面被延迟的报文这时抵达了客户端，而且该数据报文的序列号刚好在客户端接收窗口内，因此客户端会正常接收这个数据报文，但是这个数据报文是上一个连接残留下来的，这样就产生数据错乱等严重的问题。为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code class="language-plaintext highlighter-rouge">2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><li><p>保证「被动关闭连接」的一方，能被正确的关闭</p><p>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSED 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p><p><strong>简单来说就是，如果第四次握手丢了，服务端会超时重传FIN，如果没有TIME_WAIT（客户端直接close)则客户端会回复一个RST。不够优雅。</strong></p><p>为了防止这种情况出现，客户端必须等待足够长的时间确保对端收到 ACK，如果对端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。</p></ul><h3 id="为什么-time_wait-等待的时间是-2msl"><span class="mr-2">为什么 TIME_WAIT 等待的时间是 2MSL？</span><a href="#为什么-time_wait-等待的时间是-2msl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code class="language-plaintext highlighter-rouge">TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 <code class="language-plaintext highlighter-rouge">FIN</code> 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。</p><p><strong><code class="language-plaintext highlighter-rouge">2MSL</code> 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时</strong>。</p><p>在 Linux 系统里 <code class="language-plaintext highlighter-rouge">2MSL</code> 默认是 <code class="language-plaintext highlighter-rouge">60</code> 秒，那么一个 <code class="language-plaintext highlighter-rouge">MSL</code> 也就是 <code class="language-plaintext highlighter-rouge">30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><h3 id="半连接队列和全连接队列"><span class="mr-2">半连接队列和全连接队列</span><a href="#半连接队列和全连接队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在服务端当中，对socket执行bind方法可以绑定监听端口，然后执行<code class="language-plaintext highlighter-rouge">listen方法</code>后，就会进入监听（<code class="language-plaintext highlighter-rouge">LISTEN</code>）状态。内核会为每一个处于<code class="language-plaintext highlighter-rouge">LISTEN</code>状态的<code class="language-plaintext highlighter-rouge">socket</code> 分配两个队列，分别叫<strong>半连接队列和全连接队列</strong>。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629093515.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629093515.png" alt="QQ截图20220629093515" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code class="language-plaintext highlighter-rouge">这个连接对应的文件描述符</code>加入到这个队列中，队列内的<code class="language-plaintext highlighter-rouge">文件描述符对应的连接</code>都处于<code class="language-plaintext highlighter-rouge">SYN_RCVD</code> 状态。<li><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code class="language-plaintext highlighter-rouge">文件描述符</code>取出，放到全连接队列中。队列里的<code class="language-plaintext highlighter-rouge">文件描述符对应的连接</code>都处于 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code>状态。这里面的文件描述符，就<strong>等着服务端执行accept()后被取出了。</strong></ul><p><strong>全连接队列（<code class="language-plaintext highlighter-rouge">icsk_accept_queue</code>）是个链表</strong>，而<strong>半连接队列（<code class="language-plaintext highlighter-rouge">syn_table</code>）是个哈希表</strong>。</p><p>所以建立连接的过程中根本不需要<code class="language-plaintext highlighter-rouge">accept()</code> 参与， <strong>执行accept()只是为了从全连接队列里取出对应的文件描述符。</strong></p><p><strong><code class="language-plaintext highlighter-rouge">listen</code>函数的<code class="language-plaintext highlighter-rouge">backlog</code>控制的是全连接队列（ACCEPT队列）队列的大小。</strong></p><h4 id="为什么半连接队列要设计成哈希表"><span class="mr-2">为什么半连接队列要设计成哈希表</span><a href="#为什么半连接队列要设计成哈希表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>先对比下<strong>全连接里队列</strong>，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为<code class="language-plaintext highlighter-rouge">O(1)</code>。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到<code class="language-plaintext highlighter-rouge">O(1)</code>了。因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><h4 id="全连接队列满了会怎么样"><span class="mr-2">全连接队列满了会怎么样？</span><a href="#全连接队列满了会怎么样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。但除了丢弃之外，还有一些附带行为，这会受 <code class="language-plaintext highlighter-rouge">tcp_abort_on_overflow</code> 参数的影响。</p><ul><li><code class="language-plaintext highlighter-rouge">tcp_abort_on_overflow</code>设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的<strong>半连接队列里的连接</strong>给删掉。<strong>也就是丢弃链接</strong></ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094504.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094504.png" alt="QQ截图20220629094504" class="lazyload" data-proofer-ignore></a></p><ul><li><code class="language-plaintext highlighter-rouge">tcp_abort_on_overflow</code>设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094528.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094528.png" alt="QQ截图20220629094528" class="lazyload" data-proofer-ignore></a></p><h4 id="半连接队列要是满了会怎么样-syn攻击"><span class="mr-2">半连接队列要是满了会怎么样 （SYN攻击）</span><a href="#半连接队列要是满了会怎么样-syn攻击" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>一般是丢弃</strong>，但这个行为可以通过 <code class="language-plaintext highlighter-rouge">tcp_syncookies</code> 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。</p><p>首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了<strong>SYN Flood攻击</strong>。</p><p>所谓<strong>SYN Flood攻击</strong>，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。</p><p>那这种情况怎么处理？有没有一种方法可以<strong>绕过半连接队列</strong>？</p><p>有，<code class="language-plaintext highlighter-rouge">tcp_syncookies</code>派上用场了。它被设置为1的时候，客户端发来<strong>第一次握手</strong>SYN时，服务端<strong>不会将其放入半连接队列中</strong>，而是直接生成一个<code class="language-plaintext highlighter-rouge">cookies</code>，这个<code class="language-plaintext highlighter-rouge">cookies</code>会跟着<strong>第二次握手</strong>，发回客户端。客户端在发<strong>第三次握手</strong>的时候带上这个<code class="language-plaintext highlighter-rouge">cookies</code>，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094704.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220629094704.png" alt="QQ截图20220629094704" class="lazyload" data-proofer-ignore></a></p><h5 id="cookies方案为什么不直接取代半连接队列"><span class="mr-2"><strong>cookies方案为什么不直接取代半连接队列？</strong></span><a href="#cookies方案为什么不直接取代半连接队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>目前看下来<code class="language-plaintext highlighter-rouge">syn cookies</code>方案省下了半连接队列所需要的队列内存，还能解决 <strong>SYN Flood攻击</strong>，那为什么不直接取代半连接队列？</p><p>凡事皆有利弊，<code class="language-plaintext highlighter-rouge">cookies</code>方案虽然能防 <strong>SYN Flood攻击</strong>，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p><p>另外，编码解码<code class="language-plaintext highlighter-rouge">cookies</code>，都是比较<strong>耗CPU</strong>的，利用这一点，如果此时攻击者构造大量的<strong>第三次握手包（ACK包）</strong>，同时带上各种瞎编的<code class="language-plaintext highlighter-rouge">cookies</code>信息，服务端收到<code class="language-plaintext highlighter-rouge">ACK包</code>后<strong>以为是正经cookies</strong>，憨憨地跑去解码（<strong>耗CPU</strong>），最后发现不是正经数据包后才丢弃。</p><p>这种通过构造大量<code class="language-plaintext highlighter-rouge">ACK包</code>去消耗服务端资源的攻击，叫<strong>ACK攻击</strong>，受到攻击的服务器可能会因为<strong>CPU资源耗尽</strong>导致没能响应正经请求。</p><h3 id="全连接队列半连接队列总结"><span class="mr-2">全连接队列，半连接队列总结</span><a href="#全连接队列半连接队列总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>每一个</strong><code class="language-plaintext highlighter-rouge">socket</code>执行<code class="language-plaintext highlighter-rouge">listen</code>时，内核都会自动创建一个半连接队列和全连接队列。<li>第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。<li><code class="language-plaintext highlighter-rouge">accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。<li>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。<li>全连接队列满了，再来第三次握手也会丢弃，此时如果<code class="language-plaintext highlighter-rouge">tcp_abort_on_overflow=1</code>，还会直接发<code class="language-plaintext highlighter-rouge">RST</code>给客户端。<li>半连接队列满了，可能是因为受到了<code class="language-plaintext highlighter-rouge">SYN Flood</code>攻击，可以设置<code class="language-plaintext highlighter-rouge">tcp_syncookies</code>，绕开半连接队列。<li>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开。</ul><h3 id="杂项"><span class="mr-2">杂项</span><a href="#杂项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>同步位<code class="language-plaintext highlighter-rouge">SYN = 1</code> 时表明这是一个连接请求/接受报文。</p><li><p>紧急位<code class="language-plaintext highlighter-rouge">URG = 1</code> 的时候表明此报文段有紧急数据。不用在缓存队列中排队。配合紧急指针使用。</p><li><p>紧急指针指向的是紧急数据在此报文段中的末位位置。假如紧急指针 = 100，则1~100为紧急数据。</p><li><p>复位<code class="language-plaintext highlighter-rouge">RST = 1</code>的时候表明TCP连接出现严重错误。需要释放连接再重新连接</p><li><p>推送位<code class="language-plaintext highlighter-rouge">PSH = 1</code>时表明接收方应尽快将数据交付给应用程序，不需要等到缓存填满再交付。</p><li>终止位<code class="language-plaintext highlighter-rouge">FIN = 1</code>时表明此报文段发送方数据已经发送完毕，需要释放连接<li>bind()设置套接字的本地（源）地址。这是接收数据包的地址。套接字发送的数据包将此作为源地址，因此其他主机将知道将其数据包发送回哪里。 这句话的意思就是你接收到了数据包之后，bind告诉系统你发到这个端口和ip的数据包要发给某个特定的文件描述符。所以只有接受需求的时候才会用bind。客户端不写bind是因为内核自动选择了一个端口。 如果不需要接收，则套接字源地址是无用的。像 TCP 这样的协议需要启用接收才能正确发送，因为当一个或多个数据包到达时，目标主机会发回确认（即确认）。<li>被动接收的一端都要绑定一个端口，主动发送的一端一般都是系统分配端口<li>标准TCP只有单播因为是点对点，只有UDP有多播和组播<li>调用send函数仅仅是把数据拷贝到发送的缓存区。具体发送不是应用程序可控的。所以说send就算不返回错误也有可能发送失败。<li>如果服务器重启，大量客户端重新连接进来，如果服务器处理accept队列不及时将会发生连接被拒绝的错误。</ul><h3 id="为什么tcpudp套接字服务器端需要绑定端口号客户端不需要"><span class="mr-2">为什么TCP、UDP套接字服务器端需要绑定端口号客户端不需要？</span><a href="#为什么tcpudp套接字服务器端需要绑定端口号客户端不需要" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>IP地址和端口号是用来标识具体某一台主机上的具体一个进程的。也就是说，端口号可以用来标识主机上的某一个进程。<li>因此，操作系统需要对端口号进行管理，并且计算机中的端口号是有限的。<li>如果不进行绑定，操作系统会随机生成一个端口号给服务器。如果操作系统给服务器分配这个端口号的同时，有其他程序也准备使用这个端口号或者说端口号已经被使用，则可能会导致服务器一直启动不起来。<li>其次，服务器运行起来就不会在停止了，我们将服务器端的端口号绑定有助于有规划的对主机中的端口号进行使用。<li>客户端需要主动向服务器端发送请求，因此客户端就需要知道服务器端的IP地址和端口号，如果不绑定让系统随机生成，客户端将无法知道服务器端的端口号，即使知道也需要每次都去获取。<li>对于客户端来说，服务器端并不需要主动给客户端发送数据，客户端是主动的而服务器端是被动的。客户端给服务器端发送数据时，会将自己的IP地址和端口号一起发送过去，服务器端可以方便的找到客户端。<li>同时，客户端并不是一直运行的，只需要每次系统随机分配即可。<li>因此，服务器端需要绑定而客户端不需要绑定。</ol><h2 id="tcp-传输控制协议和-udp-用户数据报协议的区别"><span class="mr-2">TCP （传输控制协议）和 UDP （用户数据报协议）的区别</span><a href="#tcp-传输控制协议和-udp-用户数据报协议的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><p>连接</p><ul><li><p>TCP 是<strong>面向连接</strong>的，传输数据前先要建立连接。有拥塞控制，流量控制等。</p><li><p>UDP 是无连接的。没有拥塞控制，流量控制等。</p></ul><li><p>数据类型（传输方式）</p><ul><li>TCP是字节流。流式传输，没有边界<li>UDP是报文流。一个包一个包传输，可能丢失或乱序。</ul></ol>3. 服务对象<div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre> - TCP只支持一对一
 - UDP支持一对一，一对多，多对一和多对多。
 	4. 可靠性
 - TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
 - UDP 是尽最大努力交付，不保证可靠交付数据。
 	5. 报文首部开销
 - TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
 - UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
</pre></table></code></div></div><h2 id="tcp保证可靠性"><span class="mr-2">TCP保证可靠性</span><a href="#tcp保证可靠性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>数据分段：在发送端对数据进行分段，在接收端重组，由TCP确认分段的大小并控制分段和重组<li>确认应答（ACK）：接收端-&gt;发送端（最后一个字节的序号+1）<li>超时重传：发送端：维护一个超时定时器，如果在定时器超时之后没有收到想要的确认，重发分段<li>滑动窗口：接收端一次接收发送端最大能发送数据的大小，保证处理能力不一样的两端不会数据（缓冲区）溢出<li>失序处理：接收端将数据整理，把数据以正确的顺序交给应用层。<li>重复处理：包因为延迟（超时时长定义有问题），导致接收端收到了重复的包，要丢弃重复的数据。<li>数据校验：首部和尾部序号的校验，如果不对，会导致超时重传。</ol><h2 id="mss"><span class="mr-2">MSS</span><a href="#mss" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>MSS是TCP的最大报文长度<li>MSS不包括TCP头。也就是纯数据<ul><li>举个例子。MTU是1500，标准情况下，MTU = IP头（20） + TCP头（20） + TCP数据（1460）<li>这里的MSS就是1460</ul><li><strong>MSS主要作用是为了避免TCP报文在IP层分片</strong>。包括和滑动窗口配合<strong>与对方协商</strong>自己可以接受多少数据。在TCP的分段中，每一个分段包都有自己的TCP头部，也方便重组。<li>如果已经在TCP分段好的数据仍然大于MTU则还需要IP分片。<li><strong>MSS在三次握手阶段和每次发送的时候都会传递给对方。然后双方按照二者最小的那一个值做为通信的MSS值。这就叫MSS协商。</strong><li>MSS大于了协商值就会在TCP层分段</ul><h2 id="mtu"><span class="mr-2">MTU</span><a href="#mtu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>首先我们应该还记得，IP是网络层，TCP是传输层。TCP把数据打包好给IP的网络层，IP网络层再次打包好放到数据链路层。<strong>这个MTU（最大传输单元）就是数据链路层的</strong>。它规定了一个<strong>帧</strong>有多大。<li>一般来说它的大小是1500<li>MTU = IP头+（TCP/UDP头+TCP/UDP数据）<li>IP头大小没有特殊情况是20字节<li>MTU大于1500了就要在IP层分片。</ul><h3 id="ip层叫分片tcp叫分段"><span class="mr-2">IP层叫分片，TCP叫分段。</span><a href="#ip层叫分片tcp叫分段" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="不传递mss会怎么样"><span class="mr-2">不传递MSS会怎么样</span><a href="#不传递mss会怎么样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>没有接收到对方的MSS，本测按照默认值发送。(536字节)</p><p>因为IP层的最小重组缓冲区是576，那么576-20（tcp头）-20（ip头）就是536</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/v2-8fc147d1e13653975c3ddd6101baee7d_r.jpg" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/v2-8fc147d1e13653975c3ddd6101baee7d_r.jpg" alt="v2-8fc147d1e13653975c3ddd6101baee7d_r" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804211738.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804211738.png" alt="QQ截图20220804211738" class="lazyload" data-proofer-ignore></a></p><h2 id="为什么既然-ip-层会分片为什么-tcp-层还需要-mss-呢"><span class="mr-2">为什么既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</span><a href="#为什么既然-ip-层会分片为什么-tcp-层还需要-mss-呢" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先，我们上次提到过。TCP报文在TCP层分段的时候，每一段都会带着自己的TCP头（因为是给数据分段，MSS也是数据大小不包括TCP头，所以每一段数据切割好之后都会被加上TCP头做为一个独立报文。如果IP分片的话IP是不会给报文接TCP头的。只会给自己加上IP头。</p><p>而且 IP层没有超时重传机制。需要依靠TCP。</p><p>假如现在丢包了。因为TCP没分段，是交给了IP分片。所以整个数据只有一个TCP头（一个TCP序列号）。一旦丢包需要把整个一大块传给了IP的TCP报文全部重传（这里虽然可能由于数据过大，IP给数据分为了多片，但是这一堆分片的数据依旧是属于一个TCP报文的因为只占一个TCP序列号。举个例子就是说假如有6000字节，TCP没分段，给了IP，IP分成了4*1500。如果其中的一个1500丢了，整个6000全部重传）。</p><p>如果TCP也分段了。因为避免了IP重新分片。所以IP拿到了这个报文直接就发出去了，而且这每一个小报文段都带有TCP的序列号。如果丢包了只需要传递丢的这一小块数据就可以了。因为每一小段都是完整报文段，有自己的序列号。</p><h3 id="所以说tcp报文头没有ip报文头的禁止分片更多分片的这个标志因为ip分片的话数据是瞎瘠薄切里面可能会有不完整的tcp报文段可能切在中间了所以到了之后需要合起来tcp的数据不会被瞎瘠薄切每一段都是完整的报文所以他用序列号就可以了推测"><span class="mr-2">所以说TCP报文头没有IP报文头的（禁止分片/更多分片）的这个标志。因为IP分片的话数据是瞎瘠薄切。里面可能会有不完整的TCP报文段。可能切在中间了。所以到了之后需要合起来。TCP的数据不会被瞎瘠薄切，每一段都是完整的报文。所以他用序列号就可以了。（推测）</span><a href="#所以说tcp报文头没有ip报文头的禁止分片更多分片的这个标志因为ip分片的话数据是瞎瘠薄切里面可能会有不完整的tcp报文段可能切在中间了所以到了之后需要合起来tcp的数据不会被瞎瘠薄切每一段都是完整的报文所以他用序列号就可以了推测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="mss一定能避免ip层分片吗--不一定"><span class="mr-2">MSS一定能避免IP层分片吗？ – 不一定</span><a href="#mss一定能避免ip层分片吗--不一定" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>不一定，因为不一定每一段路由的MTU都是1500，有可能小于1500.这时候可能需要再次IP分片。</p><h2 id="udp不分段所以只能依靠ip层分片"><span class="mr-2">UDP不分段，所以只能依靠IP层分片</span><a href="#udp不分段所以只能依靠ip层分片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h1 id="tcp-ip协议栈">TCP-IP协议栈</h1><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804192446.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804192446.png" alt="QQ截图20220804192446" class="lazyload" data-proofer-ignore></a></p><h2 id="ip是网络层协议"><span class="mr-2">IP是网络层协议</span><a href="#ip是网络层协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>IP报文头一般是20字节。除了可变部分以外。</p><h3 id="ip分段-注意传输层tcp里面叫分段网络层ip层叫分片"><span class="mr-2">IP分段 注意传输层TCP里面叫分段，网络层IP层叫分片。</span><a href="#ip分段-注意传输层tcp里面叫分段网络层ip层叫分片" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>网络层发现报文（IP头+（TCP/UDP头+TCP/UDP数据））大小大于1500，则需要分片。</p><h1 id="tcp-超时重传">TCP 超时重传</h1><p>指的是发送方在超过一定时间之内没有收到对方的<code class="language-plaintext highlighter-rouge">ACK</code>应答包的时候，会重发该数据。</p><p><strong>有两种情况会触发超时重传</strong></p><ul><li>数据包丢失<li>确认应答包丢失</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804223402.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804223402.png" alt="QQ截图20220804223402" class="lazyload" data-proofer-ignore></a></p><h2 id="rtt"><span class="mr-2">RTT</span><a href="#rtt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>数据发送时刻到接收到确认的时刻的差值</strong>就是RTT</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804223448.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220804223448.png" alt="QQ截图20220804223448" class="lazyload" data-proofer-ignore></a></p><ul><li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</ul><p>所以<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p><h2 id="快重传机制fast-transmit属于拥塞控制注意不是快恢复注意快重传是数据驱动的超时重传是时间驱动的一个是看应答码一个是算时间"><span class="mr-2">快重传机制（Fast transmit属于拥塞控制。注意不是快恢复。）注意快重传是数据驱动的，超时重传是时间驱动的！一个是看应答码，一个是算时间。</span><a href="#快重传机制fast-transmit属于拥塞控制注意不是快恢复注意快重传是数据驱动的超时重传是时间驱动的一个是看应答码一个是算时间" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>TCP应答确认一定是有序的。即发送1234，如果2丢了则就算收到了34那么应答码<code class="language-plaintext highlighter-rouge">ack</code>也依旧是2，当丢包发生的时候。<code class="language-plaintext highlighter-rouge">ack</code>确认号就是接收方所期待的序号最小的没拿到的数据包。</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805031036.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805031036.png" alt="QQ截图20220805031036" class="lazyload" data-proofer-ignore></a></p><p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；<li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；<li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</ul><p><strong>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</strong></p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p><p>举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p><ul><li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为假如 Seq3 报文也丢失了，还得在后续收到三个重复的 ACK3 才能触发重传。<li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</ul><p>可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题。</p><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code class="language-plaintext highlighter-rouge">SACK</code> 方法。</p><h3 id="sack-方法选择性确认"><span class="mr-2">SACK 方法（<strong>选择性确认</strong>）</span><a href="#sack-方法选择性确认" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code class="language-plaintext highlighter-rouge">SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p><strong>说白了，就是一个数据段告诉对方我收到的是什么，如果触发了快重传则发送方看一眼这个SACK数据段缺哪块，就发送哪块。</strong></p><p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code class="language-plaintext highlighter-rouge">SACK</code> 信息发现只有 <code class="language-plaintext highlighter-rouge">200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805031827.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805031827.png" alt="QQ截图20220805031827" class="lazyload" data-proofer-ignore></a></p><h3 id="duplicate-sack-d-sack重复选择性确认"><span class="mr-2">Duplicate SACK (D-SACK)重复选择性确认</span><a href="#duplicate-sack-d-sack重复选择性确认" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>和SACK的主要区别是<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><p><strong>使用场景1：丢包</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805033509.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805033509.png" alt="QQ截图20220805033509" class="lazyload" data-proofer-ignore></a></p><ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）<li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code class="language-plaintext highlighter-rouge">D-SACK</code>。<li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</ul><p>使用场景2：延迟</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805033922.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805033922.png" alt="QQ截图20220805033922" class="lazyload" data-proofer-ignore></a></p><ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。<li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；<li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</ul><h4 id="总结"><span class="mr-2">总结：</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;<li>可以知道是不是「发送方」的数据包被网络延迟了;<li>可以知道网络中是不是把「发送方」的数据包给复制了;</ol><h1 id="tcp滑动窗口">TCP滑动窗口</h1><p>如果每一次发送数据都要进行一次ACK未免效率有点低。所以有了滑动窗口的概念。</p><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。这个值在报文头会写。就是<code class="language-plaintext highlighter-rouge">window</code>字段。这玩意和MSS没啥关系。<strong>因为滑动窗口是操作系统的缓存区大小</strong></p><p>假设窗口大小为 <code class="language-plaintext highlighter-rouge">3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code class="language-plaintext highlighter-rouge">3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034441-165968923920913.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034441-165968923920913.png" alt="QQ截图20220805034441" class="lazyload" data-proofer-ignore></a></p><p><strong>通常窗口的大小是由接收方的窗口大小来决定的。但是也会针对网络拥塞情况进行适当缩小、</strong></p><h4 id="发送方滑动窗口分为四个部分-swnd"><span class="mr-2">发送方滑动窗口分为四个部分 SWND</span><a href="#发送方滑动窗口分为四个部分-swnd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034735.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034735.png" alt="QQ截图20220805034735" class="lazyload" data-proofer-ignore></a></p><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节（这部分可以删除）<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节<li>#3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节<li>#4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后</ul><p>在下图，当发送方把数据「全部」都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，在没收到 ACK 确认之前是无法继续发送数据了。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034928.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805034928.png" alt="QQ截图20220805034928" class="lazyload" data-proofer-ignore></a></p><p>在下图，当收到之前发送的数据 <code class="language-plaintext highlighter-rouge">32~36</code> 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则<strong>滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认</strong>，接下来 <code class="language-plaintext highlighter-rouge">52~56</code> 字节又变成了可用窗口，那么后续也就可以发送 <code class="language-plaintext highlighter-rouge">52~56</code> 这 5 个字节的数据了。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805035006.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805035006.png" alt="QQ截图20220805035006" class="lazyload" data-proofer-ignore></a></p><h4 id="所以滑动窗口就是确认多少滑动多少"><span class="mr-2">所以滑动窗口就是确认多少，滑动多少。</span><a href="#所以滑动窗口就是确认多少滑动多少" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h4 id="接收方的窗口分为三个部分-rwnd"><span class="mr-2">接收方的窗口分为三个部分 RWND</span><a href="#接收方的窗口分为三个部分-rwnd" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805035154.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805035154.png" alt="QQ截图20220805035154" class="lazyload" data-proofer-ignore></a></p><ul><li>#1 + #2 是已成功接收并确认的数据（等待应用进程读取）；<li>#3 是未收到数据但可以接收的数据；<li>#4 未收到数据并不可以接收的数据；</ul><h3 id="接收方未按序收到的报文在什么位置"><span class="mr-2">接收方未按序收到的报文在什么位置？</span><a href="#接收方未按序收到的报文在什么位置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805054344.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805054344.png" alt="QQ截图20220805054344" class="lazyload" data-proofer-ignore></a></p><ul><li>最左边报文一定是尚未收到的报文<li>如果31没到，32，33先到，就先把32，33缓存在接收缓冲区中，并且会发送3个对31的确认报文（快重传），当收到了31后，那么窗口就继续滑动到34的位置.<li>注意ack包的确认号一定是下一个期望收到的数据的起始号。所以这里传回的ack不会是34而是31</ul><h1 id="tcp流量控制">TCP流量控制</h1><p>我们刚才说了滑动窗口的主要作用是不用每次都等到ACK之后才能再次发送。但是滑动窗口的大小也不是固定的。因为可能我现在比较忙，处理不过来，如果我来不及确认，但是你一直在那发，就会出现超时重传。</p><p>举个例子，你让我拆快递，没有滑动窗口就是我拆完一个，告诉你我拆完了，你再给我一个。有滑动窗口就是你给我了一张桌子，只要桌子没满你就一直在那放。但是桌子是固定大小的，可能我出去上了个厕所，虽然桌子没满但是我没在，你一直在这放导致很多快递来不及拆，你以为快递被人偷了就重新买了又放在了桌子上，很消耗资源。所以我让这个桌子是变长的。</p><p>所以，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，也就是避免「发送方」的数据填满「接收方」的缓存。这就是所谓的流量控制。</strong></p><ul><li>滑动窗口的总大小一般情况下是固定的，但是可用窗口是变化的。所以接收方的大小就是 总大小 - 已接收的但是未被处理的数据的大小。一旦数据已被处理，则可用窗口会扩大（滑动）。<li>发送方的大小就是总大小 - 已发送但未确认的数据的大小。一旦收到ACK确认则可用窗口会扩大（滑动）<li>每一次接收端发送ACK的时候都会把自己的接受窗口大小<code class="language-plaintext highlighter-rouge">rwnd</code>告知对方，这样的话对方就可以动态调整自己的发送窗口大小。<li>一旦接收端发送的<code class="language-plaintext highlighter-rouge">rwnd</code>为0，就发生了<strong>窗口关闭</strong>。</ul><h3 id="窗口关闭"><span class="mr-2">窗口关闭</span><a href="#窗口关闭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当接收方发送的ACK报文附带的<code class="language-plaintext highlighter-rouge">rwnd</code>为0的时候，就发生窗口关闭。</p><p>当接收方处理完了数据，<code class="language-plaintext highlighter-rouge">rwnd</code>又有空间的时候，会再次发送一个ACK报文，告诉发送方自己的窗口大小，（可以发送数据）。<strong>但是一旦这个ACK报文丢了，就会出现死锁。因为发送方等着这个ACK才能发，接受方已经发了ACK迟迟没拿到数据</strong>。</p><p>这时候就有一个东西叫做持续计时器。<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>（这个报文携带1字节数据），而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；<li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</ul><p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 <code class="language-plaintext highlighter-rouge">RST</code> 报文来中断连接。</p><p><strong>就算接收方的<code class="language-plaintext highlighter-rouge">rwnd</code>为0，接受方也必须接受零窗口探测报文段（ACK），确认报文段和携带紧急数据的报文段。</strong></p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805054019.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805054019.png" alt="QQ截图20220805054019" class="lazyload" data-proofer-ignore></a></p><h3 id="窗口过小导致数据传输效率问题"><span class="mr-2">窗口过小导致数据传输效率问题</span><a href="#窗口过小导致数据传输效率问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假如说应用程序读取数据很少，则每一次的窗口的大小会越来越小。这样假如告诉你我窗口是1字节你再给我发1字节这样非常浪费资源。由此，我们可以有两个选择。</p><ul><li>一个是接收方窗口小于某个值的时候，就当做0处理，发送rwnd为0<ul><li>当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code class="language-plaintext highlighter-rouge">0</code>，也就阻止了发送方再发数据过来。<li>等到接收方处理了一些数据后，窗口大小 &gt;= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</ul><li>另外一个是让发送方避免发送过小的数据包。（<strong>Nagle</strong>）</ul><h3 id="nagle算法"><span class="mr-2">Nagle算法</span><a href="#nagle算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>如果包长度达到<code class="language-plaintext highlighter-rouge">MSS</code>（或含有<code class="language-plaintext highlighter-rouge">Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code class="language-plaintext highlighter-rouge">MSS</code>的话，就会进行拆分发送；<li>等待超时（一般为<code class="language-plaintext highlighter-rouge">200ms</code>），第一个包没到<code class="language-plaintext highlighter-rouge">MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。<li>一般telnet和ssh这种小包交互的时候会关闭这个算法。</ul><h1 id="tcp拥塞控制-拥塞窗口cwndcongestion-window">TCP拥塞控制 拥塞窗口CWND(Congestion Window)</h1><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p><strong>拥塞窗口 cwnd</strong>是<strong>发送方</strong>维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><ul><li><strong>cwnd = n意思是可以发送n个报文段（n个MSS）</strong></ul><p>我们在前面提到过发送窗口 <code class="language-plaintext highlighter-rouge">swnd</code> 和接收窗口 <code class="language-plaintext highlighter-rouge">rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是<code class="language-plaintext highlighter-rouge">swnd = min(cwnd, rwnd)</code>，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code class="language-plaintext highlighter-rouge">cwnd</code> 就会增大；<li>但网络中出现了拥塞，<code class="language-plaintext highlighter-rouge">cwnd</code> 就减少；</ul><h2 id="如何判断网络是否拥塞了呢"><span class="mr-2">如何判断网络是否拥塞了呢？</span><a href="#如何判断网络是否拥塞了呢" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>很简单，超时重传了就会认为网络出现拥塞</p><h2 id="有哪些拥塞控制算法"><span class="mr-2">有哪些拥塞控制算法？</span><a href="#有哪些拥塞控制算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>慢启动<li>拥塞避免<li>拥塞发生<ul><li>超时重传<li><strong>快重传</strong></ul><li>快恢复 <strong>（注意不是快重传）</strong></ol><h3 id="慢启动指数增长"><span class="mr-2">慢启动（指数增长）</span><a href="#慢启动指数增长" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？（TCP链接完成后无法确认网络状况是否良好，一次发了一大堆万一丢了又得重传很脑瘫。所以一开始一点一点地尝试发）</p><ul><li><strong>慢启动算法规则：</strong>当发送方<strong>每收到一个 ACK</strong>，拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd </code>的大小就会加 1。注意是每次收到一个ACK。所以是<strong>指数增长</strong></ul><p>例子：</p><p>这里假定拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd</code> 和发送窗口 <code class="language-plaintext highlighter-rouge">swnd</code> 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 <code class="language-plaintext highlighter-rouge">cwnd = 1</code>，表示可以传一个 <code class="language-plaintext highlighter-rouge">MSS</code> 大小的数据。<li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个<li>当收到 <strong>2 个的 ACK</strong> 确认应答后， cwnd <strong>增加 2</strong>，于是就可以比之前多发2 个，<strong>所以这一次能够发送 4 个</strong><li>当这<strong>4 个的 ACK **确认到来的时候，</strong>每个确认 cwnd 增加 1<strong>， **4 个确认 cwnd 增加 4</strong>，于是就可以比之前多发 4 个，所以这一次能够<strong>发送 8 个</strong>。</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809060754.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809060754.png" alt="QQ截图20220809060754" class="lazyload" data-proofer-ignore></a></p><h4 id="cwnd直到涨到慢启动阈值slow-start-thresh的时候会发生状态改变"><span class="mr-2"><strong>cwnd直到涨到慢启动阈值（Slow Start thresh）的时候会发生状态改变</strong></span><a href="#cwnd直到涨到慢启动阈值slow-start-thresh的时候会发生状态改变" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>当 <code class="language-plaintext highlighter-rouge">cwnd</code> &lt; <code class="language-plaintext highlighter-rouge">ssthresh</code> 时，使用慢启动算法。<li>当 <code class="language-plaintext highlighter-rouge">cwnd</code> &gt;= <code class="language-plaintext highlighter-rouge">ssthresh</code> 时，就会使用「<strong>拥塞避免算法</strong>」。</ul><h3 id="拥塞避免算法加法增大线性增长"><span class="mr-2">拥塞避免算法（“加法增大”，线性增长）</span><a href="#拥塞避免算法加法增大线性增长" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>顾名思义，结合前面我们提到过当拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd</code> 「超过」慢启动门限 <code class="language-plaintext highlighter-rouge">ssthresh</code> 就会进入拥塞避免算法，我们可以理解为：我们为了效率，肯定希望一次尽可能发送更多的数据包。但是为了不干扰他人，又不能像之前一样指数增长，那我们采用折中的方法，<strong>当收到一个 ACK 时，cwnd 增加 1。也就是线性增长</strong>。</p><p><strong>但是，就这么一直增长，迟早要进入拥堵阶段，也就是发生了丢包。这时候就需要重传了。当触发了重传机制的时候，也就是进入了下一个阶段：「拥塞发生」</strong></p><h3 id="拥塞发生"><span class="mr-2">拥塞发生</span><a href="#拥塞发生" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传<li><strong>快速重传</strong></ul><h4 id="发生超时重传的拥塞发生算法"><span class="mr-2">发生超时重传的拥塞发生算法：</span><a href="#发生超时重传的拥塞发生算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><code class="language-plaintext highlighter-rouge">ssthresh</code> 设为 拥塞窗口的一半（<code class="language-plaintext highlighter-rouge">cwnd/2</code>）。<li><code class="language-plaintext highlighter-rouge">cwnd</code> 恢复为<code class="language-plaintext highlighter-rouge"> cwnd</code> 初始化值，这里假定 cwnd 初始化值 1<li>然后进入到<strong>慢启动</strong>阶段。</ul><p><strong>因为慢启动会极大地减少数据流，所以会发生严重的网络卡顿。</strong>所以会有快重传的拥塞发生算法</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809062600.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809062600.png" alt="QQ截图20220809062600" class="lazyload" data-proofer-ignore></a></p><h4 id="发生快速重传的拥塞发生算法"><span class="mr-2">发生快速重传的拥塞发生算法：</span><a href="#发生快速重传的拥塞发生算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，ACK会发送丢了的那个包的序列号。如果接收端发现收到了三次前一个包的 ACK，于是发送端就会快速地重传，<strong>不必等待超时再重传</strong>。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code class="language-plaintext highlighter-rouge">ssthresh</code> 和 <code class="language-plaintext highlighter-rouge">cwnd</code> 变化如下：</p><ul><li><code class="language-plaintext highlighter-rouge">cwnd = cwnd/2</code> ，也就是设置为原来的一半;（注意区别，超时重传的时候cwnd会恢复为默认值）<li><code class="language-plaintext highlighter-rouge">ssthresh = cwnd/2</code>;<li>进入<strong>快速恢复算法</strong></ul><h3 id="快恢复"><span class="mr-2">快恢复</span><a href="#快恢复" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code class="language-plaintext highlighter-rouge">RTO</code> 超时（重传超时）那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code class="language-plaintext highlighter-rouge">cwnd</code> 和 <code class="language-plaintext highlighter-rouge">ssthresh</code> 已被更新了：这俩都是原来<code class="language-plaintext highlighter-rouge">cwnd</code>的一半。</p><p>然后进入快恢复阶段：</p><ul><li>拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = ssthresh + 3</code> （ 3 的意思是快速重传时已经确认接收到了 3 个重复的ACK数据包）；<li>重传丢失的数据包；<li>如果再收到重复的 ACK，那么 cwnd 增加 1；<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809064515.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220809064515.png" alt="QQ截图20220809064515" class="lazyload" data-proofer-ignore></a></p><h3 id="为什么快恢复长得和理论的图不太一样"><span class="mr-2">为什么快恢复长得和理论的图不太一样？</span><a href="#为什么快恢复长得和理论的图不太一样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>在快速恢复的过程中，首先 ssthresh = cwnd/2，然后 <code class="language-plaintext highlighter-rouge">cwnd = ssthresh + 3</code>，表示网络可能出现了阻塞，所以需要减小 <code class="language-plaintext highlighter-rouge">cwnd </code>以避免，加 3 代表快速重传时已经确认接收到了 3 个重复的ACK数据包；<li>随后继续重传丢失的数据包，如果再收到重复的 ACK，那么 cwnd 增加 1。加 1 代表每个收到的重复的 ACK 包，都已经离开了网络。<strong>这个过程的目的是尽快将丢失的数据包发给目标。</strong><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，恢复过程结束。</ol><p><strong>首先，快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变。</strong></p><p><strong>其次，过程2（cwnd逐渐加1）的存在是为了尽快将丢失的数据包发给目标，从而解决拥塞的根本问题（三次相同的 ACK 导致的快速重传），所以这一过程中 cwnd 反而是逐渐增大的。</strong></p><h1 id="拥塞控制和流量控制的区别">拥塞控制和流量控制的区别</h1><ul><li>流量控制，的目的就是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。<strong>理解为数据包可到达，但是避免接收方来不及处理</strong><ul><li>rwnd窗口由接收方调整</ul><li>拥塞控制，的目的就是避免「发送方」的数据填满整个网络。<strong>理解为避免数据包可能会发生不可到达，避免耗尽网络资源</strong><ul><li>cwnd窗口由发送方调整。</ul></ul><h1 id="面试题相关">面试题相关</h1><h2 id="没有accept能否建立tcp链接--可以"><span class="mr-2">没有accept能否建立TCP链接？ – 可以</span><a href="#没有accept能否建立tcp链接--可以" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>上文的全连接队列和半连接队列提到了。第一次握手会放入半连接，三次握手后放入全连接。</p><p><strong>accept的目的仅仅是从全连接队列取出一条连接而已。</strong></p><h3 id="accept-底层实现"><span class="mr-2">accept 底层实现</span><a href="#accept-底层实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">accept()</code>函数，就使用来 <strong>从 全连接队列 中 的队首 (队头) 位置取出来一项 (每一项都是一个已经完成三次握手的TCP连接)，返回给进程。</strong><li><code class="language-plaintext highlighter-rouge">accept</code>会以文件描述符的形式返回一个套接字。这个套接字就是我们项目里的读写文件描述符。<li>如果已完成连接队列是空的呢？<ul><li>那么<code class="language-plaintext highlighter-rouge">accept()</code>会一致卡在这里【休眠】等待，一直到已完成队列中有一项时才会被唤醒。</ul></ul><h2 id="没有listen能否建立tcp链接--不可以"><span class="mr-2">没有listen能否建立TCP链接？ – 不可以</span><a href="#没有listen能否建立tcp链接--不可以" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>服务端如果只 bind 了 IP 地址和端口，而没有调用 listen 的话，然后客户端对服务端发起了连接建立，服务端会回 RST 报文。</strong></p><h3 id="listen底层实现"><span class="mr-2">listen底层实现</span><a href="#listen底层实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>维护一个半连接队列和一个全连接队列。<code class="language-plaintext highlighter-rouge">listen</code>调用后，监听到第一次握手就放入半连接队列，三次握手完毕后放入全连接队列。</p><h2 id="fin-报文一定得调用关闭连接的函数才会发送吗--不一定"><span class="mr-2">FIN 报文一定得调用关闭连接的函数，才会发送吗？ – 不一定</span><a href="#fin-报文一定得调用关闭连接的函数才会发送吗--不一定" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。</p><h2 id="tcp的第三次握手能不能携带数据--可以"><span class="mr-2">TCP的第三次握手能不能携带数据？ – 可以</span><a href="#tcp的第三次握手能不能携带数据--可以" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805001644.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805001644.png" alt="QQ截图20220805001644" class="lazyload" data-proofer-ignore></a></p><p>上图可以看到，第二次我握手的时候客户端已经切换到ESTABLISHED所以可以携带数据。</p><h2 id="客户端发送完第三次握手后是不是不管服务器有没有收到直接就发送数据--是的"><span class="mr-2">客户端发送完第三次握手后，是不是不管服务器有没有收到，直接就发送数据？ – 是的</span><a href="#客户端发送完第三次握手后是不是不管服务器有没有收到直接就发送数据--是的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>不然不就是四次握手了么</p><h2 id="如果因为各种原因服务端并未收到客户端发来的第三次握手包那客户端后续发送的数据服务端如何处理"><span class="mr-2">如果因为各种原因，服务端并未收到客户端发来的第三次握手包，那客户端后续发送的数据，服务端如何处理？</span><a href="#如果因为各种原因服务端并未收到客户端发来的第三次握手包那客户端后续发送的数据服务端如何处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>如果第三次握手包服务器没有收到，就直接发送数据，服务器将这个携带应用数据的包当做第三次握手（前提是这一个包中携带有ACK标记）。</strong></p><h2 id="为什么三次握手必须由客户端发起"><span class="mr-2">为什么三次握手必须由客户端发起</span><a href="#为什么三次握手必须由客户端发起" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为客户端是主动端，服务端是被动端。</p><p>服务端不知道客户端的IP地址。放到项目里就是我们监听的时候，客户端发送的数据包是含有自己的ip和端口地址的。所以我们可以利用。</p><h2 id="为什么要进行三次握手两次或四次行不行"><span class="mr-2"><strong>为什么要进行三次握手，两次或四次行不行</strong></span><a href="#为什么要进行三次握手两次或四次行不行" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<ul><li>详细点就是说假如有一个客户端的历史已经失效的报文段突然到达，则服务端以为是客户端想要建立链接。如果是两次握手的话，服务端再发送一次就可以建立连接了。但是客户端并没有需求，造成了浪费也有可能发送错误数据。、<li>第二点就是SYN SYNACK ACK这三个阶段中，客户端向服务端发送SYN，则服务端收到了并且也向客户端发送了SYN，然后客户端再次ACK才能保证双方都收到了序列号。不然无法保证客户端也受到了服务端的SYN报文。</ul><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</ul><h2 id="为什么要四次挥手三次两次行不行"><span class="mr-2">为什么要四次挥手，三次两次行不行？</span><a href="#为什么要四次挥手三次两次行不行" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>四次挥手之所以为四次就是因为可以半关闭状态。也就是服务器可能还要发送一些数据给客户端。理论上四次挥手也可以换成三次。<strong>如果服务器在收到客户端的 <code class="language-plaintext highlighter-rouge">FIN</code> 时没有更多数据或根本没有数据要发送，则可以将 ack 和 fin 合并为一个包。或者，因为延迟确认的特性，可以把ACK,FIN（第二次和第三次挥手)和要发的数据一起发过去，这样也是三次挥手。</strong></p><p>服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，<strong>但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序</strong>：</p><ul><li>如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；<li>如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，</ul><p>从上面过程可知，<strong>是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，</strong>所以服务端的 ACK 和 FIN 一般都会分开发送。</p><p><strong>两次挥手是自连接。</strong></p><h2 id="为什么每次建立-tcp-连接时初始化的序列号都要求不一样呢"><span class="mr-2">为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</span><a href="#为什么每次建立-tcp-连接时初始化的序列号都要求不一样呢" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>为了防止历史报文被下一个相同四元组的连接接收（主要方面）</strong><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收</ul><h2 id="初始化序列号不一样是防止历史报文被相同四元组接受那么为什么还需要time_wait"><span class="mr-2">初始化序列号不一样是防止历史报文被相同四元组接受，那么为什么还需要TIME_WAIT</span><a href="#初始化序列号不一样是防止历史报文被相同四元组接受那么为什么还需要time_wait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为序列号会被复用，不是无限的。</p><h2 id="time_wait-过多有什么危害"><span class="mr-2">TIME_WAIT 过多有什么危害？</span><a href="#time_wait-过多有什么危害" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等；<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code class="language-plaintext highlighter-rouge">32768～61000</code>，也可以通过 <code class="language-plaintext highlighter-rouge">net.ipv4.ip_local_port_range</code>参数指定范围。</ul><h2 id="如果已经建立了连接但是客户端突然出现故障了怎么办---tcp-keepalive"><span class="mr-2">如果已经建立了连接，但是客户端突然出现故障了怎么办？ - TCP KEEPALIVE</span><a href="#如果已经建立了连接但是客户端突然出现故障了怎么办---tcp-keepalive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP 有一个机制是<strong>保活机制KEEPALIVE</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><ul><li>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。<li>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。<li>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</ul><h4 id="我们项目里有自己的超时检测机制这个是http应用层的的不是tcptcp的保活和http保活不一样我们的保活机制就是定时器没有新的读写操作请求就调用关闭"><span class="mr-2">我们项目里有自己的超时检测机制，这个是HTTP应用层的的不是TCP。TCP的保活和HTTP保活不一样。我们的保活机制就是定时器，没有新的读写操作（请求）就调用关闭。</span><a href="#我们项目里有自己的超时检测机制这个是http应用层的的不是tcptcp的保活和http保活不一样我们的保活机制就是定时器没有新的读写操作请求就调用关闭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="http-keepalive-和-tcp-keepalive如何理解"><span class="mr-2">HTTP keepalive 和 TCP keepalive如何理解</span><a href="#http-keepalive-和-tcp-keepalive如何理解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>TCP的保活是没有通信的时候，这时候也没断开连接，我们看一下对端是否活着。所以这个周期比较长。<li>HTTP的keepalive是因为在关闭的时候，每一次请求答复后浏览器也就是客户端会主动关闭这个TCP链接。而如果打开了keepalive，则不会主动关闭这个链接。</ul><p>所以</p><ul><li>TCP keepalive是用来检测的<li>HTTP keep-alive 是用来设置生效（开关）的。关闭也就是直接收到请求就断开连接。如果打开了就不主动断开连接。</ul><h2 id="http不带keepalive的话谁主动关闭-推测"><span class="mr-2">HTTP不带keepalive的话谁主动关闭？ 推测</span><a href="#http不带keepalive的话谁主动关闭-推测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们知道HTTP的keepalive必须两端都开启才能生效。</p><p>以下是个人测试：</p><p>如果服务器关闭了keepalive，浏览器开启，则是浏览器主动发起FIN。</p><p>通过知乎https://zhuanlan.zhihu.com/p/224595048 得到：如果浏览器关闭了keepalive，服务器开启，则是服务器主动发起FIN。</p><p>那么可以推测出，是哪方关闭了，就是开启的那方主动关闭连接。</p><p>那么如果都关闭呢？不知道了。</p><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220925035850.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220925035850.png" alt="QQ截图20220925035850" class="lazyload" data-proofer-ignore></a></p><h2 id="accept服务端connect客户端的成功返回-发生在三次握手的哪一步"><span class="mr-2">accept(服务端)/connect(客户端)的成功返回 发生在三次握手的哪一步？</span><a href="#accept服务端connect客户端的成功返回-发生在三次握手的哪一步" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>客户端在第二次握手后</p><li><p>服务端在第三次握手后</p></ul><p>简单记住就是只要收到了对方的ACK就可以了。客户端是第二次握手收到服务端的ACK，服务端是第三次收到了客户端的ACK。</p><h2 id="很多closewait状态是什么原因"><span class="mr-2">很多closewait状态是什么原因</span><a href="#很多closewait状态是什么原因" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>在被动关闭连接情况下，在已经接收到FIN，回复了ACK，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。</strong>所以原因可能是我方正在忙着读或者写，还没有及时处理断开连接的操作。也就是我方没有及时close。应该读到错误的时候自己也调用关闭。</p><h2 id="很多fin_wait_2状态是什么原因"><span class="mr-2">很多FIN_WAIT_2状态是什么原因</span><a href="#很多fin_wait_2状态是什么原因" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>和上面一样。被动关闭是closewait，主动关闭对应的就是fin_wait_2</p><h2 id="shutdown和close的区别"><span class="mr-2">shutdown和close的区别</span><a href="#shutdown和close的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">shutdown()</code>函数可以选择关闭全双工连接的读通道或者写通道，如果两个通道同时关闭，则这个连接不能再继续通信。shutdown()只会关闭连接，但是不会释放占用的文件描述符。所以即使使用了SHUT_RDWR类型调用shutdown()关闭连接，也仍然要调用close()来释放连接占用的文件描述符。<strong>如果有多进程/多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响。</strong><li><code class="language-plaintext highlighter-rouge">close()</code>函数会同时关闭全双工连接的读写通道，除了关闭连接外，还会释放套接字占用的文件描述符。如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。</ul><h2 id="粗暴关闭-优雅关闭"><span class="mr-2">粗暴关闭 优雅关闭</span><a href="#粗暴关闭-优雅关闭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果客户端是用 <code class="language-plaintext highlighter-rouge">close</code> 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。当服务端收到 RST 后，内核就会释放连接，当服务端应用程序再次发起读操作或者写操作时，就能感知到连接已经被释放了：</p><ul><li>如果是读操作，则会返回 RST 的报错，也就是我们常见的Connection reset by peer。<li>如果是写操作，那么程序会产生 SIGPIPE 信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</ul><p><strong>相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。</strong></p><h2 id="客户端调用-close-了断开的流程是什么"><span class="mr-2">客户端调用 close 了，断开的流程是什么？</span><a href="#客户端调用-close-了断开的流程是什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>服务端的<code class="language-plaintext highlighter-rouge">read</code>会读到EOF。这时候可以调用close了（服务端发送FIN）。</p><ul><li>客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态<li>服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态<strong>。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包</strong>，这个 EOF 会被<strong>放在已排队等候的其他已接收的数据之后（末尾）</strong>，所以必须要继续读取read 接收缓冲区已接收的数据<ul><li><strong>调用 socket 的<code class="language-plaintext highlighter-rouge">close</code>方法后，缓冲区中未发送完的数据不会丢。因为内核会把FIN包用EOF替换后插入到缓冲区的末尾。</strong></ul><li>接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 <strong>read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数</strong>，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；<li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；<li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；<li>客户端经过 2MSL 时间之后，也进入 CLOSE 状态；</ul><p><a href="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805021651.png" class="popup img-link "><img data-src="/assets/blog_res/2022-06-23-NET1.assets/QQ%E6%88%AA%E5%9B%BE20220805021651.png" alt="QQ截图20220805021651" class="lazyload" data-proofer-ignore></a></p><h3 id="整理一下"><span class="mr-2">整理一下</span><a href="#整理一下" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>浏览器关闭了页面，浏览器会调用<code class="language-plaintext highlighter-rouge">close</code>。发送<code class="language-plaintext highlighter-rouge">FIN</code>包<li>服务器接收到了<code class="language-plaintext highlighter-rouge">FIN</code>包，TCP协议栈会把这个<code class="language-plaintext highlighter-rouge">FIN</code>包换成EOF结束符然后放到对应客户端读写描述符的接收缓冲区中。<ul><li>我们知道每一个socket都是文件描述符。<li>我们知道每个socket都有一个自己的缓冲区。</ul><li>通过读取（可能是epoll，可能是read，可能是select等等）我们能读取到这个<code class="language-plaintext highlighter-rouge">EOF</code>，我们就知道了客户端想要关闭，不会再发送数据了。我们就可以这边准备进行关闭。<li>我们读取到了<code class="language-plaintext highlighter-rouge">EOF</code>可以调用<code class="language-plaintext highlighter-rouge">close</code>进行关闭了。</ul><h2 id="服务端关闭了客户端继续写会强制退出"><span class="mr-2">服务端关闭了，客户端继续写会强制退出</span><a href="#服务端关闭了客户端继续写会强制退出" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="客户端关闭了写端服务端继续写没问题关闭了读写则服务器继续写也会触发异常"><span class="mr-2">客户端关闭了写端，服务端继续写没问题，关闭了读写则服务器继续写也会触发异常</span><a href="#客户端关闭了写端服务端继续写没问题关闭了读写则服务器继续写也会触发异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h1 id="客户端拔掉了网线会怎么样">客户端拔掉了网线会怎么样？</h1><h3 id="首先拔掉网线这个动作并不会影响-tcp-连接的状态"><span class="mr-2">首先，拔掉网线这个动作并不会影响 TCP 连接的状态。</span><a href="#首先拔掉网线这个动作并不会影响-tcp-连接的状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 连接在 Linux 内核中是一个名为 <code class="language-plaintext highlighter-rouge">struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。<strong>当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</strong></p><h3 id="假设拔掉网线后有数据传输"><span class="mr-2">假设拔掉网线后有数据传输</span><a href="#假设拔掉网线后有数据传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在客户端拔掉网线后，服务端向客户端发送的数据报文会得不到任何的响应，在等待一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p><ul><li><p><strong>如果在服务端重传报文的过程中，客户端刚好把网线插回去了</strong>，由于拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态，所以这时客户端是可以正常接收服务端发来的数据报文的，然后客户端就会回 ACK 响应报文。此时，客户端和服务端的 TCP 连接依然存在的，就<strong>感觉什么事情都没有发生。</strong></p><li><p>但是，<strong>如果如果在服务端重传报文的过程中，客户端一直没有将网线插回去</strong>，服务端超时重传报文的次数达到一定阈值后，内核就会判定出该 TCP 有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是<strong>服务端的 TCP 连接就会断开</strong>。</p><ul><li>而等客户端插回网线后，<strong>如果客户端向服务端发送了数据</strong>，由于<strong>服务端已经没有与客户端相同四元祖的 TCP 连接</strong>了，因此<strong>服务端内核就会回复 RST 报文，客户端收到后就会释放该 TCP 连接。</strong><li><strong>此时，客户端和服务端的 TCP 连接都已经断开了。</strong></ul></ul><h3 id="假设拔掉网线后没有数据传输"><span class="mr-2">假设拔掉网线后，没有数据传输</span><a href="#假设拔掉网线后没有数据传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>针对拔掉网线后，没有数据传输的场景，还得看是否开启了 TCP keepalive 机制 （TCP 保活机制）。</p><p>如果<strong>没有开启</strong> TCP keepalive 机制，在客户端拔掉网线后，并且双方都没有进行数据传输，那么客户端和服务端的 TCP 连接将会一直保持存在。（因为我压根不知道你断开了没有。）</p><p>而如果<strong>开启</strong>了 TCP keepalive 机制，在客户端拔掉网线后，即使双方都没有进行数据传输，在持续一段时间后，TCP 就会发送探测报文：</p><ul><li>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。<li>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</ul><p><strong>所以，TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</strong></p><h2 id="输入网址到显示网页的过程"><span class="mr-2">输入网址到显示网页的过程</span><a href="#输入网址到显示网页的过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先浏览器将URL通过DNS协议（UDP连接）解析为IP地址</p><p>交给TCP协议，建立链接</p><p>IP层将TCP报文封装。发送</p><p>到达对端后用ARP/RARP进行寻址。</p><p>然后找到目标客户端。</p><p>成功建立链接。</p><p>发出HTTP请求，</p><p>用到的协议：HTTP/S，DNS(UDP), TCP, IP, MAC, ARP, RARP</p><h2 id="粘包怎么办"><span class="mr-2">粘包怎么办</span><a href="#粘包怎么办" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>其实严谨一点不能叫解决粘包。应该叫实现功能。你硬要用字节流协议去做数据报协议的功能，你肯定要自己去解决怎么读取消息的问题。</strong></p><p>我们提到过，调用了<code class="language-plaintext highlighter-rouge">send</code>仅仅是把内容拷贝到内核缓冲区中而已，具体什么时候发送是TCP决定的。TCP是字节流，<strong>我们不能认为一个用户消息对应一个TCP报文，即 TCP不保证每一个报文是一个完整的数据报</strong>。所以可能会发生粘包。尤其是有些小包数据会有Nagle算法优化导致多包一起发出去。或者是一个大报文被拆成了几个小报文。这样就可能我分了五次发送 1 2 3 4 5然后变成一个12345发出去。但是应用程序不知道怎么拆开。不知道是1 2还是1 23 45 还是…</p><p>所以总结原因：</p><ul><li>TCP面向字节流，一个用户消息不一定是一个TCP报文。一个报文可能有多个消息或者是多个报文对应一个消息。所以是因为：<ul><li>多个小消息合并为大包发送（发送方粘包）<li>大包拆分为小包（发送方粘包）<li>接收端不及时接受导致多个包在一起。（接收方粘包）<li>说白了就是不知道边界在哪。</ul></ul><h3 id="要解决这个问题要交给应用程序"><span class="mr-2">要解决这个问题，要交给<strong>应用程序</strong>。</span><a href="#要解决这个问题要交给应用程序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。</p><p>一般有三种方式分包的方式：</p><ul><li>固定长度的消息；<li>特殊字符作为边界；<li>自定义消息结构。</ul><h3 id="固定长度的消息"><span class="mr-2">固定长度的消息：</span><a href="#固定长度的消息" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p><p>但是这种方式灵活性不高，实际中很少用。</p><h3 id="特殊字符作为边界http就是这玩意"><span class="mr-2">特殊字符作为边界（HTTP就是这玩意）</span><a href="#特殊字符作为边界http就是这玩意" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p><h3 id="自定义消息结构"><span class="mr-2">自定义消息结构</span><a href="#自定义消息结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p><p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p><p>https://juejin.cn/post/7031925832167718943</p><h2 id="服务端挂了客户端的tcp链接还在吗"><span class="mr-2">服务端挂了，客户端的TCP链接还在吗？</span><a href="#服务端挂了客户端的tcp链接还在吗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="如果是服务端进程崩溃--触发四次挥手"><span class="mr-2">如果是服务端进程崩溃 – 触发四次挥手</span><a href="#如果是服务端进程崩溃--触发四次挥手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP 的连接信息是由内核维护的，<strong>所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源</strong>，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，<strong>所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥手的过程。</strong></p><h3 id="如果是服务端主机宕机--无法进行四次挥手需要靠后续数据判断"><span class="mr-2">如果是服务端主机宕机 – 无法进行四次挥手。需要靠后续数据判断。</span><a href="#如果是服务端主机宕机--无法进行四次挥手需要靠后续数据判断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>当服务端的主机发生了宕机，是没办法和客户端进行四次挥手的</strong>，所以在服务端主机发生宕机的那一时刻，客户端是没办法立刻感知到服务端主机宕机了，<strong>只能在后续的数据交互中来感知服务端的连接已经不存在了</strong>。</p><h4 id="如果宕机后客户端会发送数据--触发超时重传后重传次数达到阈值内核判定链接有问题主动断开"><span class="mr-2">如果宕机后，客户端会发送数据： – 触发超时重传后，重传次数达到阈值，内核判定链接有问题，主动断开。</span><a href="#如果宕机后客户端会发送数据--触发超时重传后重传次数达到阈值内核判定链接有问题主动断开" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在服务端主机宕机后，客户端发送了数据报文，由于得不到响应，在等待一定时长后，客户端就会触发<strong>超时重传</strong>机制，重传未得到响应的数据报文。</p><p>当重传次数达到达到一定阈值后，内核就会判定出该 TCP 连接有问题，然后通过 Socket 接口告诉应用程序该 TCP 连接出问题了，于是客户端的 TCP 连接就会断开。</p><h4 id="如果宕机后客户端一直不发送数据--需要看是否开启了tcp-的keepalive没有开启则不会检测开启了由于有探测报文则可以检测到"><span class="mr-2">如果宕机后，客户端一直不发送数据： – 需要看是否开启了TCP 的keepalive。没有开启则不会检测，开启了由于有探测报文则可以检测到。</span><a href="#如果宕机后客户端一直不发送数据--需要看是否开启了tcp-的keepalive没有开启则不会检测开启了由于有探测报文则可以检测到" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>如果<strong>没有开启</strong> TCP keepalive 机制，<strong>在服务端主机发送宕机后，如果客户端一直不发送数据，那么客户端的 TCP 连接将一直保持存在</strong>，所以我们可以得知一个点，<strong>在没有使用 TCP 保活机制，且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态时，并不代表另一方的 TCP 连接还一定是正常的。</strong></p><li><p>而如果<strong>开启</strong>了 TCP keepalive 机制，在服务端主机发送宕机后，即使客户端一直不发送数据，在持续一段时间后，<strong>TCP 就会发送探测报文</strong>，探测服务端是否存活：</p><ul><li>如果<strong>对端是正常工作</strong>的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。<li>如果<strong>对端主机崩溃，或对端由于其他原因导致报文不可达</strong>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</ul><p>所以，TCP keepalive 机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活。</p></ul><h3 id="如果宕机后马上重启服务器-重启服务器后客户端此时发送了数据-由于原链接不存在会返回rst-客户端收到rst后断开连接"><span class="mr-2">如果宕机后马上重启服务器， 重启服务器后客户端此时发送了数据： –由于原链接不存在，会返回RST。 客户端收到RST后断开连接。</span><a href="#如果宕机后马上重启服务器-重启服务器后客户端此时发送了数据-由于原链接不存在会返回rst-客户端收到rst后断开连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果服务端主机宕机后，然后马上重启了服务端，重启完成后，如果这时客户端发送了数据，由于服务端之前的连接信息已经不存在（ TCP 连接的数据结构已经丢失了），所以会回 RST 报文给客户端，客户端收到 RST 报文后，就断开连接。</p><h2 id="客户端挂了服务端的tcp链接还在吗"><span class="mr-2">客户端挂了，服务端的TCP链接还在吗？</span><a href="#客户端挂了服务端的tcp链接还在吗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>和上面的服务端一样。</p><h1 id="udp和tcp哪个快">UDP和TCP哪个快</h1><ul><li>因为UDP不保证数据可以被准确无误的送达，所以没有那些重传和校验机制。自然在<strong>一般情况下UDP比TCP更快</strong>。<li>但是一般情况下，UDP还是要做重传机制。这时候问题来了。<strong>如果现在我需要传一个特别大的数据包但是丢包了呢</strong>？<ul><li>在<code class="language-plaintext highlighter-rouge">TCP</code>里，它内部会根据<code class="language-plaintext highlighter-rouge">MSS</code>的大小<strong>分段</strong>，这时候进入到IP层之后，每个包大小都不会超过<code class="language-plaintext highlighter-rouge">MTU</code>，因此IP层一般不会再进行分片。这时候发生丢包了，只需要<strong>重传每个MSS分段</strong>就够了。<li>但对于<code class="language-plaintext highlighter-rouge">UDP</code>，其本身并不会分段，如果数据过大，到了IP层，就会进行分片。此时发生丢包的话，再次重传，就会<strong>重传整个大数据包</strong>。</ul><li>对于上面这种情况，<strong>使用UDP就比TCP要慢</strong>。<li>当然，解决起来也不复杂。这里的关键点在于是否实现了数据分段机制，<strong>使用UDP的应用层如果也实现了分段机制的话，那就不会出现上述的问题了</strong>。</ul><h1 id="单判断协议在哪一层">单判断协议在哪一层</h1><ul><li><p>知道<code class="language-plaintext highlighter-rouge">mac</code>，是链路层</p><li><p>而且知道<code class="language-plaintext highlighter-rouge">ip</code> ，是网络层</p><li><p>而且知道端口，是传输层</p><ul><li>显然，<code class="language-plaintext highlighter-rouge">icmp</code>工作在网络层</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%821%20-%20Sterben_01&url=%2Fposts%2FNET1%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%821%20-%20Sterben_01&u=%2Fposts%2FNET1%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FNET1%2F&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%821%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/NET2/"><div class="card-body"> <em class="small" data-ts="1655992500" data-df="YYYY/MM/DD" > 2022/06/23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络 - 数据链路层1</h3><div class="text-muted small"><p> 计算机网络 - 数据链路层1 数据链路层 功能概述 为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认! 链路管理，即连接的建立、维持、释放（用于面向连接的服务）。 组帧 流量控制。 差错控制。（帧错、位错） 封装成帧 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比...</p></div></div></a></div><div class="card"> <a href="/posts/HTTP/"><div class="card-body"> <em class="small" data-ts="1660978500" data-df="YYYY/MM/DD" > 2022/08/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>HTTP</h3><div class="text-muted small"><p> HTTP请求报文格式 注意请求体（请求数据）部分GET请求没有。 HTTP请求方法 GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副 作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被爬虫等随意访 问。所以GET请求不应被定义为带有副作用的操作。 HEAD：与 GE...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/STL2/" class="btn btn-outline-primary" prompt="上一篇"><p>C++ STL - 2 - 迭代器设计思路。萃取。</p></a> <a href="/posts/NET2/" class="btn btn-outline-primary" prompt="下一篇"><p>计算机网络 - 数据链路层1</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
