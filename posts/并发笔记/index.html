<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="c++并发编程实战-笔记" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="第二章" /><meta property="og:description" content="第二章" /><link rel="canonical" href="/posts/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" /><meta property="og:url" content="/posts/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-05T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="c++并发编程实战-笔记" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-09T01:30:25-05:00","datePublished":"2022-09-05T01:55:00-05:00","description":"第二章","headline":"c++并发编程实战-笔记","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"},"url":"/posts/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/"}</script><title>c++并发编程实战-笔记 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>c++并发编程实战-笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>c++并发编程实战-笔记</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1662360900" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/09/05 </em> </span> <span> 更新于 <em class="" data-ts="1683613825" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/05/09 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9952 字"> <em>55 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="第二章">第二章</h1><h3 id="stdthread的析构函数在线程对象没有调用join或detach的时候会调用stdterminate"><span class="mr-2"><code class="language-plaintext highlighter-rouge">std::thread</code>的析构函数在线程对象没有调用join或detach的时候会调用<code class="language-plaintext highlighter-rouge">std::terminate()</code>。</span><a href="#stdthread的析构函数在线程对象没有调用join或detach的时候会调用stdterminate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果一个线程我们没有调用<code class="language-plaintext highlighter-rouge">join</code>或<code class="language-plaintext highlighter-rouge">detach</code>，也就是说并没有分离出去或阻塞直至新线程执行完毕并回收资源，（也就是<code class="language-plaintext highlighter-rouge">joinable() == true</code>)。那么当这个线程被析构的时候，<code class="language-plaintext highlighter-rouge">std::thread</code>的析构函数会调用<code class="language-plaintext highlighter-rouge">std::terminate()</code>。这是非常不好的行为。因为是异常！</p><ul><li><p>有四种情况在调用<code class="language-plaintext highlighter-rouge">thread</code>析构函数的时候是正常销毁：</p><ul><li>被默认构造<ul><li>默认构造的线程对象不认为是激活的线程对象</ul><li>被移动<li>已调用<code class="language-plaintext highlighter-rouge">join()</code><li>已调用 <code class="language-plaintext highlighter-rouge">detach()</code></ul></ul><h4 id="为何要这么设计effective-c-条款37部分"><span class="mr-2">为何要这么设计（effective c++ 条款37部分）</span><a href="#为何要这么设计effective-c-条款37部分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>因为剩下两种选项：隐式<code class="language-plaintext highlighter-rouge">join</code>或隐式<code class="language-plaintext highlighter-rouge">detach</code>会更糟糕。</p><p>如果隐式join，则析构函数会阻塞等待至线程结束。这听上去好像不错，但是会导致难以追踪的性能问题。</p><p>如果隐式detach，假设线程使用了某些局部变量，或者是使用的资源已被释放，会导致很多问题。同时可能此时被释放的内存被其他资源或程序占用，而一直运行的线程会无意间使用这部分本来就毫无相关的资源。</p><h3 id="注意在将仿函数函数对象作为参数传入thread对象的时候避免语法歧义"><span class="mr-2">注意在将仿函数（函数对象）作为参数传入<code class="language-plaintext highlighter-rouge">thread</code>对象的时候，避免语法歧义。</span><a href="#注意在将仿函数函数对象作为参数传入thread对象的时候避免语法歧义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">obj</span><span class="p">{</span>
    <span class="c1">//其他东西</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">mythread</span><span class="p">(</span><span class="n">obj</span><span class="p">());</span> <span class="c1">//错误</span>
    <span class="n">mythread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    
    <span class="kr">thread</span> <span class="n">mythread1</span><span class="p">((</span><span class="n">obj</span><span class="p">()));</span> <span class="c1">//可以</span>
    <span class="n">mythread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    
    <span class="kr">thread</span> <span class="n">mythread2</span><span class="p">{</span><span class="n">obj</span><span class="p">()};</span> <span class="c1">//可以</span>
    <span class="n">mythread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="传参的时候需要使用引用就需要用stdrefcref因为默认一律按照拷贝移动传值"><span class="mr-2">传参的时候需要使用引用就需要用<code class="language-plaintext highlighter-rouge">std::ref/cref</code>。因为默认一律按照拷贝/移动传值。</span><a href="#传参的时候需要使用引用就需要用stdrefcref因为默认一律按照拷贝移动传值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>一个实参从主线程传递到子线程的线程函数中，<strong>需要经过两次传递</strong>。<strong>第1次发生在<code class="language-plaintext highlighter-rouge">std::thread</code>构造时，此次参数按值并以副本形式被保存在<code class="language-plaintext highlighter-rouge">thread</code>对象内部</strong>。<strong>第2次发生在向线程函数传递时</strong>，此次传递是由子线程发起，并将之前<code class="language-plaintext highlighter-rouge">std::thread</code>内部保存的副本<strong>以右值的形式(std::move())传入线程函数</strong>中的。<li>当我们使用了<code class="language-plaintext highlighter-rouge">ref</code>去完成引用传参的时候，其实我们会先创建一个<code class="language-plaintext highlighter-rouge">std::ref</code>的临时对象，这里保存着我们要传入的那个值的引用。然后这个<code class="language-plaintext highlighter-rouge">std::ref</code>再以副本的形式保存在<code class="language-plaintext highlighter-rouge">thread</code>对象中。随后这个副本被<code class="language-plaintext highlighter-rouge">move</code>到线程函数，由于<code class="language-plaintext highlighter-rouge">std::ref</code>重载了<code class="language-plaintext highlighter-rouge">operator T&amp;()</code>,因此会隐式转换为对应的类型。因此看起来就像是真的按照引用个传递进来了一样。<ul><li>此处参考：https://en.cppreference.com/w/cpp/thread/thread/thread</ul><li><p><strong>如果线程函数的形参为T、const T&amp;或T&amp;&amp;类型时</strong>，std::thread的构造函数可以接受左值或右值实参。因为不管是左值还是右值，在std::thread中均是以副本形式被保存，并在第2次向线程函数传参时以右值方式传入，而以上三种形参均可接受右值。</p><li><p><strong>而如果线程函数的形参为T&amp;时</strong>，<strong>不管是左值还是右值的T类型实参，都是无法直接经std::thread传递给形参为T&amp;的线程函数</strong>，因为该实参数的副本会被std::move成右值并传递线程函数，但T&amp;无法接受右值类型。<strong>因此，需要以std::ref形式传入</strong>。</p><li><p>当向线程函数传参时，可能发生隐式类型转换，这种转换是在子线程中进行的。需要注意，由于隐式转换会构造临时对象，并将该对象（是个右值）传入线程函数，因此线程函数的形参应该是可接受右值类型的T、const T&amp;或T&amp;&amp;类型，但不能是T&amp;类型。此外，如果源类型是指针或引用类型时，还要防止可能发生悬空指针和悬空引用的现象。</p><li><p>因为thread函数使用了完美转发，所以在某些只支持移动的参数中，必须显示使用move来转移所有权。比如智能指针。（异步操作API也一样）</p><li>参考资料：https://www.cnblogs.com/5iedu/p/11633683.html</ul><h2 id="传递成员函数做为线程执行函数注意语法"><span class="mr-2">传递成员函数做为线程执行函数注意语法</span><a href="#传递成员函数做为线程执行函数注意语法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>需要传入成员函数指针。语法参见杂记2（显式指定作用域并取地址）。并且要传入类对象地址做为类成员函数的隐藏参数- this指针做为第二个参数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">obj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">execute</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"start"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">obj</span> <span class="n">classobj</span><span class="p">;</span>
    <span class="kr">thread</span> <span class="n">mythread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">::</span><span class="n">execute</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">classobj</span><span class="p">);</span> <span class="c1">//需要传入成员函数指针。语法参见杂记2（显式指定作用域并取地址）。并且要传入类对象地址做为类成员函数的隐藏参数- this指针。</span>
   
    <span class="kr">thread</span> <span class="n">mythread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">::</span><span class="n">execute</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">classobj</span><span class="p">));</span> <span class="c1">//引用</span>
    
    <span class="kr">thread</span> <span class="n">mythread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">::</span><span class="n">execute</span><span class="p">,</span> <span class="n">classobj</span><span class="p">);</span> <span class="c1">//对象</span>
    <span class="n">mythread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>此处第二个参数传递引用，指针或者是对象本身都可以。具体情况需要具体分析。比如当禁用了X类的拷贝构造的时候，第三种按值传递就不可以。因为是拷贝。 最好是传递指针。因为类成员函数的第一个参数是this指针。所以thread的第二个参数应该最好是这个类对象的指针。 还有，如果按照值传递，会变成副本。可能会导致原对象被销毁。</strong></p><h2 id="线程对象不可以被复制但是可以被移动"><span class="mr-2">线程对象不可以被复制。但是可以被移动</span><a href="#线程对象不可以被复制但是可以被移动" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">some_function</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">some_other_function</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">t1</span><span class="p">(</span><span class="n">some_function</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="n">t1</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">some_other_function</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t3</span><span class="p">;</span> <span class="c1">// 4</span>
<span class="n">t3</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="c1">// 5</span>
<span class="n">t1</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t3</span><span class="p">);</span> <span class="c1">// 6 赋值操作将使程序崩溃</span>
</pre></table></code></div></div><p>并发编程P32</p><p>前面几个都没问题。包括t1。因为在给t1赋值前，其所有权已经转移至t2。此时t1就空了。</p><ul><li><p>赋值给一个已经有关联线程的std::thread，系统直接调用 std::terminate() 终止程序继续运行。</p><li><strong>不能通过赋新值给 std::thread 对象的方式来”丢弃”一个线程。</strong><li>如果这个容器是移动敏感的(比如，标准中的 <code class="language-plaintext highlighter-rouge">std::vector&lt;&gt;</code> )，那么移动操作同样适用于这些容器。</ul><h2 id="小心局部变量导致的悬空引用"><span class="mr-2">小心局部变量导致的悬空引用</span><a href="#小心局部变量导致的悬空引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>比如我们有这样一个例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">func1</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kr">thread</span> <span class="n">th2</span><span class="p">(</span><span class="n">func2</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">//按照引用传递</span>
    <span class="n">th2</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"thread 1 finished"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">th1</span><span class="p">(</span><span class="n">func1</span><span class="p">);</span>
    <span class="n">th1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span> <span class="c1">//一定要sleep</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>在这个例子中，输出了两次<code class="language-plaintext highlighter-rouge">x</code>后，输出<code class="language-plaintext highlighter-rouge">thread 1 finished</code>。这时候马上会有<code class="language-plaintext highlighter-rouge">segmentation fault</code>。因为这时候<code class="language-plaintext highlighter-rouge">x</code>已经被销毁因为线程1已经结束。所以这时候<code class="language-plaintext highlighter-rouge">func2</code>引用的<code class="language-plaintext highlighter-rouge">x</code>就是悬空引用。</ul><h2 id="避免应用被抛出的异常所终止通常在无异常的情况下使用join时需要在异常处理过程中调用join从而避免生命周期的问题最好使用raii"><span class="mr-2">避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。最好使用RAII</span><a href="#避免应用被抛出的异常所终止通常在无异常的情况下使用join时需要在异常处理过程中调用join从而避免生命周期的问题最好使用raii" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="使用raii包装线程对象避免在某些可能抛出异常的函数中忘记join或detach线程对象"><span class="mr-2">使用RAII包装线程对象避免在某些可能抛出异常的函数中忘记<code class="language-plaintext highlighter-rouge">join</code>或<code class="language-plaintext highlighter-rouge">detach</code>线程对象</span><a href="#使用raii包装线程对象避免在某些可能抛出异常的函数中忘记join或detach线程对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>一个简单的线程对象包装类。这里的语义是持有一个线程对象的引用。如果想写为值语义，也就是包装类本身持有线程对象，可以参考effective modern C++的条款37</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">thread_guard</span><span class="p">{</span>
    <span class="kr">thread</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">;</span> <span class="c1">//持有一个线程对象的引用</span>
    <span class="nl">public:</span>
        <span class="k">explicit</span> <span class="n">thread_guard</span> <span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span><span class="n">t</span><span class="p">(</span><span class="n">rhs</span><span class="p">){};</span> <span class="c1">//构造函数要explicit避免隐式类型转换</span>

        <span class="o">~</span><span class="n">thread_guard</span><span class="p">(){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">()){</span> <span class="c1">//析构函数中如果线程是joinable的</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"析构"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">thread_guard</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">//禁用拷贝构造和拷贝赋值</span>
        <span class="n">thread_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>

    <span class="n">thread_guard</span> <span class="n">my_guard</span><span class="p">(</span><span class="n">my_thread</span><span class="p">);</span> <span class="c1">//使用RAII对象管理线程对象</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>

    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"abc"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">//安全join。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="在给thread调用的线程函数传递参数的时候注意参数是否是不可拷贝的"><span class="mr-2">在给thread调用的线程函数传递参数的时候，注意参数是否是不可拷贝的</span><a href="#在给thread调用的线程函数传递参数的时候注意参数是否是不可拷贝的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">threadfunc</span><span class="p">(</span><span class="n">mutex</span> <span class="o">&amp;</span><span class="n">mylock</span><span class="p">){</span> <span class="c1">//注意必须传引用</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
    <span class="n">mylock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">testfunc</span><span class="p">(){</span>
    <span class="n">mylock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="kr">thread</span> <span class="n">th</span><span class="p">(</span><span class="n">threadfunc</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">mylock</span><span class="p">));</span> <span class="c1">//注意必须传引用</span>
    <span class="n">mylock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">mylock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">th</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

<span class="p">}</span>
</pre></table></code></div></div><p>因为<code class="language-plaintext highlighter-rouge">mutex</code>是不可拷贝的。所以必须引用传参。</p><p># 第三章</p><ul><li>尽可能不要使用原始锁，而使用<code class="language-plaintext highlighter-rouge">lock_guard</code>。因为使用原始锁意味着必须在函数的每一个出口都手动解锁。<li><strong>一个指针或引用，也会让这种保护形同虚设。切勿将受保护数据的指针或引用传递到互斥锁作用域之外。因为指针或引用可以在锁的作用域外面直接修改数据。锁是管不到那些的。所以切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论 是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。</strong></ul><p>一个例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">list_wrapper</span><span class="p">{</span>
    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">my_list</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">add_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lcg</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
        <span class="n">my_list</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="nf">get_list</span><span class="p">(){</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>如上面所示，我们有一个函数会返回一个指向受保护数据（<code class="language-plaintext highlighter-rouge">my_list</code>）的指针。然而有可能有别人通过这个指针直接修改我们的<code class="language-plaintext highlighter-rouge">my_list</code>。这样做就完全绕过了我们的函数<code class="language-plaintext highlighter-rouge">add_to_list</code>所添加的锁的保护。</p><ul><li>避免死锁<ul><li>方式之一就是让两个互斥量总以相同的顺序上锁。不要一个函数先锁A再锁B，另一个先锁B再锁A。<li>我们也可以使用<code class="language-plaintext highlighter-rouge">std::lock</code>或<code class="language-plaintext highlighter-rouge">std::scoped_lock</code>(c++17起)来同时上锁多个互斥量。（由于设计的原因，不会发生死锁。因为一旦一个锁报异常就会把另一个锁也解锁 – 要么两个都锁，要么一个都不锁。）同时，我们可以用<code class="language-plaintext highlighter-rouge">lock_guard</code> 的可选参数<code class="language-plaintext highlighter-rouge">std::adopt_lock</code>来接管已经上锁了的互斥量。<li>避免死锁的进阶指导：<ul><li>避免嵌套锁。<li>避免在持有锁时调用外部代码。<li>使用固定顺序获取锁。<li>使用层次锁结构。当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定。因此锁的顺序只能先锁层级高的锁再锁层级低的锁。</ul></ul><li><code class="language-plaintext highlighter-rouge">unique_lock</code>比<code class="language-plaintext highlighter-rouge">lock_guard</code>更灵活，但是成本会更高。<li>一般情况下，尽可能将持有锁的时间缩减到最小。<li>单例模式也可以使用<code class="language-plaintext highlighter-rouge">call_once</code>来解决线程安全问题。<li>可以使用读写锁来减少一定场合下普通锁的开销。c中可以使用<code class="language-plaintext highlighter-rouge">pthread_rwlock_t</code>，c++可以使用<code class="language-plaintext highlighter-rouge">shared_lock</code>(c++17起）/<code class="language-plaintext highlighter-rouge">shared_mutex</code>（c++14起）<ul><li>用 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 与 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 管理排他性锁定。(写锁)<li>用 <code class="language-plaintext highlighter-rouge">std::shared_lock</code> 管理共享锁定。（读锁）</ul></ul><h1 id="第四章">第四章</h1><ul><li>同步操作可使用条件变量。此处不赘述用法。<li>剩下的都在杂记3.</ul><h1 id="thread源码解析">thread源码解析</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre><td class="rouge-code"><pre>
<span class="c1">// 管理线程的类</span>
<span class="k">class</span> <span class="nc">thread</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">class</span> <span class="nc">id</span><span class="p">;</span>                   <span class="c1">// 内部ID类</span>
	<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">native_handle_type</span><span class="p">;</span>
 
	<span class="kr">thread</span><span class="p">()</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	    <span class="c1">// 构造函数，专门为空线程设计。这就是为什么默认构造的线程对象并不是有效的</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>    <span class="c1">// 宏定义，原型为：#define _Thr_set_null(thr) (thr._Id = 0)</span>
	<span class="p">}</span>
 
	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Fn</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">_Args</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="nf">thread</span><span class="p">(</span><span class="n">_Fn</span><span class="o">&amp;&amp;</span> <span class="n">_Fx</span><span class="p">,</span> <span class="n">_Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">_Ax</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// 带参模板构造函数_Fx(_Ax...)</span>
		<span class="n">_Launch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Thr</span><span class="p">,</span> <span class="n">_STD</span> <span class="n">bind</span><span class="p">(</span><span class="n">_Decay_copy</span><span class="p">(</span><span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">_Fn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Fx</span><span class="p">)),</span> <span class="n">_Decay_copy</span><span class="p">(</span><span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Ax</span><span class="p">))...));</span>
        <span class="c1">//一堆乱七八糟连带着完美转发和退化的。你看到copy了。所以说了thread是一种必拷贝传值的。引用的话得用ref包一下。</span>
    <span class="p">}</span>
 
	<span class="o">~</span><span class="kr">thread</span><span class="p">()</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	    <span class="c1">// 析构函数</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span>         <span class="c1">// 如果析构线程对象的时候，线程依旧是可结合的（没有调用join或detach）的话会调用terminate</span>
			<span class="n">_XSTD</span> <span class="n">terminate</span><span class="p">();</span>  <span class="c1">// terminate会调用abort()来终止程序</span>
	<span class="p">}</span>
 
	<span class="kr">thread</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span> <span class="o">:</span> <span class="n">_Thr</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">)</span> <span class="p">{</span>	    <span class="c1">// 拷贝构造函数，调用move</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="kr">thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	<span class="c1">// 赋值函数，调用move</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">_Move_thread</span><span class="p">(</span><span class="n">_Other</span><span class="p">));</span>
	<span class="p">}</span>
 
	<span class="kr">thread</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>                 <span class="c1">// 禁用 拷贝构造函数</span>
	<span class="kr">thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>      <span class="c1">// 禁用 赋值函数</span>
 
	<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	        <span class="c1">// 交换两线程</span>
		<span class="n">_STD</span> <span class="n">swap</span><span class="p">(</span><span class="n">_Thr</span><span class="p">,</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="kt">bool</span> <span class="nf">joinable</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	            <span class="c1">// 若线程可结合程，返回 true；否则，返回flase</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">_Thr_is_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">));</span>               <span class="c1">// 宏定义，原型为：#define _Thr_is_null(thr) (thr._Id == 0)</span>
	<span class="p">}</span>
 
	<span class="kt">void</span> <span class="nf">join</span><span class="p">();</span>                                    <span class="c1">// 线程结合，阻塞的</span>
 
	<span class="kt">void</span> <span class="nf">detach</span><span class="p">()</span> <span class="p">{</span>	                                <span class="c1">// 线程分离</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">joinable</span><span class="p">())</span>                            <span class="c1">// 若线程是不可结合的，则异常</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>
		<span class="n">_Thrd_detachX</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>					<span class="c1">//detach的核心</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>					<span class="c1">//设置线程id为0</span>
	<span class="p">}</span>
 
	<span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span><span class="p">;</span>                    <span class="c1">// 获取线程唯一 id</span>
 
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">hardware_concurrency</span><span class="p">()</span> <span class="n">_NOEXCEPT</span> <span class="p">{</span>	    <span class="c1">// 返回硬件线程上下文数量</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">::</span><span class="n">Concurrency</span><span class="o">::</span><span class="n">details</span><span class="o">::</span><span class="n">_GetConcurrency</span><span class="p">());</span>
	<span class="p">}</span>
 
	<span class="n">native_handle_type</span> <span class="nf">native_handle</span><span class="p">()</span> <span class="p">{</span>	        <span class="c1">// 以 void* 形式返回线程的 Win32 句柄</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">_Thr</span><span class="p">.</span><span class="n">_Hnd</span><span class="p">);</span>
	<span class="p">}</span>
 
<span class="k">private</span><span class="o">:</span>
	<span class="kr">thread</span><span class="o">&amp;</span> <span class="n">_Move_thread</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="p">{</span>	        <span class="c1">// move from _Other</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span>
			<span class="n">_XSTD</span> <span class="n">terminate</span><span class="p">();</span>
		<span class="n">_Thr</span> <span class="o">=</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">;</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="n">_Thrd_t</span> <span class="n">_Thr</span><span class="p">;</span>            <span class="c1">// 私有成员变量，_Thrd_t是一个结构体</span>
<span class="p">};</span>

</pre></table></code></div></div><p>里面的<code class="language-plaintext highlighter-rouge">_Thrd_t</code>结构体长这样：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">_Thrd_t</span> <span class="n">_Thr</span><span class="p">;</span> <span class="c1">//其实_Thrd_t 是类型的别名</span>
 
<span class="k">typedef</span> <span class="n">_Thrd_imp_t</span> <span class="n">_Thrd_t</span><span class="p">;</span>    <span class="c1">// 而_Thrd_imp_t是一个结构体</span>
 
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>	<span class="cm">/* 线程 Win32 标识符 */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">_Hnd</span><span class="p">;</span>	    <span class="cm">/* Win32 句柄 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">_Id</span><span class="p">;</span>    <span class="c1">// 线程id</span>
<span class="p">}</span> <span class="n">_Thrd_imp_t</span><span class="p">;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">join</code>长这样：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>
<span class="kr">inline</span> <span class="kt">void</span> <span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">(){</span>	<span class="c1">// join thread</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">joinable</span><span class="p">())</span>            <span class="c1">// 如果线程不可结合，调用join就报错。</span>
		<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_Thr_is_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">))</span>     <span class="c1">// 如果是空线程，调用join继续报错。</span>
		<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">get_id</span><span class="p">()</span> <span class="o">==</span> <span class="n">_STD</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">())</span> <span class="c1">// 线程不能自己join自己。自己join自己就死锁了。</span>
		<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_RESOURCE_DEADLOCK_WOULD_OCCUR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">_Thrd_join</span><span class="p">(</span><span class="n">_Thr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_Thrd_success</span><span class="p">)</span>   <span class="c1">// 线程结合（_Thrd_join()是join方法的核心），是阻塞的</span>
		<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_NO_SUCH_PROCESS</span><span class="p">);</span> <span class="c1">//如果结合失败就报错</span>
	<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>        <span class="c1">// 设置线程id为0</span>
<span class="p">}</span>

</pre></table></code></div></div><p>所以我们看到这几种情况不可以<code class="language-plaintext highlighter-rouge">join</code>：</p><ul><li>默认构造的线程对象（空对象）<li>是非joinable的 (比如已经<code class="language-plaintext highlighter-rouge">join</code>或者<code class="language-plaintext highlighter-rouge">detach</code>过的，<code class="language-plaintext highlighter-rouge">move</code>过的和空的）<li>自己和自己。</ul><p>如果一个可结合的线程经过<code class="language-plaintext highlighter-rouge">join</code>后（等线程执行完毕后），会将线程id置为0。</p><p><strong>我们查看<code class="language-plaintext highlighter-rouge">_Move_thread</code>函数可以发现，如果尝试给一个仍有效的线程对象再次用一个线程对象赋值，则会触发<code class="language-plaintext highlighter-rouge">terminate</code></strong></p><h2 id="为什么析构一个非joinable的线程会报错"><span class="mr-2">为什么析构一个非joinable的线程会报错？</span><a href="#为什么析构一个非joinable的线程会报错" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>在实例化了线程对象之后，它们的状态默认都是可结合的，如果现在直接调用它们的析构函数来析构它们，那么在析构的时候线程处于什么状态呢？是执行完了吗？还是正在执行呢？注意，如果一个在没有结合（join）的情况下，就算它先于主线程执行完毕，其id依然是不为0的。所以我们是不能确定其状态的，所以我们只能析构明确了id为0的线程。因为id为0的线程要么已经执行完毕，要么是空线程，要么是分离后的线程。<li>另外，一个线程分离（<code class="language-plaintext highlighter-rouge">detach</code>）后，该线程对象便不能控制该线程，而是交由系统接管。</ul><p>学习，整理自<a href="https://blog.csdn.net/hujingshuang/article/details/70208443">这里</a></p><h1 id="join和detach区别">join和detach区别</h1><ul><li><code class="language-plaintext highlighter-rouge">join</code>在主线程和新线程中引入了一个同步点。<ul><li>主线程调用<code class="language-plaintext highlighter-rouge">join</code>后，会阻塞直到新线程完成并返回。只有当<code class="language-plaintext highlighter-rouge">join</code>返回后，主线程才能回收被调线程资源，并继续运行。</ul><li>当使用<code class="language-plaintext highlighter-rouge">detach</code>函数时，主线程继续运行，被调线程驻留后台运行。二者同时运行。主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。（<code class="language-plaintext highlighter-rouge">thread</code>对象已和底层执行线程分离）</ul><p>我们对一个线程对象使用<code class="language-plaintext highlighter-rouge">join</code>或<code class="language-plaintext highlighter-rouge">detach</code>后，这个线程对象就不再是<code class="language-plaintext highlighter-rouge">joinable</code>的了。这时候线程对象可以被安全销毁。</p><p>当<code class="language-plaintext highlighter-rouge">detach</code>函数被调用后，执行的线程从线程对象中被分离，已不再被一个线程对象所表达–这是两个独立的事情。<strong>C++线程对象可以被销毁，同时OS执行的线程可以继续。</strong>如果程序想要知道执行的线程何时结束，就需要一些其它的机制。<code class="language-plaintext highlighter-rouge">join</code>函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。 <strong>去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，要么<code class="language-plaintext highlighter-rouge">join</code>函数需要被调用（并结束），要么<code class="language-plaintext highlighter-rouge">detach</code>函数被调用。如果一个C++线程对象当销毁时仍然可以被<code class="language-plaintext highlighter-rouge">join</code>，异常会被抛出。</strong></p><h1 id="提防表面的线程安全">提防表面的线程安全</h1><p>假设我们有这样一个表面线程安全的<code class="language-plaintext highlighter-rouge">stack</code>包装器</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">not_good_stack</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">my_stk</span><span class="p">;</span>
    <span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">){</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lcg</span> <span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="n">my_stk</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">pop</span><span class="p">(){</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lcg</span> <span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="n">my_stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="kt">bool</span> <span class="nf">empty</span><span class="p">(){</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lcg</span> <span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">my_stk</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="n">top</span><span class="p">(){</span>
            <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lcg</span> <span class="p">(</span><span class="n">m</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">my_stk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>它很简单，因为只是给每一个标准库实现的函数外面加了个锁。而且现在看起来很安全。不会同时又<code class="language-plaintext highlighter-rouge">push</code>又<code class="language-plaintext highlighter-rouge">pop</code>。但是有一个问题。在<code class="language-plaintext highlighter-rouge">empty</code>和<code class="language-plaintext highlighter-rouge">pop</code>中间，<code class="language-plaintext highlighter-rouge">top</code>和<code class="language-plaintext highlighter-rouge">pop</code>中间都会有间接的线程不安全问题。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">race1</span><span class="p">(){</span>
    <span class="n">not_good_stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mystk</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mystk</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">mystk</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">mystk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>  
<span class="p">}</span>
</pre></table></code></div></div><p>在这种情况下，假设我们现在<code class="language-plaintext highlighter-rouge">stack</code>只有一个元素。有可能有两个线程并发的进入了该函数。</p><ul><li>第一个函数检查是否为空，答案是不为空，所以进入<code class="language-plaintext highlighter-rouge">if</code>。<li>第二个函数此时刚好也进来了，检查是否为空。由于第一个函数没有来得及进行下一步，则此时依旧不为空。也进入<code class="language-plaintext highlighter-rouge">if</code>。</ul><p>这时候就已经有问题了。可能第一个元素已经移除元素，这时候<code class="language-plaintext highlighter-rouge">top</code>会出现错误。</p><p>甚至，因为两个线程必定会执行两次<code class="language-plaintext highlighter-rouge">pop</code>。但是此时只有一个元素。所以会出现错误。</p><p>如果并不是只有一个元素，也会额外的多删除一个元素。也是错误。</p><h2 id="如何解决"><span class="mr-2">如何解决</span><a href="#如何解决" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>一般有两种方式。</p><ul><li>第一种方式是针对整个函数<code class="language-plaintext highlighter-rouge">race1</code>加锁。<li>另一种方式是把有竞争关系的函数整合为一个。例如<code class="language-plaintext highlighter-rouge">empty</code>和<code class="language-plaintext highlighter-rouge">pop</code>合起来</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">pop</span><span class="p">(){</span>
    <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span><span class="n">lcg</span> <span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">my_stk</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"already empty"</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">my_stk</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="信号量">信号量</h1><ul><li>这个<code class="language-plaintext highlighter-rouge">sem_init</code>最后的值意思是初始值是几。也不能完全理解为物品容量。信号量后续操作是单纯地对那个数字进行增减。而这个数字只有初始值而没有顶（所以会溢出）。<code class="language-plaintext highlighter-rouge">wait</code>会让这个数字减掉1。如果<strong>相减后</strong>小于0了就阻塞<strong>（所以这个数字理论上可以到-1，因为我们如果现在是1，则拿一个资源就是0。因为现在我拿到了资源所以不会被阻塞，然后下一个线程进来了-1，发现结果变成了-1，就会阻塞）</strong>。<li><strong>选择题中，这个值可以为负。负数就是目前有多少个进程/线程在等待该资源</strong><li><strong>这个值可能会溢出。也就是初始值假如5，可能变成6，溢出，这样会返回错误 一个错误代码是<code class="language-plaintext highlighter-rouge">EOVERFLOW</code>。但是一般操作系统会忽略。</strong><li><code class="language-plaintext highlighter-rouge">post</code>会让睡眠的进程唤醒，如果<strong>相加后</strong>发现信号量值&lt;=0，意味着有程序被阻塞，则会唤醒对应的线程或者是进程。如果&gt;0则意味着没有进程睡眠</ul><p>这也就是为什么信号量是<strong>先等待（-1），后加锁</strong>。因为<code class="language-plaintext highlighter-rouge">wait</code>本身是阻塞的，如果小于0了就阻塞。如果先加锁，发现小于0了直接阻塞就没办法解锁了。这也是为什么条件变量要反过来。</p><h2 id="如何理解信号量"><span class="mr-2">如何理解信号量</span><a href="#如何理解信号量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>信号量理解为需要控制的资源数量。</strong>比如经典的更衣室场景。我们不应该只限制一个人在更衣室内，假如更衣室的容量是50，则应该允许高达50人同时在更衣室内。所以使用信号量，让信号量的初始值为50是非常合理的选择，也满足语义。<li><strong>所以如果初始值是1，那么这就是一种互斥锁。</strong><li><strong>同时，我们反复强调，只有当信号量数值小于等于0的时候才会引起阻塞，所以由于这个特殊性，信号量不需要broadcast。</strong>因为信号量数值增加（有人从更衣室出来）的方式只可以是一个一个增加，所以只需要挑选一个睡眠的进程（线程）唤醒即可。</ul><h2 id="例子"><span class="mr-2">例子</span><a href="#例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>假设我们使用的是一个信号量，即消费者和生产者共享信号量。<ul><li>一个信号量的时候就是，如果数字不为0，就该消费消费该生产生产。如果数字为0了，那么消费者就等着，等生产者生产完了通知后继续消费。<li>首先，初始化的时候，我们不能让消费者直接消费，所以初始化的值一定是0。（如果生产者消费者区分信号量，则生产者信号量初始值应为队列的最大值，消费者信号量初始值仍旧应为0。<li>生产者：<ul><li>加锁<li>生产<li>解锁<li>post [+1]</ul><li>消费者：<ul><li>wait [-1] 一定要先等待。如果上来就锁了，因为wait是阻塞的如果是0就阻塞等待，那生产者也拿不到锁也没办法生产了。<li>加锁<li>消费<li>解锁</ul></ul><li>假设我们使用的是两个信号量，即消费者和生产者<strong>不</strong>共享信号量。（其实和条件变量差不多）<ul><li>首先，初始化的时候，我们不能让消费者直接消费，所以初始化的值一定是0。但是生产者可以直接生产。所以初始化的值可以为队列最大值，比如8。<li>生产者：<ul><li>wait[-1] 注意这个时候是减掉的生产者自己的空位。也就是每生产一次，减掉一个。他最多生产8个，生产多了就停止等待让这个数字不为0。（消费者会+1）<li>加锁<li>生产<li>解锁<li>post [+1]注意这个时候是添加的消费者的消费。让消费者的信号量不为1</ul><li>消费者：<ul><li>wait[-1] 注意这个时候是减掉的消费者自己的空位。也就是记录有多少可以消费的<li>加锁<li>消费<li>解锁<li>post[+1]注意这个是告诉生产者+1，也就是可生产的空位+1.</ul></ul></ul><h2 id="信号量可以有多种同步方式"><span class="mr-2">信号量可以有多种同步方式</span><a href="#信号量可以有多种同步方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>实现一次临时的happens-before 语义<ul><li>初始信号量为<code class="language-plaintext highlighter-rouge">0</code>,<li><code class="language-plaintext highlighter-rouge">A; V(S)</code><ul><li>V就是<code class="language-plaintext highlighter-rouge">post</code></ul><li><code class="language-plaintext highlighter-rouge">P(S); B</code><ul><li><code class="language-plaintext highlighter-rouge">P</code>就是<code class="language-plaintext highlighter-rouge">wait</code></ul><li>假设S只被使用一次，则保证A happens-before B。因为如果A没有执行完毕后把信号量的值增加1，则B无法执行，因为前面一直在等待信号量的值增加。<li>举个例子就是标准库的线程的<code class="language-plaintext highlighter-rouge">join</code>操作。如果使用这个方法，则每一个子线程会<code class="language-plaintext highlighter-rouge">V(Sn)</code>。主线程会<code class="language-plaintext highlighter-rouge">P(Sn)</code>。比如第一个线程会<code class="language-plaintext highlighter-rouge">V(S1)</code>，第二个线程会<code class="language-plaintext highlighter-rouge">V(S2)</code>。主线程就是<code class="language-plaintext highlighter-rouge">P(S1); P(S2)</code></ul></ul><p><a href="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230508221734.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230508221734.png" alt="QQ截图20230508221734" class="lazyload" data-proofer-ignore></a></p><ul><li>实现计数型同步<ul><li>初始信号量为<code class="language-plaintext highlighter-rouge">0</code><li>执行线程每完成一次工作，<code class="language-plaintext highlighter-rouge">V(S)</code><li>主线程等候，<code class="language-plaintext highlighter-rouge">P(S) * 工作数量</code>来检查是否完成全部工作。<li>举个例子就是标准库的线程的<code class="language-plaintext highlighter-rouge">join</code>操作。如果使用这个方法，则每一个子线程会V(S)。主线程会<code class="language-plaintext highlighter-rouge">P(S)</code>。比如第一个线程会<code class="language-plaintext highlighter-rouge">V(S)</code>，第二个线程会<code class="language-plaintext highlighter-rouge">V(S)</code>。主线程就是<code class="language-plaintext highlighter-rouge">P(S)*n</code>。</ul></ul><p><a href="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230508221739.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230508221739.png" alt="QQ截图20230508221739" class="lazyload" data-proofer-ignore></a></p><h1 id="条件变量">条件变量</h1><p>条件变量的语义是：<strong><em>wait until</em></strong>。</p><p><strong>条件变量一定要先加锁而且必须是可以手动解锁的锁比如<code class="language-plaintext highlighter-rouge">unique_lock</code>而不能使用<code class="language-plaintext highlighter-rouge">lock_guard</code></strong>。也可以用一个条件变量也可以用两个。核心是<code class="language-plaintext highlighter-rouge">pthread_cond_wait</code>。原理是首先调用方抢锁，然后发现需要等待，所以调用方会被阻塞（睡眠并加入等待队列），然后互斥锁解锁，让其余线程抢锁。其余线程如果抢到锁执行完了任务，然后就可以调用<code class="language-plaintext highlighter-rouge">notify</code>通知。通知后调用方的<code class="language-plaintext highlighter-rouge">wait</code>会重新加锁并唤醒当前进程（之后<code class="language-plaintext highlighter-rouge">wait</code>函数返回）。<strong>系统保证解锁并睡眠是原子操作。系统也保证加锁并唤醒是原子操作。</strong></p><ul><li>为了防止虚假唤醒，必须要使用<code class="language-plaintext highlighter-rouge">while</code>而不能使用wait。</ul><p>因为首先，我们的生产者和消费者线程全部都是<code class="language-plaintext highlighter-rouge">wait</code>同一个条件变量。我们在<code class="language-plaintext highlighter-rouge">wait</code>函数返回之前，当前进程必须执行 <strong>拿到锁–&gt;加锁并唤醒</strong> 这两步。加锁并唤醒是原子的，但是并不一定能拿得到这个锁。假如我们消费者1在等待，然后生产者生产完毕，通知消费者。假如这个时候消费者2进来了，直接就拿了锁（因为生产者释放锁到<code class="language-plaintext highlighter-rouge">wait</code>函数拿锁这两步不是原子的。存在这种第三方插进来的情况）然后消费了生产的数据。然后释放锁。这时候我们消费者1才终于拿到锁了，但是这个时候抢到的锁在语义上可能并不是被原始生产者释放的锁，而是被其他消费者释放的锁。所以发现数据已经被消费了（或者是不满足某一条件），这样再去拿数据会有错误。所以必须用<code class="language-plaintext highlighter-rouge">while</code>。也就是使用判别式。</p><p><strong>再详细解释一下第三方插进来的情况。其实这样解释并不准确。因为我们提到过，我们的生产者和消费者线程全部都是<code class="language-plaintext highlighter-rouge">wait</code>同一个条件变量。所以我们<code class="language-plaintext highlighter-rouge">notify</code>不一定是<code class="language-plaintext highlighter-rouge">notify</code>到具体哪一个生产者或者是哪个消费者。如果不使用<code class="language-plaintext highlighter-rouge">while</code>再次判断的话，就会发生错误。提到的不满足某一条件，比如队列为空等等。</strong>举个例子，此时两个消费者都卡在<code class="language-plaintext highlighter-rouge">wait</code>。生产者生产了一个，<code class="language-plaintext highlighter-rouge">notify</code>。这时候<code class="language-plaintext highlighter-rouge">notify</code>了一个消费者，消费者拿到了锁，消费过后队列为空。这时候再解锁，<code class="language-plaintext highlighter-rouge">notify</code>一个生产者，表示可以生产了。但是此时可能<code class="language-plaintext highlighter-rouge">notify</code>到了另一个消费者。因为消费者已经卡在<code class="language-plaintext highlighter-rouge">wait</code>了（已经判断过条件了），它拿到了锁。然后再想消费但是队列为空。这时候就错了。</p><p><a href="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506004803.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506004803.png" alt="QQ截图20230506004803" class="lazyload" data-proofer-ignore></a></p><ul><li>注意条件变量的信号丢失问题。<strong>因为如果没有<code class="language-plaintext highlighter-rouge">notify()</code>，则<code class="language-plaintext highlighter-rouge">wait()</code>的线程永远不会唤醒。</strong></ul><p>看看例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">gMtx</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">Sender</span><span class="p">(){</span>	
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ready Send notification."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">//先解锁</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>   <span class="c1">// 发送通知</span>
 <span class="p">}</span>

<span class="kt">void</span> <span class="nf">Receiver</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wait for notification."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span>    <span class="c1">// 等待通知并唤醒继续执行下面的指令</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Process."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">sender</span><span class="p">(</span><span class="n">Sender</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">receiver</span><span class="p">(</span><span class="n">Receiver</span><span class="p">);</span>
    <span class="n">sender</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">receiver</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>线程随机启动导致的唤醒丢失，即：通信线程先启动并调用通知函数（<code class="language-plaintext highlighter-rouge">notify_one</code>），但是接收线程还没有开始执行等待（<code class="language-plaintext highlighter-rouge">wait</code>）函数，如果不再次调用函数通知，等待会一直持续下去。这个是最容易发现和验证的问题，上面的主线程中启动线程的顺序就会概率性出现唤醒丢失的问题。</p><p>解决方案也比较简单。也是搭配<code class="language-plaintext highlighter-rouge">while</code>和判断式。其实和上面解决虚假唤醒的道理一致。只不过要注意使用<code class="language-plaintext highlighter-rouge">while</code></p><ul><li><code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>后面的判断式（谓词）的意思是，只要后面的谓词返回<code class="language-plaintext highlighter-rouge">false</code>，则前面无论如何都不会解锁。尽管可能已经被通知到。</ul><p>判断式法：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">gMtx</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">send</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">Sender</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ready Send notification."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="n">send</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">//先解锁</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>   <span class="c1">// 发送通知</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Receiver</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wait for notification."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lck</span><span class="p">,</span> <span class="p">[](){</span><span class="k">return</span> <span class="n">send</span><span class="p">;});</span>    <span class="c1">// 等待通知并唤醒继续执行下面的指令</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Process."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">sender</span><span class="p">(</span><span class="n">Sender</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">receiver</span><span class="p">(</span><span class="n">Receiver</span><span class="p">);</span>
    <span class="n">sender</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">receiver</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>上面的谓词可以等同于这种写法：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Receiver1</span><span class="p">()</span>
<span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wait for notification."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
     <span class="k">while</span><span class="p">(</span><span class="n">send</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span> <span class="c1">// 等待通知并唤醒继续执行下面的指令</span>
     <span class="p">}</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Process."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>有没有发现和解决虚假唤醒的很像？都是<code class="language-plaintext highlighter-rouge">while</code>内有一个判别式，然后循环判断等待。</p><ul><li><strong>这个方法可以解决唤醒丢失的原因：</strong><ul><li>我们的问题在于<code class="language-plaintext highlighter-rouge">sender</code>先发送了<code class="language-plaintext highlighter-rouge">notify</code>，然后<code class="language-plaintext highlighter-rouge">receiver</code>才开始<code class="language-plaintext highlighter-rouge">wait</code>。导致丢失<li>所以在使用上述方法后，就算<code class="language-plaintext highlighter-rouge">sender</code>先发送了<code class="language-plaintext highlighter-rouge">nofity</code>，但是此时<code class="language-plaintext highlighter-rouge">send</code>已经被<code class="language-plaintext highlighter-rouge">sender</code>变更为<code class="language-plaintext highlighter-rouge">true</code>。所以此时就算唤醒<code class="language-plaintext highlighter-rouge">receiver</code>的信号已经丢失，由于<code class="language-plaintext highlighter-rouge">send</code>是<code class="language-plaintext highlighter-rouge">true</code>，所以不会被阻塞。</ul><li>二者的解决方式都是<code class="language-plaintext highlighter-rouge">while</code>+判别式。<li>为什么要先解锁，再通知？也就是先<code class="language-plaintext highlighter-rouge">unlock()</code>，再<code class="language-plaintext highlighter-rouge">notify_one()</code>？<ul><li>语义上没什么区别，但是性能会有一点点提升。原因是如果先通知再解锁，在通知的那一刻，<code class="language-plaintext highlighter-rouge">wait</code>中的被通知线程会尝试获取锁，但是这时候通知线程还没有释放锁，所以被通知线程又会被阻塞一次然后睡眠，加入等待队列。如果是先释放锁，则不会发生这种情况。也就是它可能会直接获取锁成功。<ul><li>这时候可能会问，我要是先解锁不就有可能通知线程又抢了一次吗？没错，但是就算是后解锁也有可能发生这种情况。也就是所有情况下，都可能发生虚假唤醒。这种情况其实并不要紧。</ul><li>来自<a href="https://youtu.be/F6Ipn7gCOsY?t=2200">这里</a> 和 <a href="https://stackoverflow.com/questions/55154462/c-condition-variable-notify-one-before-or-after-release-lock">这里</a></ul></ul><h2 id="简要分析源码"><span class="mr-2">简要分析源码</span><a href="#简要分析源码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre><td class="rouge-code"><pre><span class="c1">// 阻塞等待条件。进入该函数前，已经获得了互斥锁mutex</span>
<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">volatile</span> <span class="n">pthread_t</span> <span class="n">self</span> <span class="o">=</span> <span class="n">thread_self</span><span class="p">();</span>
    
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span><span class="c1">// 加锁操作队列</span>

    <span class="n">enqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_waiting</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span> <span class="c1">// 插入条件的等待队列</span>

    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span> <span class="c1">// 操作完释放锁</span>
    
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 释放互斥变量，否则别人无法操作资源，导致条件一直无法满足</span>
    
    <span class="n">suspend_with_cancellation</span><span class="p">(</span><span class="n">self</span><span class="p">);</span> <span class="c1">// 挂起，然后等待条件满足后被唤醒</span>
	<span class="c1">//上面这行和下面这行不是原子的，所以虚假唤醒发生在这里。</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 被唤醒后重新获取互斥锁</span>
    <span class="cm">/* This is a cancellation point */</span>
    <span class="c1">// 取消点，等待期间被取消了</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">p_canceled</span> <span class="o">&amp;&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">p_cancelstate</span> <span class="o">==</span> <span class="n">PTHREAD_CANCEL_ENABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Remove ourselves from the waiting queue if we're still on it */</span>
        <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span>
        <span class="c1">// 线程准备退出，从条件阻塞队列中移除</span>
        <span class="n">remove_from_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_waiting</span><span class="p">,</span> <span class="n">self</span><span class="p">);</span>
        <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span>
        <span class="n">pthread_exit</span><span class="p">(</span><span class="n">PTHREAD_CANCELED</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">suspend_with_cancellation</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sigset_t</span> <span class="n">mask</span><span class="p">;</span>
  <span class="n">sigjmp_buf</span> <span class="n">jmpbuf</span><span class="p">;</span>
  <span class="c1">// 获取当前的信号屏蔽码</span>
  <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span> <span class="cm">/* Get current signal mask */</span>
  <span class="c1">// 清除PTHREAD_SIG_RESTART的信号掩码，即允许处理该信号</span>
  <span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">PTHREAD_SIG_RESTART</span><span class="p">);</span> <span class="cm">/* Unblock the restart signal */</span>
  <span class="cm">/* No need to save the signal mask, we'll restore it ourselves */</span>
  <span class="cm">/*
    直接调用返回0，从siglongjump回来返回非0,这里支持线程挂起时，
    收到restart信号被唤醒，或者在取消信号的处理函数中，通过siglongjmp返回这里
  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigsetjmp</span><span class="p">(</span><span class="n">jmpbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">p_cancel_jmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">jmpbuf</span><span class="p">;</span>
    <span class="c1">// 已经被取消并且是可取消的则直接返回，否则挂起等待唤醒</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">p_canceled</span> <span class="o">&amp;&amp;</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">p_cancelstate</span> <span class="o">==</span> <span class="n">PTHREAD_CANCEL_ENABLE</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="c1">// 挂起等待restart信号</span>
        <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">);</span>               <span class="cm">/* Wait for a signal */</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">p_signal</span> <span class="o">!=</span> <span class="n">PTHREAD_SIG_RESTART</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">p_cancel_jmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 从cancel信号的处理函数中的siglongjmp返回，重新设置信号掩码,屏蔽restart信号</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="n">PTHREAD_SIG_RESTART</span><span class="p">);</span> <span class="cm">/* Reblock the restart signal */</span>
    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 条件满足，唤醒线程</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">th</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span>
  <span class="n">th</span> <span class="o">=</span> <span class="n">dequeue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_waiting</span><span class="p">);</span> <span class="c1">// 取出一个被被阻塞的线程</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">c_spinlock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">th</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">restart</span><span class="p">(</span><span class="n">th</span><span class="p">);</span> <span class="c1">// 发送信号唤醒他</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 给pid进程发送唤醒信号</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">restart</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">kill</span><span class="p">(</span><span class="n">th</span><span class="o">-&gt;</span><span class="n">p_pid</span><span class="p">,</span> <span class="n">PTHREAD_SIG_RESTART</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>整理自<a href="https://zhuanlan.zhihu.com/p/374385534">这里</a></p><h2 id="生产者消费者模型中到底使用几个条件变量"><span class="mr-2">生产者消费者模型中，到底使用几个条件变量？</span><a href="#生产者消费者模型中到底使用几个条件变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>针对条件变量和生产者消费者模型到底应该用几个条件变量的问题，比较看情况。有可能生产者和消费者各有一个，也可能同时使用一个。为什么呢？</strong></p><ul><li>这是一个非常不好解答的问题。因为这个和死锁息息相关。比如下面的例子。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cvS</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cvR</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">gMtx</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">countm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">SenderS</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">countm</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="s">"exceedin S"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span> <span class="c1">//or cvS.wait(lck);</span>
    <span class="p">}</span>
    <span class="n">countm</span><span class="o">++</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"S"</span><span class="o">&lt;&lt;</span> <span class="n">countm</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>  <span class="c1">//or cvR.notify_one(); or cv.notify_all();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">ReceiverS</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">gMtx</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">countm</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="s">"exceedin R"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span> <span class="c1">//or cvR.wait(lck);</span>
    <span class="p">}</span>
    <span class="n">countm</span><span class="o">--</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="s">"R"</span> <span class="o">&lt;&lt;</span> <span class="n">countm</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">lck</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>  <span class="c1">//or cvS.notify_one(); or cv.notify_all();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Sender</span><span class="p">(){</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">SenderS</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">Receiver</span><span class="p">(){</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">ReceiverS</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">sender1</span><span class="p">(</span><span class="n">Sender</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">receiver1</span><span class="p">(</span><span class="n">Receiver</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">sender2</span><span class="p">(</span><span class="n">Sender</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">receiver2</span><span class="p">(</span><span class="n">Receiver</span><span class="p">);</span>
    <span class="n">sender1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">receiver1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">sender2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">receiver2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>上面的代码死锁了。为何会死锁？现在我们只使用1个条件变量<code class="language-plaintext highlighter-rouge">cv</code>，并且使用的是<code class="language-plaintext highlighter-rouge">cv.notify_one()</code><ul><li>在极限情况下，假设现在有一个<code class="language-plaintext highlighter-rouge">ReceiverS</code>执行了，卡在<code class="language-plaintext highlighter-rouge">cv.wait</code>。然后这时候是第二个<code class="language-plaintext highlighter-rouge">ReceiverS</code>执行，也卡在<code class="language-plaintext highlighter-rouge">cv.wait</code>了。然后这时候只能从两个<code class="language-plaintext highlighter-rouge">SenderS</code>中选。其中一个<code class="language-plaintext highlighter-rouge">SenderS</code>成功执行，<strong>然后这时候非常不巧。<code class="language-plaintext highlighter-rouge">notify</code>的还是一个<code class="language-plaintext highlighter-rouge">SenderS</code></strong>。然后卡在<code class="language-plaintext highlighter-rouge">cv.wait</code>。然后最后只剩下一个<code class="language-plaintext highlighter-rouge">SenderS</code>，又卡在<code class="language-plaintext highlighter-rouge">cv.wait</code>了。此时所有线程都卡在了<code class="language-plaintext highlighter-rouge">cv.wait</code>。死锁发生。</ul><li>但是为什么改成两个条件变量，也就是<code class="language-plaintext highlighter-rouge">cvS</code>和<code class="language-plaintext highlighter-rouge">cvR</code>就没事呢？<ul><li>假设现在有一个<code class="language-plaintext highlighter-rouge">ReceiverS</code>执行了，卡在<code class="language-plaintext highlighter-rouge">cvR.wait</code>。然后这时候是第二个<code class="language-plaintext highlighter-rouge">ReceiverS</code>执行，也卡在<code class="language-plaintext highlighter-rouge">cvR.wait</code>了。然后这时候只能从两个<code class="language-plaintext highlighter-rouge">SenderS</code>中选。其中一个<code class="language-plaintext highlighter-rouge">SenderS</code>成功执行，<strong>然后这时候<code class="language-plaintext highlighter-rouge">notify</code>一定且只能通知到等待<code class="language-plaintext highlighter-rouge">cvR</code>的线程，也就是<code class="language-plaintext highlighter-rouge">ReceiverS</code></strong>。就算现在唤醒的这个<code class="language-plaintext highlighter-rouge">ReceiverS</code>没有成功抢锁，被一个<code class="language-plaintext highlighter-rouge">SenderS</code>抢到了，<code class="language-plaintext highlighter-rouge">SenderS</code>卡在<code class="language-plaintext highlighter-rouge">cvS.wait</code>了。然后此时又没有成功抢锁，第二个<code class="language-plaintext highlighter-rouge">SenderS</code>抢到了，<code class="language-plaintext highlighter-rouge">SenderS</code>也卡在<code class="language-plaintext highlighter-rouge">cvS.wait</code>了。不过没关系。这时候抢到锁的一定是仅剩的一个<code class="language-plaintext highlighter-rouge">ReceiverS</code>。<strong>因为<code class="language-plaintext highlighter-rouge">ReceiverS</code>此时已经被唤醒，只是没抢到锁，只要能抢到锁程序就可以继续。</strong>然后此时<code class="language-plaintext highlighter-rouge">notify</code>一定且只能通知到等待<code class="language-plaintext highlighter-rouge">cvS</code>的线程，也就是<code class="language-plaintext highlighter-rouge">SenderS</code>。程序继续。</ul><li>或者改成<code class="language-plaintext highlighter-rouge">cv.notify_all();</code><ul><li>这样可以确保唤醒所有等候的线程。因为这种情况死锁的核心是非常不巧的<code class="language-plaintext highlighter-rouge">notify</code>到了自己类型的线程。也就是发送者通知发送者，接收者通知接收者。</ul></ul><p>所以说，具体使用一个或两个不是那么简单就可以决定的。这是我的<a href="https://stackoverflow.com/questions/76187529/how-many-conditoinal-variables-should-be-used-in-producer-consumer-problem">提问</a>。<strong>根据我的个人分析，如果使用一个条件变量，为了避免唤醒到错误的线程，则应该使用<code class="language-plaintext highlighter-rouge">notify_all()</code>唤醒所有等候线程。如果使用两个条件变量，则使用<code class="language-plaintext highlighter-rouge">notify_one()</code>唤醒对方的一个线程即可。</strong></p><p><strong>同时，具体的<code class="language-plaintext highlighter-rouge">while</code>判断的<code class="language-plaintext highlighter-rouge">wait</code>的条件也很重要。比如现在是两个接收者和两个发送者。如果不更改原有死锁代码，只把<code class="language-plaintext highlighter-rouge">countm &gt;= 1</code>更改为<code class="language-plaintext highlighter-rouge">countm &gt;= 2</code>便没有问题。但是，如果这时候又加了一个发送者，三个发送者的话此时又会死锁。</strong>所以为了根本性避免这个问题，就应该使用上一段提到的，自我总结的规则。因为一般来说，具体的<code class="language-plaintext highlighter-rouge">while</code>判断的<code class="language-plaintext highlighter-rouge">wait</code>的条件是不确定的，比如在任务队列场景下，具体应该大于几是可以更改的，同时，具体由几个线程也是可以更改的。但是。任务队列本身的逻辑不应该变动。</p><h1 id="杂项">杂项</h1><ul><li>注意，线程对象在创建时就已经启动。而非调用<code class="language-plaintext highlighter-rouge">join</code>或<code class="language-plaintext highlighter-rouge">detach</code>时启动，这里和异步API有些不同。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"我的线程开始执行了"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"我的线程结束执行了"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">my_thread</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
    <span class="n">my_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span><span class="c1">//等待子线程执行结束</span>

    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"abc"</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
我的线程开始执行了
我的线程结束执行了

然后睡眠直到时间到达。开始继续执行join
abc

*/</span>
</pre></table></code></div></div><p>C++11原语和C++20原语的比较。来自<a href="https://youtu.be/F6Ipn7gCOsY?t=2573">这里</a></p><p><a href="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506032808.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506032808.png" alt="QQ截图20230506032808" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506032738.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0.assets/QQ%E6%88%AA%E5%9B%BE20230506032738.png" alt="QQ截图20230506032738" class="lazyload" data-proofer-ignore></a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0%20-%20Sterben_01&url=%2Fposts%2F%25E5%25B9%25B6%25E5%258F%2591%25E7%25AC%2594%25E8%25AE%25B0%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0%20-%20Sterben_01&u=%2Fposts%2F%25E5%25B9%25B6%25E5%258F%2591%25E7%25AC%2594%25E8%25AE%25B0%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E5%25B9%25B6%25E5%258F%2591%25E7%25AC%2594%25E8%25AE%25B0%2F&text=c++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98-%E7%AC%94%E8%AE%B0%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" class="btn btn-outline-primary" prompt="上一篇"><p>深度探索 C++ 对象模型 笔记</p></a> <a href="/posts/%E6%9D%82%E8%AE%B03/" class="btn btn-outline-primary" prompt="下一篇"><p>C++杂记 - 3</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
