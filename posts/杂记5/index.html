<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++杂记 - 5" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="std::pmr 多态内存分配器" /><meta property="og:description" content="std::pmr 多态内存分配器" /><link rel="canonical" href="/posts/%E6%9D%82%E8%AE%B05/" /><meta property="og:url" content="/posts/%E6%9D%82%E8%AE%B05/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-07T00:55:00-06:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++杂记 - 5" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-04T03:12:32-05:00","datePublished":"2023-03-07T00:55:00-06:00","description":"std::pmr 多态内存分配器","headline":"C++杂记 - 5","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%9D%82%E8%AE%B05/"},"url":"/posts/%E6%9D%82%E8%AE%B05/"}</script><title>C++杂记 - 5 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++杂记 - 5</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>C++杂记 - 5</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1678172100" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/03/07 </em> </span> <span> 更新于 <em class="" data-ts="1749024752" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/06/04 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="32522 字"> <em>180 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="stdpmr-多态内存分配器">std::pmr 多态内存分配器</h1><h2 id="先回顾一下标准分配器"><span class="mr-2">先回顾一下标准分配器</span><a href="#先回顾一下标准分配器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这一节最好搭配侯捷的标准STL内存分配器来看，这样可以很好帮助理解一些动作的行为。</p><p><strong>分配器的核心就是四个步骤： 分配空间（allocate），构造对象（construct），析构对象（destruct），解分配空间（deallocate）。</strong></p><p>标准内存分配器就提供了这四个函数。多态内存分配器也提供了这四个函数。</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308160711.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308160711.png" alt="QQ截图20230308160711" class="lazyload" data-proofer-ignore></a></p><ul><li>在标准分配器当中，<code class="language-plaintext highlighter-rouge">allocate</code>和<code class="language-plaintext highlighter-rouge">deallocate</code>对应的全局的<code class="language-plaintext highlighter-rouge">::operator new</code>和<code class="language-plaintext highlighter-rouge">::operator delete</code>。<code class="language-plaintext highlighter-rouge">construct</code>和<code class="language-plaintext highlighter-rouge">destruct</code>对应的就是元素的构造和析构</ul><h2 id="为什么要有多态内存分配器"><span class="mr-2">为什么要有多态内存分配器</span><a href="#为什么要有多态内存分配器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在没有多态内存分配器的时候，我们面临两个问题。</p><p><strong>第一种情况是内存分配器的传播问题。</strong></p><p>我们有一个独特的例子：</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162015.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162015.png" alt="QQ截图20230308162015" class="lazyload" data-proofer-ignore></a></p><ul><li>我们有一个<code class="language-plaintext highlighter-rouge">CustomString</code>类，每一个对象接受一个<code class="language-plaintext highlighter-rouge">allocator</code>。我们现在有三个不同<code class="language-plaintext highlighter-rouge">allocator</code>的同类对象。注意此时对象类型均为<code class="language-plaintext highlighter-rouge">CustomString</code>。<li>然后我们放入<code class="language-plaintext highlighter-rouge">vector</code>。在<code class="language-plaintext highlighter-rouge">push_back</code> <code class="language-plaintext highlighter-rouge">x1</code>和<code class="language-plaintext highlighter-rouge">x2</code>的时候没什么问题，使用了对应的分配器。但是如果我们在头部插入了<code class="language-plaintext highlighter-rouge">x3</code>，情况就不对了。<li><code class="language-plaintext highlighter-rouge">vector</code>的头插逻辑是先在下一个可用位置分配一块内存，然后使用移动（拷贝）构造在新的位置构造出最后一个元素。然后再按照顺序把前面的元素搬移（拷贝）。在搬移（拷贝中），分配器是不会被拷贝（赋值）的。因为永远不该这么做，因为内存是已经被分配好了的，无法更改。<li>所以这个时候有问题了。<code class="language-plaintext highlighter-rouge">x1</code>用了<code class="language-plaintext highlighter-rouge">alloc2</code>，<code class="language-plaintext highlighter-rouge">x3</code>用了<code class="language-plaintext highlighter-rouge">alloc1</code>。瞬间混乱了起来。</ul><p><strong>我们真正想要的是这样的东西：</strong></p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162600.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308162600.png" alt="QQ截图20230308162600" class="lazyload" data-proofer-ignore></a></p><ul><li>所以在C++17之前，我们有一个<code class="language-plaintext highlighter-rouge">std::scoped_allocator_adaptor</code>。我们可以把自己的分配器使用它包装，它可以保证分配器的正确传播：</ul><blockquote><p><code class="language-plaintext highlighter-rouge">std::scoped_allocator_adaptor</code> 类模板是可用于多层容器（ map 的 list 的 set 的 vector 等等）的分配器。它以外层分配器类型 <code class="language-plaintext highlighter-rouge">OuterAlloc</code> 与零或更多个内层分配器类型 <code class="language-plaintext highlighter-rouge">InnerAlloc...</code> 实例化。直接以 <code class="language-plaintext highlighter-rouge">scoped_allocator_adaptor</code> 构造的容器用 <code class="language-plaintext highlighter-rouge">OuterAlloc</code> 分配其元素，但若元素自身是容器，则它使用首个内存分配器。该容器的元素，若其自身是容器，则使用第二个内存分配器，以此类推。若容器的层级多于内层分配器的数量，则最内层分配器为所有进一步内嵌的容器再度使用。</p></blockquote><p><strong>第二个问题是内存分配器固有的问题：</strong></p><ul><li><p>针对默认内存分配器本身的性能有如下问题：</p><ul><li><p>内存分配、回收慢。</p><li><p>内存分配可能有锁。</p><li><p>内存对齐无法控制。</p><li><p>分配位置无法控制。比如连续多次分配时，内存的定域性/局部性(locality)无法保证。</p></ul><li><p>针对使用的参数方面有如下问题（尤其针对<code class="language-plaintext highlighter-rouge">std::allocator</code>)</p><ul><li><p><code class="language-plaintext highlighter-rouge">allocator</code>是模板签名的一部分。不同<code class="language-plaintext highlighter-rouge">allocator</code>的容器，无法混用。</p><ul><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// Default allocator</span>
<span class="c1">//上面的vector签名是：std::vector&lt;int, std::allocator&lt;int&gt;&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">MyAlloc</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">someAlloc</span><span class="p">);</span> <span class="c1">// 自定义分配器</span>
<span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// ERROR: v is a different type than std::vector&lt;int&gt;</span>
</pre></table></code></div></div><li>二者签名不匹配。我们尽管可以使用模板，但是这会让后面所有的函数都是模板。</ul><li><p>c++11以前，<code class="language-plaintext highlighter-rouge">allocator</code>无状态；c++11以后，可以有状态，然而<code class="language-plaintext highlighter-rouge">allocator</code>类型复杂难用。</p><li><p><code class="language-plaintext highlighter-rouge">allocator</code>内存对齐无法控制，需要传入自定义<code class="language-plaintext highlighter-rouge">allocator</code>。</p><li><p>以上三点、特别是第一点，造成STL无法成为软件接口(interface)的一部分。</p><li><p><strong>难以将局部特种内存（比如共享内存），内存池用于STL容器。</strong></p></ul></ul><h2 id="多态内存分配器内存资源和容器的关系"><span class="mr-2">多态内存分配器，内存资源和容器的关系</span><a href="#多态内存分配器内存资源和容器的关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308163419.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308163419.png" alt="QQ截图20230308163419" class="lazyload" data-proofer-ignore></a></p><p><code class="language-plaintext highlighter-rouge">memory_resource</code>是获得的原始内存，我们拿到了原始内存后，通过<code class="language-plaintext highlighter-rouge">polymorphic_allocator</code>分配器来进行分配。最后容器需要使用分配器来给元素分配内存。说白了，分配器从内存资源中获得资源，然后进行内存的再分配。<code class="language-plaintext highlighter-rouge">polymorphic_allocator</code>分配器是一层<code class="language-plaintext highlighter-rouge">memory_resource</code>的包装。</p><ul><li>多态内存分配器作用域下的容器是<code class="language-plaintext highlighter-rouge">pmr::</code>。其实就是别名模板。所以我们以<code class="language-plaintext highlighter-rouge">vector</code>为例：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">pmr</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="p">&gt;</span>
    <span class="k">using</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>由于多态内存分配器把内存资源的获取和分配分离开来，所以可以保证同一个元素哪怕底层内层资源不同，但是分配器的类型可以相同。</strong></p><p>这部分的细节我们后面再细说。</p><h3 id="再次解释一下多态内存分配器为什么解决了签名问题"><span class="mr-2">再次解释一下多态内存分配器为什么解决了签名问题</span><a href="#再次解释一下多态内存分配器为什么解决了签名问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>重申一下，内存资源不是类模板。而是使用了继承。所以这一部分是动态多态。所以说内存资源类型是运行时确定的。在编译期间，所有<code class="language-plaintext highlighter-rouge">pmr::vector&lt;T&gt;</code>类型的容器都是同一个类型。</strong>分配器使用一个内存资源的指针在内部对内存资源进行管理。在上面的<code class="language-plaintext highlighter-rouge">pmr::</code>容器中，我们看到了多态内存分配器的模板参数是元素类型。然后我们容器已经构建完毕了。然后我们可以使用容器的构造函数传入分配器。这里用<code class="language-plaintext highlighter-rouge">vector</code>举例子：去查看<a href="https://zh.cppreference.com/w/cpp/container/vector/vector">文档</a> 以第二个构造函数为例，就是接受一个分配器。</p><p>所以传入展开后会长这样：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">allocator2</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>我们可以看到所有的模板参数都是元素类型。分配器底层的内存资源并不影响分配器的类型。因为我们重申多态内存分配器把内存资源和分配分离开来了。所以针对同一元素类型的容器，可以使用不同类型的分配器。</strong></p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004954.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004954.png" alt="QQ截图20230309004954" class="lazyload" data-proofer-ignore></a></p><h2 id="内存资源-memory_resources"><span class="mr-2">内存资源 memory_resources</span><a href="#内存资源-memory_resources" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/image-20230308163929518.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/image-20230308163929518.png" alt="image-20230308163929518" class="lazyload" data-proofer-ignore></a></p><ul><li>上图是一个抽象简化版的内存资源类。我们看到里面有allocate和deallocate。这两个是非虚函数。他们的分配动作是委托给私有虚成员函数<code class="language-plaintext highlighter-rouge">do_allocate</code>和<code class="language-plaintext highlighter-rouge">do_deallocate</code>进行的。<ul><li><strong>这里是模板方法模式的NVI（non-virtual-interface）技术。</strong></ul><li><p><code class="language-plaintext highlighter-rouge">memory_resource</code>是一个抽象基类。STL给我们提供了内置的5种内存资源和一些工具函数。</p><ul><li><p>我们如果要自己实现自己的内存资源，也需要继承自此类。</p><li><blockquote><p>类 <code class="language-plaintext highlighter-rouge">std::pmr::memory_resource</code> 是抽象接口，针对封装内存资源类的无界集。</p></blockquote></ul><li><p>继承自<code class="language-plaintext highlighter-rouge">memory_resource</code>的类需要实现的函数主要是四个</p><ul><li><code class="language-plaintext highlighter-rouge">do_allocate</code><ul><li>从自身内存中分配特定大小的内存。<ul><li>具体定义会随之变化。比如从何处分配。</ul></ul><li><code class="language-plaintext highlighter-rouge">do_deallocate</code><ul><li>从自身内存中解分配某一特定位置，特定大小的区块。<ul><li>具体定义会随之变化。比如解分配到何处，是否真的解分配。</ul></ul><li><code class="language-plaintext highlighter-rouge">is_equal</code><ul><li>比较两个内存资源是否相等。也就是从当前这个内存资源分配的内存是否可以通过另一个内存资源解分配。</ul><li><code class="language-plaintext highlighter-rouge">release</code><ul><li>调用上游的deallocate来释放内存。将全部内存交还给上游内存分配器。</ul></ul><li><p><strong>内存资源是可以成为链条的。这一点我们下面讲。</strong></p><li><strong>注意内存资源类不是类模板！！！</strong></ul><h3 id="stdpmrnew_delete_resource"><span class="mr-2">std::pmr::new_delete_resource</span><a href="#stdpmrnew_delete_resource" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这是最基础的，也是默认的内存资源。它是从哪儿获取的原始内存呢？答案是从全局的<code class="language-plaintext highlighter-rouge">::operator new</code></p><blockquote><p>返回指向使用全局 <a href="https://zh.cppreference.com/w/cpp/memory/new/operator_new">operator new</a> 与 <a href="https://zh.cppreference.com/w/cpp/memory/new/operator_delete">operator delete</a> 分配内存的 <code class="language-plaintext highlighter-rouge">memory_resource</code> 的指针。</p></blockquote><ul><li><strong>allocate</strong><ul><li>因为这是默认的选项，所以非常自然地，内存的分配会使用<code class="language-plaintext highlighter-rouge">::operator new</code></ul><li><strong>deallocate</strong><ul><li>既然分配的都用默认的了，那么解分配也是会用到<code class="language-plaintext highlighter-rouge">::operator delete</code></ul></ul><p><strong>一般来说，上游分配器都是它。默认也是它。</strong></p><h3 id="stdpmrmonotonic_buffer_resource"><span class="mr-2">std::pmr::monotonic_buffer_resource</span><a href="#stdpmrmonotonic_buffer_resource" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>这是一个比较特殊的资源。它特殊就特殊在我们可以使用栈内存做为内存资源。如使用<code class="language-plaintext highlighter-rouge">char buffer[1024]</code>来获取一段栈内存做为原始内存。<strong>它是一种单调递增的资源。它仅在销毁资源时释放分配的内存。它的意图是提供非常快速的内存分配，在内存用于分配少量对象，并于之后一次释放的情况下。</strong><ul><li><strong>因为它的原理仅仅是推指针。所以分配速度非常快。属于一块线性内存。</strong></ul><li><strong>构造函数</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">monotonic_buffer_resource</span><span class="p">();</span> 											<span class="c1">//(1)</span>
<span class="k">explicit</span> <span class="nf">monotonic_buffer_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">);</span>	<span class="c1">//(2)</span>
<span class="k">explicit</span> <span class="nf">monotonic_buffer_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">initial_size</span><span class="p">);</span>				<span class="c1">//(3)</span>
<span class="n">monotonic_buffer_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">initial_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">);</span>			<span class="c1">//(4)</span>
<span class="n">monotonic_buffer_resource</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">);</span>			<span class="c1">//(5)</span>
<span class="n">monotonic_buffer_resource</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">);</span><span class="c1">//(6)</span>
<span class="n">monotonic_buffer_resource</span><span class="p">(</span><span class="k">const</span> <span class="n">monotonic_buffer_resource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>		<span class="c1">//(7)</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code> 能以初始缓冲区构造，若无初始缓冲，或缓冲用尽，则从构造时提供的<em>上游分配器</em>分配缓冲区。缓冲区的大小以几何级数增长。</p></blockquote><p>比较常用的有1,2,5,6</p><ul><li><p>第一个就是默认构造函数。默认构造函数会使用<code class="language-plaintext highlighter-rouge">std::pmr::get_default_resource</code>返回的<code class="language-plaintext highlighter-rouge">memory_resource </code>当做上游分配器。</p><li><p>第二个就是指定上游分配器。</p><li>第五个是提供一块给定内存<code class="language-plaintext highlighter-rouge">buffer</code>，然后设置当前资源为<code class="language-plaintext highlighter-rouge">buffer</code>。<code class="language-plaintext highlighter-rouge">buffer_size</code>是下一块缓冲区的大小，然后使用<code class="language-plaintext highlighter-rouge">std::pmr::get_default_resource</code>返回的<code class="language-plaintext highlighter-rouge">memory_resource </code>当做上游分配器。<ul><li>当给定的内存用尽后，使用上游分配器进行内存分配。</ul><li><p>第六个是提供一块给定内存<code class="language-plaintext highlighter-rouge">buffer</code>，然后设置当前资源为<code class="language-plaintext highlighter-rouge">buffer</code>。<code class="language-plaintext highlighter-rouge">buffer_size</code>是下一块缓冲区的大小，并且指定上游分配器。</p><ul><li>当给定的内存用尽后，使用上游分配器进行内存分配。</ul><li><p><strong>do_allocate</strong></p><ul><li><blockquote><p><strong>若当前缓冲区有足够的未使用空间以适合一个拥有指定大小和对齐的块，则从当前缓冲区分配返回的块。</strong></p><p><strong>否则，此函数通过调用 <code class="language-plaintext highlighter-rouge">upstream_resource()-&gt;allocate(n, m)</code> 分配新缓冲区</strong>，其中 <code class="language-plaintext highlighter-rouge">n</code> 不小于<code class="language-plaintext highlighter-rouge">bytes</code> 与<em>下个缓冲区大小</em>的较大者，且 <code class="language-plaintext highlighter-rouge">m</code> 不小于 <code class="language-plaintext highlighter-rouge">alignment</code> 。它设置新缓冲区为<em>当前缓冲区</em>，以实现定义的增长因子（不必是整数）增加<em>下个缓冲区大小</em>，然后从新分配的缓冲区分配返回块。</p></blockquote><li>插一句话，这个时候就是使用<code class="language-plaintext highlighter-rouge">std::pmr::null_memory_resource</code>的一个典型场景</ul><li><p><strong>do_deallocate</strong></p><ul><li><strong>此函数无效应。！！！啥也不干！！！因为我们都说了它是单调递增的！！！直到销毁资源为止（对象析构或调用release）</strong></ul><li><p><strong>release</strong></p><ul><li><blockquote><p><strong>通过上游 memory_resource 的 <code class="language-plaintext highlighter-rouge">deallocate</code> 函数，按需要释放所有分配的内存。</strong>重设<em>当前缓冲区</em>及<em>下个缓冲区大小</em>为其构造时的初始值。</p><p>内存被释放回上游资源，即使未对某些被分配块调用 <code class="language-plaintext highlighter-rouge">deallocate</code> 。</p></blockquote><li><p>释放内存。注意，这是调用<strong>上游</strong><code class="language-plaintext highlighter-rouge">deallocate</code>解分配。<strong>解分配不代表调用内存中储存对象的析构函数。仅仅是把指针塞回给上游内存池。</strong></p><ul><li>如果上游是<code class="language-plaintext highlighter-rouge">null_memory_resource</code>，那就相当于啥也没干。<strong>同时，一般来说使用这种方式分配内存的时候，初始缓冲区一般是在栈上。如果在堆上，记得要手动回收提供的初始内存。因为这些内存资源不会帮助我们回收初始内存资源。所谓的：重设当前缓冲区及下个缓冲区大小为其构造时的初始值 的含义仅仅是把指针推回去。</strong><li>内存被释放回上游资源，即使未对某些被分配块调用 <code class="language-plaintext highlighter-rouge">deallocate</code> 。这句话每一个内存资源的<code class="language-plaintext highlighter-rouge">release</code>都有。我们下面再说。</ul></ul><p>源代码，<a href="https://reviews.llvm.org/D47090">来自</a></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">monotonic_buffer_resource</span><span class="o">::</span><span class="n">release</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">header_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__monotonic_buffer_header</span><span class="p">);</span>
  
    <span class="n">__original_</span><span class="p">.</span><span class="n">__used_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">__original_</span><span class="p">.</span><span class="n">__next_</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__monotonic_buffer_header</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="n">__original_</span><span class="p">.</span><span class="n">__next_</span><span class="p">;</span>
        <span class="n">__monotonic_buffer_header</span> <span class="o">*</span><span class="n">next_header</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">__next_</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">aligned_capacity</span> <span class="o">=</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">__capacity_</span> <span class="o">+</span> <span class="n">header_size</span><span class="p">;</span>
        <span class="n">__res_</span><span class="o">-&gt;</span><span class="n">deallocate</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">__start_</span><span class="p">,</span> <span class="n">aligned_capacity</span><span class="p">,</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">__alignment_</span><span class="p">);</span> <span class="c1">//调用上游分配器的deallocate</span>
        <span class="n">__original_</span><span class="p">.</span><span class="n">__next_</span> <span class="o">=</span> <span class="n">next_header</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//除了那一行以外其他的就是回推指针。</span>
</pre></table></code></div></div><li><strong>析构函数</strong><ul><li>调用<code class="language-plaintext highlighter-rouge">this-&gt;release() </code>来解分配此资源拥有的所有内存。<ul><li>所以说针对这几种内存资源，压根没必要<code class="language-plaintext highlighter-rouge">release</code>。因为已经应用了RAII特性。</ul></ul></ul><p><strong>测试</strong></p><p>我们下面的测试是单纯的测试内存分配器。并没有结合容器。但是效果是一致的。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_val</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass constructed with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass destroyed with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">m_val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">m_val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">m_val</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">//从栈获取原始内存</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"original "</span><span class="o">&lt;&lt;&amp;</span><span class="n">buffer</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//原始内存地址</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer_resource</span><span class="p">{</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
        <span class="c1">//monotonic memory resource使用栈获取的资源做为初始资源，使用null_memory_resource当做上游分配器强调内存用尽后抛出bad_alloc而不是从默认分配器分配</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span> <span class="c1">//初始化分配器</span>
        <span class="p">{</span>
            <span class="n">MyClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//分配1个Myclass对象 8字节</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//获取指针地址</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1st alloc place "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//获取当前分配地址</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">//在该地址构造元素</span>

            <span class="n">MyClass</span><span class="o">*</span> <span class="n">tt</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//再分配1个Myclass对象 8字节</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//获取指针地址</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2nd alloc place  "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//获取当前分配地址</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c1">//在该地址构造元素</span>
<span class="c1">//------------如果不destroy会泄露。因为deallocate解分配并不会调用元素的析构函数---------</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//析构元素</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">tt</span><span class="p">);</span> <span class="c1">//析构元素</span>
<span class="c1">//----------使用release重置内存，把首地址推回分配起始地址（原始内存首地址）           </span>
            <span class="n">buffer_resource</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
            
            <span class="n">MyClass</span><span class="o">*</span> <span class="n">ttt</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//再次分配1个Myclass对象</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ttt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//获取指针地址 </span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"3rd alloc place  "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">ttt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//获取当前分配地址</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">ttt</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>  <span class="c1">//在该地址构造元素</span>
            <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">ttt</span><span class="p">);</span>  
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>original 0x7ffe4ff6eb90 起始地址
0x7ffe4ff6eb30
1st alloc place 0x7ffe4ff6eb90 起始地址和第一次分配地址一致
MyClass constructed with value: 20
0x7ffe4ff6eb38
2nd alloc place  0x7ffe4ff6eb98 第二次分配在第一次分配上+8
MyClass constructed with value: 30
MyClass destroyed with value: 20
MyClass destroyed with value: 30
0x7ffe4ff6eb40
3rd alloc place  0x7ffe4ff6eb90 release后指针推回至原生内存起始位置。
MyClass constructed with value: 40
MyClass destroyed with value: 40
</pre></table></code></div></div><ul><li>我们从上面的测试能看到<ul><li>如果不<code class="language-plaintext highlighter-rouge">destroy</code>会导致内存泄露。因为<code class="language-plaintext highlighter-rouge">deallocate</code>解分配并不会调用内存中元素的析构函数，仅仅是回推指针。<li>如果不需要重复使用内存，则无需手动调用<code class="language-plaintext highlighter-rouge">release</code>。RAII特性会让<code class="language-plaintext highlighter-rouge">buffer_resource</code>内存资源在析构时自动调用<code class="language-plaintext highlighter-rouge">release</code><li>注意：我们是使用<code class="language-plaintext highlighter-rouge">allocator</code>进行内存分配，对象构造和对象摧毁。</ul><li>假设我们的初始内存是从堆中获取的，则必须要手动释放。因为分配器和内存资源并不保有底层原始内存</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span> <span class="c1">//堆内存。</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer_resource</span><span class="p">{</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">buffer</span><span class="p">;</span> <span class="c1">//回收内存</span>
</pre></table></code></div></div><p>分析一下<code class="language-plaintext highlighter-rouge">release</code>过程。无论是析构还是手动调用<code class="language-plaintext highlighter-rouge">release</code>，都有两个步骤：第一步是调用上游的<code class="language-plaintext highlighter-rouge">memory_resource</code> 的 <code class="language-plaintext highlighter-rouge">deallocate</code> 函数。第二步是重设当前缓冲区及下个缓冲区大小为其构造时的初始值。当前我们上游是<code class="language-plaintext highlighter-rouge">null_memory_resource</code>，<code class="language-plaintext highlighter-rouge">deallocate</code>函数无效果。所以仅仅是把当前缓冲区及下个缓冲区大小为其构造时的初始值。（推回指针）</p><h3 id="stdpmrunsynchronized_pool_resource--stdpmrsynchronized_pool_resource"><span class="mr-2">std::pmr::unsynchronized_pool_resource / std::pmr::synchronized_pool_resource</span><a href="#stdpmrunsynchronized_pool_resource--stdpmrsynchronized_pool_resource" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>这是一种池化的内存资源：</strong></p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308173021.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230308173021.png" alt="QQ截图20230308173021" class="lazyload" data-proofer-ignore></a></p><p>具体应该不用赘述。侯捷老师的课讲标准分配器的时候就提到过大概的样子。</p><ul><li>这俩唯一的区别是一个线程安全，一个线程不安全。线程安全的性能贼差尽量别用。</ul><blockquote><ul><li><strong>它占有被分配内存并在析构时释放它，即使 <code class="language-plaintext highlighter-rouge">deallocate</code> 未被对于某些被分配块调用。</strong><ul><li>这个释放是指调用<code class="language-plaintext highlighter-rouge">release</code>。<code class="language-plaintext highlighter-rouge">release</code>中调用上游 memory_resource 的 <code class="language-plaintext highlighter-rouge">deallocate</code> 函数，释放所有此资源所占有的内存。</ul><li><strong>它由供应不同块大小请求的池的汇集组成。每个池管理之后被分入一致大小的大块的汇集。</strong><li><strong>对 <code class="language-plaintext highlighter-rouge">do_allocate</code>的调用被派发到供应适应请求大小的最小块的池。</strong><li><strong>在池中耗尽内存，会导致该池从上游分配器分配额外的内存大块，以填满池。获取的大块大小以几何级数增加。</strong><li>请求超出最大的块大小的分配，由上游分配器直接供应。<li>最大的块大小和大块大小的最大值可通过传递<code class="language-plaintext highlighter-rouge">std::pmr::pool_options</code>结构体给其构造函数调节。</ul></blockquote><ul><li><strong>构造函数</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">unsynchronized_pool_resource</span><span class="p">();</span> <span class="c1">//(1)</span>
<span class="k">explicit</span> <span class="nf">unsynchronized_pool_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">);</span> <span class="c1">//(2)</span>
<span class="k">explicit</span> <span class="nf">unsynchronized_pool_resource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">pool_options</span><span class="o">&amp;</span> <span class="n">opts</span><span class="p">);</span> <span class="c1">//(3)</span>
<span class="n">unsynchronized_pool_resource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">pool_options</span><span class="o">&amp;</span> <span class="n">opts</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">memory_resource</span><span class="o">*</span> <span class="n">upstream</span><span class="p">);</span> <span class="c1">//(4)</span>
<span class="n">unsynchronized_pool_resource</span><span class="p">(</span><span class="k">const</span> <span class="n">unsynchronized_pool_resource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">//(5)</span>
</pre></table></code></div></div><p><strong>有没有发现这一组构造函数和<code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code>有个非常明显的差别？也就是我们不再有像<code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code>第5和第6个构造函数那种提供初始原始内存的构造函数了。也就是说这两个池化内存资源必须从上游分配器获取资源。</strong></p><p>如果依旧想要从栈分配，则可以先使用栈分配<code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code>，然后让它成为当前池化内存的上游分配器。</p><p>第一个构造函数就是使用默认的池化选项和默认的上游分配器。</p><p>第二，三，四个分别指定上游分配器，池化选项和二者皆指定。</p><ul><li><p><strong>do_allocate</strong></p><ul><li><blockquote><p>若为 <code class="language-plaintext highlighter-rouge">bytes</code> 大小的块所选的池不足以满足来自其内部数据结构的请求，则调用上游 memory_resources 上的 <code class="language-plaintext highlighter-rouge">allocate()</code> 以获得内存。</p><p><strong>若请求的大小大于最大的池所能处理者，则通过调用上游 memory_resources 上的 <code class="language-plaintext highlighter-rouge">allocate()</code> 分配内存。</strong></p></blockquote></ul><li><p><strong>do_deallocate</strong></p><ul><li><blockquote><p>将在 <code class="language-plaintext highlighter-rouge">p</code> 的内存返还到池。<strong>此操作是否或在何种场合下导致对上游 memory_resource 上的 <code class="language-plaintext highlighter-rouge">deallocate()</code> 调用是未指定的。</strong></p></blockquote><li>在对池化资源使用<code class="language-plaintext highlighter-rouge">do_deallocate</code>的时候一定要仅返回内存至内存池，而不是调用上游分配器的<code class="language-plaintext highlighter-rouge">deallocate</code>直接回收。一定要格外注意。但是这一点平时普通人不需要过多操心</ul><li><p><strong>release</strong></p><ul><li><blockquote><p>需要时，通过调用上游 memory_resource 的 <code class="language-plaintext highlighter-rouge">deallocate</code> 函数，释放所有此资源所占有的内存。</p><p>即使未对某些被分配块调用 <code class="language-plaintext highlighter-rouge">deallocate</code> ，资源也被返还给上游 memory_resource 。</p></blockquote><li>这就是<code class="language-plaintext highlighter-rouge">release</code>和<code class="language-plaintext highlighter-rouge">deallocate</code>的最大区别。<code class="language-plaintext highlighter-rouge">deallocate</code>是返还内存到内存池。而<code class="language-plaintext highlighter-rouge">release</code>是释放（返还）整个内存池全部的内存至上游分配器。因为是调用上游分配器的<code class="language-plaintext highlighter-rouge">deallocate</code>。<li><strong>不知道这玩意是只释放内存还是摧毁整个池。标准库没说</strong></ul><li><p><strong>析构函数</strong></p><ul><li><p>通过调用 <code class="language-plaintext highlighter-rouge">this-&gt;release()</code> 释放此资源所拥有的所有内存。</p><ul><li>和其他的一样。</ul></ul></ul><h3 id="我们捋一下针对池化内存release的可能情况"><span class="mr-2">我们捋一下针对池化内存release的可能情况</span><a href="#我们捋一下针对池化内存release的可能情况" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>第一种情况：<ul><li>如果<code class="language-plaintext highlighter-rouge">sync</code>或<code class="language-plaintext highlighter-rouge">unsync</code>的上游分配器是<code class="language-plaintext highlighter-rouge">monotonic</code>，<code class="language-plaintext highlighter-rouge">sync</code>或<code class="language-plaintext highlighter-rouge">unsync</code>调用<code class="language-plaintext highlighter-rouge">release</code>会使上游的<code class="language-plaintext highlighter-rouge">monotonic</code>调用<code class="language-plaintext highlighter-rouge">deallocate</code>。但是<code class="language-plaintext highlighter-rouge">monotonic</code>的<code class="language-plaintext highlighter-rouge">deallocate</code>不做任何事情。所以分配出去的内存无法被<code class="language-plaintext highlighter-rouge">monotonic</code>回收。只能单调递增直到<code class="language-plaintext highlighter-rouge">monotonic</code>的<code class="language-plaintext highlighter-rouge">release</code>被调用</ul><li>第二种情况：<ul><li>如果<code class="language-plaintext highlighter-rouge">sync</code>或<code class="language-plaintext highlighter-rouge">unsync</code>的上游是<code class="language-plaintext highlighter-rouge">new_delete_resource</code>，则<code class="language-plaintext highlighter-rouge">sync/unsync</code>调用<code class="language-plaintext highlighter-rouge">release</code>会使得上游的<code class="language-plaintext highlighter-rouge">new_delete_resource</code>调用其<code class="language-plaintext highlighter-rouge">deallocate</code>，我们说过它的<code class="language-plaintext highlighter-rouge">deallocate</code>是全局<code class="language-plaintext highlighter-rouge">::operator delete</code>。</ul></ul><h3 id="在已经release的内存资源上再次调用allocate是否是ub"><span class="mr-2">在已经release的内存资源上再次调用allocate是否是UB？</span><a href="#在已经release的内存资源上再次调用allocate是否是ub" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>标准库没有明确说明。例子如下：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer_resource</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">new_delete_resource</span><span class="p">()};</span> <span class="c1">//最外层monotonic通过new_delete获取原始内存。</span>
<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">unsynchronized_pool_resource</span> <span class="n">midlevel</span><span class="p">{</span><span class="o">&amp;</span><span class="n">buffer_resource</span><span class="p">};</span> <span class="c1">//第一层unsync池化</span>
<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">unsynchronized_pool_resource</span> <span class="n">un_sync</span><span class="p">{</span><span class="o">&amp;</span><span class="n">midlevel</span><span class="p">};</span> <span class="c1">//第二层unsync 池化</span>
<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span><span class="o">&amp;</span><span class="n">un_sync</span><span class="p">};</span>
<span class="p">{</span>
    <span class="n">MyClass</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"1st alloc place "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">MyClass</span><span class="o">*</span> <span class="n">tt</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2nd alloc place  "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">tt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

    <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">tt</span><span class="p">);</span>

    <span class="n">un_sync</span><span class="p">.</span><span class="n">release</span><span class="p">();</span> <span class="c1">//release内存资源。此行为会导致第一层unsync调用deallocate。回收已分配的内存到第一层unsync的内存池</span>

    <span class="n">MyClass</span><span class="o">*</span> <span class="n">ttt</span> <span class="o">=</span> <span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//第二层unsync再次allocate</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ttt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"3rd alloc place  "</span><span class="o">&lt;&lt;&amp;*</span><span class="n">ttt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">construct</span><span class="p">(</span><span class="n">ttt</span><span class="p">,</span> <span class="mi">40</span><span class="p">);</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">destroy</span><span class="p">(</span><span class="n">ttt</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>0x7ffe69b80ed8
1st alloc place 0x559e13abbc00 //第一次分配
MyClass constructed with value: 20
0x7ffe69b80ee0
2nd alloc place  0x559e13abbc08 //第二次分配
MyClass constructed with value: 30
MyClass destroyed with value: 20
MyClass destroyed with value: 30
释放
0x7ffe69b80ee8
3rd alloc place  0x559e13abbc00 //第三次分配。地址同第一次。
MyClass constructed with value: 40
MyClass destroyed with value: 40
</pre></table></code></div></div><p><strong>经过我的测试，似乎是会重建内存池。</strong></p><p>已提问，目前无人<a href="https://stackoverflow.com/questions/75680593/call-allocate-again-on-the-released-unsynchronized-pool-resource-is-an-undefin">回答</a></p><h3 id="stdpmrnull_memory_resource"><span class="mr-2">std::pmr::null_memory_resource</span><a href="#stdpmrnull_memory_resource" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>很多人很奇怪？为啥要弄个空的呢？答案很简单。我们提到了，内存资源可以成为链条。如果某一个分配资源不够了，我们不希望它去默认的上游分配器去获取内存，就可以把这个分配器做为那个分配器的上游分配器。</p><li><p>allocate</p><ul><li><blockquote><ul><li>其 <code class="language-plaintext highlighter-rouge">allocate()</code> 函数始终抛出 std::bad_alloc；</ul></blockquote></ul><li><p>deallocate</p><ul><li>其 <code class="language-plaintext highlighter-rouge">deallocate()</code> 函数无效果；</ul></ul><h2 id="分配器-allocator"><span class="mr-2">分配器 allocator</span><a href="#分配器-allocator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们提到过。分配器是一种对内存资源的包装</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309000840.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309000840.png" alt="QQ截图20230309000840" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004214.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309004214.png" alt="QQ截图20230309004214" class="lazyload" data-proofer-ignore></a></p><ul><li><p>第二个转换构造函数非常有用。它的作用是我们可以直接把<code class="language-plaintext highlighter-rouge">memory_resource</code>传入任何需要<code class="language-plaintext highlighter-rouge">polymorphic_allocator</code>的地方。比如直接传入<code class="language-plaintext highlighter-rouge">pmr::</code>容器。</p><li><p><strong>构造函数</strong></p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">polymorphic_allocator</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">//(1)</span>
<span class="n">polymorphic_allocator</span><span class="p">(</span> <span class="k">const</span> <span class="n">polymorphic_allocator</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">//(2)</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">U</span> <span class="p">&gt;</span> 
<span class="n">polymorphic_allocator</span><span class="p">(</span> <span class="k">const</span> <span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">//(3) 关键的构造函数模板。</span>
<span class="n">polymorphic_allocator</span><span class="p">(</span> <span class="n">memory_resource</span><span class="o">*</span> <span class="n">r</span><span class="p">);</span> <span class="c1">//(4) 转换构造</span>
</pre></table></code></div></div><p>第一个：默认构造函数会默认构造一个以默认值（通常为<code class="language-plaintext highlighter-rouge">new_delete_resource</code>）为内存资源的分配器</p><p>第二个：拷贝构造</p><p><strong>第三个：构造函数模板。下面的模板参数以及正确转换全都靠它</strong></p><p>第四个：是上文提到的转换构造。</p><ul><li><p><strong>allocate</strong></p><ul><li><blockquote><p>用底层的 memory_resource 分配 <code class="language-plaintext highlighter-rouge">n</code> 个 <code class="language-plaintext highlighter-rouge">T</code> 类型对象的存储。</p><p>等价于 <code class="language-plaintext highlighter-rouge">return static_cast&lt;T*&gt;(resource()-&gt;allocate(n * sizeof(T), alignof(T)));</code> 。</p></blockquote><li><p>由于我们提过，分配器是一种内存资源的wrapper。所以分配器调用的<code class="language-plaintext highlighter-rouge">allocate</code>就相当于对内存资源调用<code class="language-plaintext highlighter-rouge">allocate</code>。</p><li>格外要注意的是，内存资源返回的内存是<code class="language-plaintext highlighter-rouge">void*</code>。而分配器返回的内存是对应类型的。</ul><li><p><strong>deallocate</strong></p><ul><li><blockquote><p>解分配 <code class="language-plaintext highlighter-rouge">p</code> 所指向的存储，它必须通过与 <code class="language-plaintext highlighter-rouge">*resource()</code> 比较等于的（相等的）<code class="language-plaintext highlighter-rouge">std::pmr::memory_resource</code> <code class="language-plaintext highlighter-rouge">x</code> 使用 <code class="language-plaintext highlighter-rouge">x.allocate(n * sizeof(T), alignof(T))</code> 分配。</p><p>等价于 <code class="language-plaintext highlighter-rouge">this-&gt;resource()-&gt;deallocate(p, n * sizeof(T), alignof(T));</code></p></blockquote><li>还是调用了底层内存资源的<code class="language-plaintext highlighter-rouge">deallocate</code></ul><li><p><strong>construct</strong></p><ul><li><p>这玩意有一堆重载。主要是看第一个：</p><ul><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">class</span> <span class="nc">U</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span> <span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">construct</span><span class="p">(</span> <span class="n">U</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">);</span> <span class="c1">//(1)</span>
</pre></table></code></div></div><li><blockquote><p>在 <code class="language-plaintext highlighter-rouge">p</code> 所指的，分配但未初始化的存储上，以提供的构造函数参数构造一个对象。<strong>若对象自身拥有使用分配器的类型，或它是 <code class="language-plaintext highlighter-rouge">std::pair</code> ，则传递 <code class="language-plaintext highlighter-rouge">this-&gt;resource()</code> 给被构造的对象。</strong></p></blockquote><li><blockquote><p>以<a href="https://zh.cppreference.com/w/cpp/memory/uses_allocator#.E4.BD.BF.E7.94.A8.E5.88.86.E9.85.8D.E5.99.A8.E6.9E.84.E9.80.A0">使用分配器构造</a>的手段在 <code class="language-plaintext highlighter-rouge">p</code> 所指示的未初始化内存位置，以 <code class="language-plaintext highlighter-rouge">*this</code> 为分配器创建给定类型 <code class="language-plaintext highlighter-rouge">U</code> 的对象。</p></blockquote></ul><li><p>说白了就如果提供了分配器，就使用提供的分配器构造。</p></ul><li><p><strong>destroy</strong></p><ul><li><blockquote><p>销毁 <code class="language-plaintext highlighter-rouge">p</code> 所指向的对象，如同以调用 <code class="language-plaintext highlighter-rouge">p-&gt;~U()</code></p></blockquote><li>所以我们强调了，<code class="language-plaintext highlighter-rouge">dellocate</code>解分配不调用内存位置上元素的析构函数。摧毁元素和回收内存是两个独立动作。</ul></ul><h2 id="polymorphic_allocator-的模板参数"><span class="mr-2">polymorphic_allocator 的模板参数</span><a href="#polymorphic_allocator-的模板参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>有一些讲座说我们应该始终以<code class="language-plaintext highlighter-rouge">std::byte</code>为<code class="language-plaintext highlighter-rouge">polymorphic_allocator </code>的模板参数。但是直觉来说，应该以元素类型为模板参数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_val</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass constructed with value: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass destroyed with value: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">m_val</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">m_val</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">m_val</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer_resource</span><span class="p">{</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
        <span class="c1">//monotonic内存资源从已分配栈内存做为初始资源。并使用null做为上游资源</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span> <span class="c1">//版本1，分配器参数为元素类型：MyClass</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span> <span class="c1">//版本2，分配器参数为byte。</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span> <span class="c1">//使用分配器初始化pmr vector</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//预留一个空间</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//原地构造一个对象</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">MyClass</span> <span class="n">constructed</span> <span class="n">with</span> <span class="n">value</span><span class="o">:</span> <span class="mi">1</span>
<span class="n">MyClass</span> <span class="n">destroyed</span> <span class="n">with</span> <span class="n">value</span><span class="o">:</span> <span class="mi">1</span>
</pre></table></code></div></div><ul><li>注意关于monotonic内存资源和winkout的联系会在下一节讲。但是这里必须要提到一点，winkout和使用何种内存资源之间无任何联系。</ul><p>两种分配器参数都可以正常工作。那么是什么原因呢？我们看一下这一行代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span> <span class="c1">//此行展开</span>
</pre></table></code></div></div><p>这一行代码展开后的样子是这样的：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span>
</pre></table></code></div></div><p>首先记住一点：<code class="language-plaintext highlighter-rouge">allocator</code>的模板参数一定会被推导为元素类型。因为别忘了上面提到的<code class="language-plaintext highlighter-rouge">pmr</code>是别名模板，元素类型是<code class="language-plaintext highlighter-rouge">T</code>，<code class="language-plaintext highlighter-rouge">allocator</code>的类型是根据<code class="language-plaintext highlighter-rouge">T</code>来的。</p><p>其次，我们发现如果分配器类型和元素类型一致，则顺利构造。左右两侧无区别。</p><p>但是如果我们换成<code class="language-plaintext highlighter-rouge">byte</code>呢？</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">byte</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span> <span class="c1">//此行展开</span>
</pre></table></code></div></div><p>这一行展开后是这样的：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">allocator</span><span class="p">));</span>
</pre></table></code></div></div><p>再次重申，<code class="language-plaintext highlighter-rouge">allocator</code>的模板参数一定会被推导为元素类型。同时，右侧括号内传入的分配器发生了隐式类型转换。调用的正是我们在分配器中提到的第三个构造函数。</p><p><strong>所以理论上讲，此时行为都是一致的。而分配器本身的构造并不会造成性能的过多损失。但是有一点要注意，隐式类型转换后，传入的分配器是那个转换后的临时对象。所以现在<code class="language-plaintext highlighter-rouge">vector</code>内部的分配器和外面传入的<code class="language-plaintext highlighter-rouge">allocator</code>其实是两个独立对象了。一定要注意。最好还是使用和元素一样类型的分配器。</strong></p><p>我的<a href="https://stackoverflow.com/questions/75669627/what-is-the-usage-of-the-template-parameter-of-the-stdpmrpolymorphic-allocat">提问</a></p><h2 id="分配器种类分配器绑定方式和析构的组合"><span class="mr-2">分配器种类，分配器绑定方式和析构的组合</span><a href="#分配器种类分配器绑定方式和析构的组合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>目前为止，分配器绑定方式可以分为两种</strong></p><ul><li>类型参数（模板参数）<li>继承自抽象基类，比如：<ul><li><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225735.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225735.png" alt="QQ截图20230309225735" class="lazyload" data-proofer-ignore></a></p><li><p>注意这里不是继承自<code class="language-plaintext highlighter-rouge">std::allocator</code>。一般也不应该这样做。原因见<a href="https://stackoverflow.com/questions/21081796/why-not-to-inherit-from-stdallocator">这里</a></p><li><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310032548.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310032548.png" alt="QQ截图20230310032548" class="lazyload" data-proofer-ignore></a></p></ul></ul><p><strong>目前为止，分配器内存来源可以分为这么几种</strong></p><ul><li>默认全局分配器（std::allocator)<ul><li>绑定方式一定是类型参数</ul><li>New_Delete_Allocator<ul><li>和默认全局分配器原理一致，但是绑定方式一定是继承自抽象基类</ul><li>多态内存资源<ul><li>如<code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code>，<code class="language-plaintext highlighter-rouge">unsync/synchronized_pool_resource</code>等</ul></ul><p><strong>析构方式又可以分为两种：</strong></p><ul><li>常规析构<li>wink-out</ul><p>所以，一共我们可以得到这么多种搭配组合</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225948.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309225948.png" alt="QQ截图20230309225948" class="lazyload" data-proofer-ignore></a></p><h2 id="wink-out-和-常规析构"><span class="mr-2">wink-out 和 常规析构</span><a href="#wink-out-和-常规析构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先注意，wink-out适用于任何内存资源。<strong>我们还记得容器分配构造的四个步骤：分配空间，构造对象，析构对象，解分配空间。</strong></p><p>wink-out就是不析构，直接解分配。所以使用wink-out的时候一定要注意，如果内存区域的元素是含有额外资源的，则不可以winkout。会导致内存泄漏。</p><ul><li><strong>我们看一下常规析构：</strong></ul><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309234908.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230309234908.png" alt="QQ截图20230309234908" class="lazyload" data-proofer-ignore></a></p><p>一切都很正常。标准的四个步骤。</p><ul><li><strong>我们再来看一下所谓的winked-out</strong></ul><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310023351.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230310023351.png" alt="QQ截图20230310023351" class="lazyload" data-proofer-ignore></a></p><p>核心意思就是我们不再需要析构和解分配两个步骤</p><p>不需要析构非常好理解，因为如果某些对象没有保有其他资源，也就是析构函数是trivial的时候，调用析构是没有意义的。所以可以不调用这些析构。</p><p>不需要<code class="language-plaintext highlighter-rouge">deallocate</code>如何理解呢？一般情况下，通常只针对<code class="language-plaintext highlighter-rouge">monotonic_buffer_resource</code>使用winkout。因为它的<code class="language-plaintext highlighter-rouge">deallocate</code>是无作用。只有在析构的时候才会把资源交还给上游分配器。当然了，标准库提供的所有内存资源都符合RAII特性，在析构的时候都会把内存交还给上游分配器。所以这里不使用<code class="language-plaintext highlighter-rouge">deallocate</code>也是可以的。<strong>一定要记住，所有解分配<code class="language-plaintext highlighter-rouge">deallocate</code>都不会调用元素的析构函数</strong>。所以要注意内存泄漏问题，使用这个技巧之前一定要清楚自己在做什么。</p><p>我们来看个特殊例子，因为有时候容易错误理解：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="p">{</span>

        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">buffer_resource</span><span class="p">{</span><span class="n">buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">null_memory_resource</span><span class="p">()};</span>
        <span class="c1">//外层monotonic原始内存</span>
        <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">allocator</span><span class="p">{</span> <span class="o">&amp;</span><span class="n">buffer_resource</span> <span class="p">};</span> <span class="c1">//分配器</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span><span class="n">allocator</span><span class="p">);</span> <span class="c1">//分配器传入pmr vector</span>
            <span class="n">t</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//预留1个位置</span>
            <span class="n">t</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//原地构造元素</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">MyClass</span> <span class="n">constructed</span> <span class="n">with</span> <span class="n">value</span><span class="o">:</span> <span class="mi">20</span>
<span class="n">MyClass</span> <span class="n">destroyed</span> <span class="n">with</span> <span class="n">value</span><span class="o">:</span> <span class="mi">20</span>
</pre></table></code></div></div><p>奇怪？明明我们没有手动对内存资源进行操作，怎么会正确析构呢？因为这是<code class="language-plaintext highlighter-rouge">pmr::vector</code>帮助我们做的。因为它毕竟还是<code class="language-plaintext highlighter-rouge">vector</code>。还是会在<code class="language-plaintext highlighter-rouge">vector</code>被销毁的时候帮助我们对元素进行析构。</p><blockquote><p><code class="language-plaintext highlighter-rouge">std::vector&lt;T,Allocator&gt;::~vector</code>：调用元素的析构函数，然后解分配所用的存储。</p></blockquote><h2 id="自定义分配器的相等比较"><span class="mr-2">自定义分配器的相等比较</span><a href="#自定义分配器的相等比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>参考<a href="https://stackoverflow.com/questions/47186641/why-c-custom-allocator-needs-comparison-operators">来自这里</a></p><blockquote><p>[<code class="language-plaintext highlighter-rouge">operator ==(a1, a2)</code>] returns true only if the storage allocated by the allocator <code class="language-plaintext highlighter-rouge">a1</code> can be deallocated through <code class="language-plaintext highlighter-rouge">a2</code>. Establishes reflexive, symmetric, and transitive relationship. Does not throw exceptions. <code class="language-plaintext highlighter-rouge">operator ==(a1, a2)</code>仅当分配器 <code class="language-plaintext highlighter-rouge">a1</code> 分配的存储可以通过分配器 <code class="language-plaintext highlighter-rouge">a2</code> 释放时才返回 true。建立了自反、对称和传递关系。不抛出异常。</p></blockquote><p>一般来说，如果两个分配器相等，那么在移动一个容器至另一个容器的时候可以直接交换指针，在第二个容器重用第一个容器的内存。如果分配器不相等，则必须要在第二个容器中重新分配内存，然后复制每一个元素，然后释放第一个容器。</p><p><strong>针对如何实现内存资源，和如何实现使用多态内存分配器的容器，可以看看下面参考资料的内容</strong></p><h2 id="参考资料"><span class="mr-2">参考资料</span><a href="#参考资料" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://youtu.be/v3dz-AKOVL8">CppCon 2017针对如何实现内存资源和自己的使用分配器的容器</a></p><p><a href="https://youtu.be/RLezJuqNcEQ">CppCon 2019针对如何实现带有多态内存分配器的类和容器类</a></p><p><a href="https://youtu.be/nZNd5FjSquk">CppCon 2017理解并测试分配器</a></p><p><a href="https://zhuanlan.zhihu.com/p/96089089">游戏引擎新感觉</a></p><p><a href="https://blog.csdn.net/audi2/article/details/118252089">CSDN的pmr</a></p><p><a href="https://blog.feabhas.com/2019/03/thanks-for-the-memory-allocator/">分配器，内存资源，容器的关联</a></p><p><a href="https://stackoverflow.com/questions/75669627/what-is-the-usage-of-the-template-parameter-of-the-stdpmrpolymorphic-allocat">polymorphic allocator的模板参数</a></p><p><a href="https://stackoverflow.com/questions/74012811/what-is-the-difference-between-magically-winked-out-and-monotonic">如何测试wink-out</a></p><p><a href="https://reviews.llvm.org/D47090">memory_source的LLVM源代码</a> 和 <a href="https://fossies.org/linux/gcc/libstdc++-v3/src/c++17/memory_resource.cc">LLVM最终源代码</a></p><h1 id="反射">反射</h1><p>反射的核心目的是根据一个类名来生成对应的实例。也就是<strong>如何通过类名称字符串来生成类的对象。比如有一个类<code class="language-plaintext highlighter-rouge">ClassA</code>，那么如何通过类名称字符串<code class="language-plaintext highlighter-rouge">ClassA</code>创建类的对象呢？</strong>比如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
<span class="nl">public:</span>
   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Allen</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, I'm Allen!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">className</span> <span class="o">=</span> <span class="cm">/*从配置文件中读取*/</span>
<span class="n">Person</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">getNewInstance</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="n">className</span><span class="p">);</span>
</pre></table></code></div></div><p>但是C++不像java或者C#一样提供这种机制。但是我们可以通过工厂模式+单例模式+映射器+宏来实现一个反射</p><p>一般来说，实现反射需要如下几个组件（步骤）：</p><ul><li>我们的业务代码，也就是需要被反射的类。这个类通常继承自一个反射基类如<code class="language-plaintext highlighter-rouge">ReflectObject</code>。<ul><li>这个步骤的目的是为抽象对象工厂类<code class="language-plaintext highlighter-rouge">ObjectFactory</code>提供统一的接口</ul><li>一个抽象对象工厂类<code class="language-plaintext highlighter-rouge">ObjectFactory</code><li>具体对象工厂类<ul><li>一般情况下使用宏</ul><li>反射器<ul><li>通常情况下，反射器可以是单例。<li>反射器的核心是建立字符串（标识符）到回调函数的映射。然后通过一个容器储存。<li>在我们即将展示的例子中，这个回调函数是一个具体对象工厂的指针。然后我们会通过这个具体对象工厂来创建具体对象。</ul></ul><p><strong>下面我们看代码</strong></p><ul><li>反射基类<code class="language-plaintext highlighter-rouge">ReflectObject</code>。所有实现反射的类都需要继承自它。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ReflectObject</span> <span class="p">{</span> 
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">ReflectObject</span><span class="p">(){}</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>具体的被反射类</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ReflectObject</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Person</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Person()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Person</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Person()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">show</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, I'm person"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Miku</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Miku</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Miku()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Miku</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Miku()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">show</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, I'm Miku"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Animal</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ReflectObject</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Animal</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Animal()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">bark</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"animal bark"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

</pre></table></code></div></div><ul><li>抽象对象工厂<code class="language-plaintext highlighter-rouge">ObjectFactory</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ObjectFactory</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ObjectFactory</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ObjectFactory()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">ObjectFactory</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~ObjectFactory()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">virtual</span> <span class="n">ReflectObject</span><span class="o">*</span> <span class="n">newInstance</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//提供统一的纯虚函数，返回反射基类的指针。也就是说，所有的具体对象工厂类都要通过这个函数返回具体对象并被转化为反射基类的指针</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>反射器Reflector<ul><li>此处我们以单例模式呈现。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Reflector</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">Reflector</span><span class="o">&amp;</span> <span class="n">reflector</span><span class="p">();</span> <span class="c1">//mayer’s单例模式经典方法</span>
    <span class="n">Reflector</span><span class="p">(</span><span class="k">const</span> <span class="n">Reflector</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">//禁止拷贝构造</span>
    <span class="n">Reflector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">Reflector</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">//禁止拷贝赋值</span>
	<span class="kt">void</span> <span class="n">registerFactory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">,</span> <span class="n">ObjectFactory</span><span class="o">*</span> <span class="n">function</span><span class="p">);</span> <span class="c1">//注册至映射map</span>

	<span class="n">ReflectObject</span><span class="o">*</span> <span class="n">getNewInstance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">);</span> <span class="c1">//在映射器内查找类名对应的对象工厂指针。然后通过该指针调用该对象工厂对应的创建实例的函数。此处是newInstance</span>
<span class="nl">private:</span>
    <span class="n">Reflector</span><span class="p">();</span> <span class="c1">//私有构造</span>
	<span class="o">~</span><span class="n">Reflector</span><span class="p">();</span> <span class="c1">//私有析构</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">ObjectFactory</span><span class="o">*&gt;</span> <span class="n">objectFactories</span><span class="p">;</span> <span class="c1">//映射map。key是类名，value是该类的对象工厂指针。</span>
<span class="p">};</span>
<span class="n">Reflector</span><span class="o">::</span><span class="n">Reflector</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Reflector constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Reflector</span><span class="o">::~</span><span class="n">Reflector</span><span class="p">(){</span>
    <span class="c1">//析构函数中释放资源。在当前业务中，反射器的映射map负责保有所有的具体对象工厂指针。所以需要负责释放。</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">ObjectFactory</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">){</span>
		<span class="k">delete</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">objectFactories</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Reflector</span><span class="o">::</span><span class="n">registerFactory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">,</span> <span class="n">ObjectFactory</span> <span class="o">*</span><span class="n">of</span><span class="p">){</span>
    <span class="c1">//注册函数。首先在map中查找是否有对应的键值，如果没有则创建一个 名称-对象工厂指针 的映射</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">ObjectFactory</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">className</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"该类已经存在"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">objectFactories</span><span class="p">[</span><span class="n">className</span><span class="p">]</span> <span class="o">=</span> <span class="n">of</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">ReflectObject</span><span class="o">*</span> <span class="n">Reflector</span><span class="o">::</span><span class="n">getNewInstance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">){</span>
    <span class="c1">//通过类名获取对象工厂的指针，然后调用对象工厂的创建具体实例的方法并返回。</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">ObjectFactory</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">className</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">objectFactories</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">ObjectFactory</span> <span class="o">*</span><span class="n">of</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> 
		<span class="k">return</span> <span class="n">of</span><span class="o">-&gt;</span><span class="n">newInstance</span><span class="p">();</span> <span class="c1">//如果找到了。那么调用这个对象工厂指针的创建具体实例的方法。</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Reflector</span><span class="o">&amp;</span> <span class="n">Reflector</span><span class="o">::</span><span class="n">reflector</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//经典的mayer‘s单例模式</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"get reflector reference "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">Reflector</span> <span class="n">reflector</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">reflector</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
这是个非常特殊的地方。我们有一个全局函数模板。外部调用的是这个函数。
这个函数是我们的反射器的包装。传入一个具体被映射类名字，同时将其做为模板参数。
该函数内部会先获取单例的反射器的实例，然后通过该实例调用内部的getNewInstance成员函数。
由于调用返回的是ReflectObject*指针，但是通常我们等号左侧调用的时候会是当前类型或者是实际父类，所以需要强转一下。
*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">*</span> <span class="nf">getNewInstance</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">className</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Reflector</span><span class="o">::</span><span class="n">reflector</span><span class="p">().</span><span class="n">getNewInstance</span><span class="p">(</span><span class="n">className</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>具体对象工厂</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ObjectFactory_Miku</span><span class="o">:</span> <span class="k">public</span> <span class="n">ObjectFactory</span><span class="p">{</span> <span class="c1">//继承自反射基类</span>
    <span class="nl">public:</span>
    	<span class="n">ObjectFactory_Miku</span><span class="p">(){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"ObjectFactory_Miku() "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ReflectObject</span><span class="o">*</span> <span class="nf">newInstance</span><span class="p">(){</span> <span class="c1">//实现创建实例的接口。</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Miku</span><span class="p">();</span>
        <span class="p">};</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>主函数</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Reflector</span><span class="o">::</span><span class="n">reflector</span><span class="p">().</span><span class="n">registerFactory</span><span class="p">(</span><span class="s">"Miku"</span><span class="p">,</span> <span class="k">new</span> <span class="n">ObjectFactory_Miku</span><span class="p">());</span>
	<span class="n">Person</span> <span class="o">*</span><span class="n">allen</span> <span class="o">=</span> <span class="n">getNewInstance</span><span class="o">&lt;</span><span class="n">Miku</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Miku"</span><span class="p">);</span>
	<span class="n">allen</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">allen</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
get reflector reference  获取反射器实例
Reflector constructor 反射器创建且只创建一次
ObjectFactory() new的对象工厂类的父类部分
ObjectFactory_Miku() new的对象工厂类子类部分
---以上是第一行的注册部分------
get reflector reference  第二行的getnewinstance内部调用的获取反射器实例。
Person() 反射器实例调用的getnewinstance找到的对象工厂指针调用的newInstance导致的Miku类的父类部分创建
Miku() //miku类本类创建
Hello, I'm Miku //show 业务代码
~Miku()
~Person()
~ObjectFactory()
*/</span>
</pre></table></code></div></div><p>这时候我们发现，写对象工厂类和注册比较麻烦，我们可以用一个宏来实现</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cp">#define REFLECT(name)\
class ObjectFactory_##name : public ObjectFactory{\
public:\
	ObjectFactory_##name(){ std::cout &lt;&lt; "ObjectFactory_" &lt;&lt; #name &lt;&lt; "()" &lt;&lt; std::endl; }\
	virtual ~ObjectFactory_##name(){ std::cout &lt;&lt; "~ObjectFactory_" &lt;&lt; #name &lt;&lt; "()" &lt;&lt; std::endl; }\
	ReflectObject* newInstance() {\
		return new name(); \
	}\
}; \
Reflector::reflector().registerFactory(#name, new ObjectFactory_##name());
</span></pre></table></code></div></div><p>宏的部分语法我们在杂记4中提到过，这里不赘述</p><p>这样我们可以直接<code class="language-plaintext highlighter-rouge">REFLECT(Animal)</code>就完成了创建对象工厂和注册</p><p>也可以考虑使用一个额外的类和全局对象的方式替换最后一行</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Register_</span><span class="err">##</span><span class="n">name</span><span class="p">{</span>\
<span class="k">public</span><span class="o">:</span>\
	<span class="n">Register_</span><span class="err">##</span><span class="n">name</span><span class="p">(){</span>\
		<span class="n">Reflector</span><span class="o">::</span><span class="n">reflector</span><span class="p">().</span><span class="n">registerFactory</span><span class="p">(</span><span class="err">#</span><span class="n">name</span><span class="p">,</span> <span class="k">new</span> <span class="n">ObjectFactory_</span><span class="err">##</span><span class="n">name</span><span class="p">());</span> \
	<span class="p">}</span>\
<span class="p">};</span>\
<span class="n">Register_</span><span class="err">##</span><span class="n">name</span> <span class="n">register_</span><span class="err">##</span><span class="n">name</span><span class="p">;</span>
</pre></table></code></div></div><p>我目前不清楚有什么好处，可能和链接有关？因为全局对象的构造函数在<code class="language-plaintext highlighter-rouge">main</code>前执行。</p><p>上面的代码我们梳理了最基本的反射原理和实现，参考自<a href="https://blog.csdn.net/q1007729991/article/details/56012253">这里</a>。现在有一个问题。如果我的类需要使用有参构造函数怎么办？可以使用可变模板参数。但是导致复杂非常多。我找到了Nebula的一种实现方式，参考自<a href="https://zhuanlan.zhihu.com/p/40134288">这里</a>，我们一起分析一下。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cxxabi.h&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">neb</span><span class="p">{</span>
    <span class="k">class</span> <span class="nc">Actor</span><span class="p">{</span> <span class="c1">//*理解为反射基类 reflectobject</span>
    <span class="nl">public:</span>
        <span class="n">Actor</span><span class="p">(){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Actor construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Actor</span><span class="p">(){};</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Say</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Actor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">ActorFactory</span><span class="p">{</span>  <span class="c1">//*理解为反射器类。此处是单例模式</span>
    <span class="nl">public:</span>
        <span class="c1">//typedef Actor* (*ActorCreateFunction)();</span>
        <span class="c1">//std::function&lt; Actor*(Targs...args) &gt; pp;</span>

        <span class="k">static</span> <span class="n">ActorFactory</span><span class="o">*</span> <span class="n">Instance</span><span class="p">(){</span>  <span class="c1">//! 线程不安全的单例模式。获取反射器指针。</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static ActorFactory* Instance()"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">nullptr</span> <span class="o">==</span> <span class="n">m_pActorFactory</span><span class="p">){</span>
                <span class="n">m_pActorFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ActorFactory</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span><span class="p">(</span><span class="n">m_pActorFactory</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">ActorFactory</span><span class="p">(){};</span>

        <span class="c1">//Lambda: static std::string ReadTypeName(const char * name)</span>

        <span class="c1">//bool Regist(const std::string&amp; strTypeName, ActorCreateFunction pFunc)</span>
        <span class="c1">//bool Regist(const std::string&amp; strTypeName, std::function&lt;Actor*()&gt; pFunc)</span>
        <span class="cm">/*
        
        &amp;将“实例创建方法（对象工厂的CreateObject方法）”注册到ActorFactory，注册的同时赋予这个方法一个名字“类名”，后续可以通过“类名”获得该类的“实例创建方法”。
        &amp;这个实例创建方法实质上是个函数指针，在C++11里std::function的可读性比函数指针更好，所以用了std::function。
        */</span>
        <span class="kt">bool</span> <span class="nf">Regist</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">strTypeName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">*</span><span class="p">(</span><span class="n">Targs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">pFunc</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bool ActorFactory::Regist(const std::string&amp; strTypeName, std::function&lt;Actor*(Targs... args)&gt; pFunc)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">nullptr</span> <span class="o">==</span> <span class="n">pFunc</span><span class="p">){</span>
                <span class="k">return</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">strRealTypeName</span> <span class="o">=</span> <span class="n">strTypeName</span><span class="p">;</span>
            <span class="c1">//[&amp;strTypeName, &amp;strRealTypeName]{int iPos = strTypeName.rfind(' '); strRealTypeName = std::move(strTypeName.substr(iPos+1, strTypeName.length() - (iPos + 1)));};</span>

            <span class="kt">bool</span> <span class="n">bReg</span> <span class="o">=</span> <span class="n">m_mapCreateFunction</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">strRealTypeName</span><span class="p">,</span> <span class="n">pFunc</span><span class="p">)).</span><span class="n">second</span><span class="p">;</span> <span class="c1">// 创建键值对</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"m_mapCreateFunction.size() ="</span> <span class="o">&lt;&lt;</span> <span class="n">m_mapCreateFunction</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span><span class="p">(</span><span class="n">bReg</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">//&amp; 传入“类名”和参数创建类实例，方法内部通过“类名”从m_mapCreateFunction获得了对应的“实例创建方法（DynamicCreator的CreateObject方法）”完成实例创建操作。</span>
        <span class="n">Actor</span><span class="o">*</span> <span class="nf">Create</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">strTypeName</span><span class="p">,</span> <span class="n">Targs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Actor* ActorFactory::Create(const std::string&amp; strTypeName, Targs... args)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m_mapCreateFunction</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">strTypeName</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">m_mapCreateFunction</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
                <span class="k">return</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="c1">//return(iter-&gt;second());</span>
                <span class="k">return</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Targs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span> <span class="c1">//把参数完美转发至实例创建方法。</span>
            <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">ActorFactory</span><span class="p">(){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ActorFactory construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;};</span> <span class="c1">//私有构造，经典的单例模式</span>
        <span class="k">static</span> <span class="n">ActorFactory</span><span class="o">&lt;</span><span class="n">Targs</span><span class="p">...</span><span class="o">&gt;*</span> <span class="n">m_pActorFactory</span><span class="p">;</span>   <span class="c1">//静态的单例的本类指针</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">*</span><span class="p">(</span><span class="n">Targs</span><span class="o">&amp;&amp;</span><span class="p">...)</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">m_mapCreateFunction</span><span class="p">;</span> <span class="c1">//存贮映射的数据结构。第二个std::function对象统一存储返回类型是Actor*，入参可变的函数。</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
    <span class="n">ActorFactory</span><span class="o">&lt;</span><span class="n">Targs</span><span class="p">...</span><span class="o">&gt;*</span> <span class="n">ActorFactory</span><span class="o">&lt;</span><span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">m_pActorFactory</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">//静态的单例的本类指针的类外定义并初始化</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">DynamicCreator</span><span class="p">{</span>  <span class="c1">//*理解为对象工厂</span>
    <span class="cm">/*
    我们写自己的业务类的时候，不仅要继承自反射基类，也要继承自这个类。
    继承自这个类的第一个参数就是我们的类名。会通过mangled方法获取到这个字符串
    然后把这个字符串和这个类的CreateObject函数放进去
    */</span>
    <span class="nl">public:</span>
        <span class="k">struct</span> <span class="nc">Register</span><span class="p">{</span>
            <span class="n">Register</span><span class="p">(){</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"DynamicCreator.Register construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span>
                <span class="kt">char</span><span class="o">*</span> <span class="n">szDemangleName</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
                <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">strTypeName</span><span class="p">;</span> <span class="c1">//这个就是类名</span>
                <span class="cp">#ifdef __GNUC__
</span>                    <span class="n">szDemangleName</span> <span class="o">=</span> <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">(),</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
                <span class="cp">#else
</span>                <span class="c1">//in this format?:     szDemangleName =  typeid(T).name();</span>
                    <span class="n">szDemangleName</span> <span class="o">=</span> <span class="n">abi</span><span class="o">::</span><span class="n">__cxa_demangle</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">(),</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
                <span class="cp">#endif
</span>                <span class="k">if</span> <span class="p">(</span><span class="nb">nullptr</span> <span class="o">!=</span> <span class="n">szDemangleName</span><span class="p">){</span>
                    <span class="n">strTypeName</span> <span class="o">=</span> <span class="n">szDemangleName</span><span class="p">;</span>
                    <span class="n">free</span><span class="p">(</span><span class="n">szDemangleName</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strTypeName</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">ActorFactory</span><span class="o">&lt;</span><span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Regist</span><span class="p">(</span><span class="n">strTypeName</span><span class="p">,</span> <span class="n">CreateObject</span><span class="p">);</span> <span class="c1">//通过反射器类实例把类名和创建函数放进去。</span>
            <span class="p">}</span>
            <span class="kr">inline</span> <span class="kt">void</span> <span class="n">do_nothing</span><span class="p">()</span><span class="k">const</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">//!注意这个do_nothing。</span>
        <span class="p">};</span>
        <span class="n">DynamicCreator</span><span class="p">(){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"DynamicCreator construct"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="n">m_oRegister</span><span class="p">.</span><span class="n">do_nothing</span><span class="p">();</span> <span class="c1">//!这里的目的是使用一次我们嵌套类的static对象。这样的话编译器不会优化掉嵌套类静态对象的构造。尤其是分离编译的时候，可能会发生链接错误。</span>
        <span class="p">}</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">DynamicCreator</span><span class="p">(){</span><span class="n">m_oRegister</span><span class="p">.</span><span class="n">do_nothing</span><span class="p">();};</span> <span class="c1">//!这里我就不知道为什么了</span>

        <span class="k">static</span> <span class="n">T</span><span class="o">*</span> <span class="nf">CreateObject</span><span class="p">(</span><span class="n">Targs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span> <span class="c1">//这个实例创建函数很有意思。别看它返回的是T*，但是由于我们所有的业务代码具体类都需要继承自反射基类。所以说T*是子类指针，而反射器存储的是Actor*父类指针。很自然的多态存储。</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static Actor* DynamicCreator::CreateObject(Targs... args)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Targs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span> <span class="c1">//一旦调用这个函数，就执行这个new。把传进来的参数再次完美转发至对象类的构造函数。</span>
        <span class="p">}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Say</span><span class="p">(){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"DynamicCreator say"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">static</span> <span class="n">Register</span> <span class="n">m_oRegister</span><span class="p">;</span> <span class="c1">//这里必须要是静态的。注意这是静态成员变量，不是静态局部变量。因为我们把注册的过程放到了Register的构造函数中。细节下面再说。</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
    <span class="k">typename</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Register</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">m_oRegister</span><span class="p">;</span> <span class="c1">//成员static变量的类外定义并默认初始化。这一行非常关键。注意这是静态成员变量，不是静态局部变量。</span>


    <span class="c1">//下面开始是业务类。第一个是继承自反射基类，然后继承自对象工厂类。对象工厂类第一个模板参数是本类类型，然后依次是构造函数参数类型。</span>
    <span class="k">class</span> <span class="nc">Cmd</span><span class="o">:</span> <span class="k">public</span> <span class="n">Actor</span><span class="p">,</span> <span class="k">public</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">Cmd</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Cmd</span><span class="p">(){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Create Cmd "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Say</span><span class="p">(){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am Cmd"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Step</span><span class="o">:</span> <span class="k">public</span> <span class="n">Actor</span><span class="p">,</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">Step</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">Step</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">strType</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iSeq</span><span class="p">){</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Create Step "</span> <span class="o">&lt;&lt;</span> <span class="n">strType</span> <span class="o">&lt;&lt;</span> <span class="s">" with seq "</span> <span class="o">&lt;&lt;</span> <span class="n">iSeq</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Say</span><span class="p">(){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am Step"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nc">miku</span><span class="o">:</span><span class="k">public</span> <span class="n">Actor</span><span class="p">,</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">miku</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span>
        <span class="n">miku</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"miku"</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Worker</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
        <span class="n">Actor</span><span class="o">*</span> <span class="n">CreateActor</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">strTypeName</span><span class="p">,</span> <span class="n">Targs</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
            <span class="n">Actor</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ActorFactory</span><span class="o">&lt;</span><span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="n">strTypeName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Targs</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
            <span class="k">return</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">neb</span><span class="o">::</span><span class="n">Worker</span> <span class="n">W</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">neb</span><span class="o">::</span><span class="n">Actor</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">CreateActor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"neb::Cmd"</span><span class="p">));</span>
    <span class="n">p1</span><span class="o">-&gt;</span><span class="n">Say</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">neb</span><span class="o">::</span><span class="n">Actor</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">CreateActor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"neb::Step"</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"neb::Step"</span><span class="p">),</span> <span class="mi">1002</span><span class="p">);</span>
    <span class="n">p2</span><span class="o">-&gt;</span><span class="n">Say</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------------------------------------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">neb</span><span class="o">::</span><span class="n">Actor</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">W</span><span class="p">.</span><span class="n">CreateActor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"neb::miku"</span><span class="p">),</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">p3</span><span class="o">-&gt;</span><span class="n">Say</span><span class="p">();</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>有一些具体的代码内容已经在注释说过了。我们一起看一下执行结果</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre>DynamicCreator.Register construct //静态成员变量类外定义导致的默认初始化。
neb::DynamicCreator&lt;T, Targs&gt;::Register::Register() [with T = neb::Cmd; Targs = {}] //为了好看打出来的
neb::Cmd //strTypeName也就是拿到的类名
static ActorFactory* Instance()//拿到ActorFactory的实例。因为ActorFactory也是单例模式。
ActorFactory construct //构造ActorFactory。因为不同的模板参数是不同的类。所以也是三次。
bool ActorFactory::Regist(const std::string&amp; strTypeName, std::function&lt;Actor*(Targs... args)&gt; pFunc) //注册
m_mapCreateFunction.size() =1 //不知道干啥的。
    
    
DynamicCreator.Register construct
neb::DynamicCreator&lt;T, Targs&gt;::Register::Register() [with T = neb::Step; Targs = {std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, int}]
neb::Step
static ActorFactory* Instance()
ActorFactory construct
bool ActorFactory::Regist(const std::string&amp; strTypeName, std::function&lt;Actor*(Targs... args)&gt; pFunc)
m_mapCreateFunction.size() =1
    
    
DynamicCreator.Register construct
neb::DynamicCreator&lt;T, Targs&gt;::Register::Register() [with T = neb::miku; Targs = {int, int}]
neb::miku
static ActorFactory* Instance()
ActorFactory construct
bool ActorFactory::Regist(const std::string&amp; strTypeName, std::function&lt;Actor*(Targs... args)&gt; pFunc)
m_mapCreateFunction.size() =1
</pre></table></code></div></div><p>上面这一部分是在执行main的第一行代码前执行的。为什么是这个顺序？</p><p>首先，我们代码的这一行</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">Targs</span><span class="p">&gt;</span>
    <span class="k">typename</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">Register</span> <span class="n">DynamicCreator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Targs</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">m_oRegister</span><span class="p">;</span> <span class="c1">//成员static变量的类外定义并且被默认初始化。这一行非常关键。注意这不是静态局部变量</span>
</pre></table></code></div></div><p>非常重要。首先，业务代码有三个类模板。分别继承了不同模板参数的<code class="language-plaintext highlighter-rouge">DynamicCreator</code>类模板。所以我们有三个不同模板参数的<code class="language-plaintext highlighter-rouge">DynamicCreator</code>。所以三个不同的类都有自己的<code class="language-plaintext highlighter-rouge">m_oRegister</code>。同时，<code class="language-plaintext highlighter-rouge">m_oRegister</code>不是静态局部变量，是静态成员变量。生存周期不同。所以说，我们在类外部的这个对静态成员变量的定义导致了其被<strong>默认初始化</strong>。所以我们看到有三个<code class="language-plaintext highlighter-rouge">DynamicCreator</code>内部的<code class="language-plaintext highlighter-rouge">Register</code>的默认构造函数被调用。</p><p>在<code class="language-plaintext highlighter-rouge">Register</code>的默认构造函数中，我们获得到了不同的<code class="language-plaintext highlighter-rouge">T</code>。然后通过这个<code class="language-plaintext highlighter-rouge">T</code>，获得到了特殊处理的类名。随后，由于<code class="language-plaintext highlighter-rouge">ActorFactory</code>也是类模板，所以它也是三份。自然也有三份不同的<code class="language-plaintext highlighter-rouge">m_pActorFactory</code>，所以也有三个<code class="language-plaintext highlighter-rouge">ActorFactory</code>的构造函数被调用。然后我们拿到了<code class="language-plaintext highlighter-rouge">ActorFactory</code>的实例，调用它的<code class="language-plaintext highlighter-rouge">Regist</code>注册，传入类名和一个函数<code class="language-plaintext highlighter-rouge">CreateObject</code>。这个函数很特殊，是一个静态的成员函数。别看它返回的是<code class="language-plaintext highlighter-rouge">T*</code>，但是由于我们所有的业务代码具体类都需要继承自反射基类。所以说<code class="language-plaintext highlighter-rouge">T*</code>是子类指针，而反射器存储的是一个返回值为<code class="language-plaintext highlighter-rouge">Actor*</code>（父类指针）的<code class="language-plaintext highlighter-rouge">std::function</code>对象。很自然的多态存储。这个函数一旦被调用，就会<code class="language-plaintext highlighter-rouge">new</code>。把传进来的参数再次完美转发至对象类的构造函数。</p><p>好了，下面开始看执行部分。</p><p>由于我们已经获取到了<code class="language-plaintext highlighter-rouge">ActorFactory</code>的实例，所以这次在调用中不再构造。然后调用<code class="language-plaintext highlighter-rouge">Create</code>函数。传入类名和构造函数参数。在这个函数中寻找对应类名的实例创建方法，然后完美转发参数至这个函数。进入到映射器存储的对应类的实例创建方法也就是<code class="language-plaintext highlighter-rouge">CreateObject</code>函数，<code class="language-plaintext highlighter-rouge">new</code>一个对应的对象。</p><p>这时候，我们刚刚才开始创建对象。随后，这个对象的第一基类也就是反射基类被创建。然后第二基类，也就是对象工厂基类被创建。然后是对象的子类部分。</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre>----------------------------------------------------------------------
static ActorFactory* Instance() //获取实例。由于上面已经构造过ActorFactory了，所以直接拿就可以。
Actor* ActorFactory::Create(const std::string&amp; strTypeName, Targs... args) //正式调用create
static Actor* DynamicCreator::CreateObject(Targs... args) //调用至映射器存储的对应类的CreateObject函数，new一个对应的对象
Actor construct //对应对象的反射基类部分
neb::DynamicCreator&lt;T, Targs&gt;::DynamicCreator() [with T = neb::Cmd; Targs = {}]//为了好看
DynamicCreator construct //对应对象的DynamicCreator基类部分。注意这个和上面的不同。这里是基类的构造。上面执行前的是内部嵌套类静态Register对象的初始化导致的。
Create Cmd //对象子类部分
I am Cmd
----------------------------------------------------------------------
static ActorFactory* Instance()
Actor* ActorFactory::Create(const std::string&amp; strTypeName, Targs... args)
static Actor* DynamicCreator::CreateObject(Targs... args)
Actor construct
neb::DynamicCreator&lt;T, Targs&gt;::DynamicCreator() [with T = neb::Step; Targs = {std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, int}]
DynamicCreator construct
Create Step neb::Step with seq 1002
I am Step
----------------------------------------------------------------------
static ActorFactory* Instance()
Actor* ActorFactory::Create(const std::string&amp; strTypeName, Targs... args)
static Actor* DynamicCreator::CreateObject(Targs... args)
Actor construct
neb::DynamicCreator&lt;T, Targs&gt;::DynamicCreator() [with T = neb::miku; Targs = {int, int}]
DynamicCreator construct
miku23
Actor
</pre></table></code></div></div><p>编译期静态反射，来自<a href="https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/">这里</a>，看不懂。</p><h1 id="动态链接的使用经验">动态链接的使用经验</h1><h2 id="运行时动态链接"><span class="mr-2">运行时动态链接</span><a href="#运行时动态链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>首先拥有动态库源文件，如<code class="language-plaintext highlighter-rouge">chn_lang.cpp</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">extern</span> <span class="s">"C"</span><span class="p">{</span> <span class="c1">//必须使用extern "C"</span>
    <span class="kt">void</span> <span class="n">print_cur_language</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"chinese"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>编译源文件</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ <span class="nt">-c</span> <span class="nt">-fPIC</span> chn_lang.cpp <span class="nt">-o</span> chn_lang.o
</pre></table></code></div></div><ul><li>链接为动态链接库</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ <span class="nt">-shared</span> chn_lang.o <span class="nt">-o</span> libchn_lang.so
</pre></table></code></div></div><ul><li>编写主文件</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">"./libchn_lang.so"</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to load the library: "</span> <span class="o">&lt;&lt;</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 从动态链接库中获取函数指针</span>
    <span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ExampleFunction</span><span class="p">)();</span>
    <span class="n">ExampleFunction</span> <span class="n">exampleFunc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ExampleFunction</span><span class="p">)</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">"print_cur_language"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exampleFunc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Failed to load the function: "</span> <span class="o">&lt;&lt;</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 调用函数</span>
    <span class="n">exampleFunc</span><span class="p">();</span>
    <span class="c1">// 关闭动态链接库</span>
    <span class="n">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>编译主文件<ul><li>使用 <code class="language-plaintext highlighter-rouge">g++</code> 编译器时，使用 <code class="language-plaintext highlighter-rouge">-ldl</code> 选项是为了链接 <code class="language-plaintext highlighter-rouge">libdl</code> 库，该库提供了对动态链接库（<code class="language-plaintext highlighter-rouge">.so</code> 文件）的动态加载和符号解析的支持。</ul></ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ main.cpp <span class="nt">-ldl</span> <span class="nt">-o</span> main
</pre></table></code></div></div><h3 id="运行时动态链接的好处和坏处"><span class="mr-2">运行时动态链接的好处和坏处</span><a href="#运行时动态链接的好处和坏处" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>好处是可以自由的加载和卸载所需的动态库。坏处是有些API，比如<code class="language-plaintext highlighter-rouge">dlsym</code>是采用字符串来进行符号查找，所以<code class="language-plaintext highlighter-rouge">C++</code>这种带mangling的就会很难受。一般会使用<code class="language-plaintext highlighter-rouge">extern "C"</code>来强制使用C风格的API，但是这样就不能使用函数重载了。</p><h2 id="加载时动态链接"><span class="mr-2">加载时动态链接</span><a href="#加载时动态链接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>根据我目前的学习方式，由于<code class="language-plaintext highlighter-rouge">dlsym</code>是采用我们拿字符串来进行符号查找，所以C++这种带mangling的就会很难受。</p><ul><li>首先拥有动态库源文件，如<code class="language-plaintext highlighter-rouge">chn_lang.cpp</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">extern</span> <span class="s">"C"</span><span class="p">{</span> <span class="c1">//如果此处使用了extern "C", 则后面的头文件也需要使用extern "C"注明</span>
    <span class="kt">void</span> <span class="n">print_cur_language</span><span class="p">(){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"chinese"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>编译源文件</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ <span class="nt">-c</span> <span class="nt">-fPIC</span> chn_lang.cpp <span class="nt">-o</span> chn_lang.o
</pre></table></code></div></div><ul><li>链接为动态链接库</ul><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ <span class="nt">-shared</span> chn_lang.o <span class="nt">-o</span> libchn_lang.so
</pre></table></code></div></div><ul><li>编写头文件</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#ifndef LANGUAGEHEADER_H
#define LANGUAGEHEADER_H
</span>
<span class="k">extern</span> <span class="s">"C"</span> <span class="kt">void</span> <span class="nf">print_cur_language</span><span class="p">();</span> <span class="c1">//因为我们上面使用了extern "C"，所以这里也需要</span>
<span class="cp">#endif
</span></pre></table></code></div></div><ul><li>编写主文件</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">"languageheader.h"</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">print_cur_language</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><p>编译主文件并链接至动态链接库</p><ul><li><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>g++ main.cpp <span class="nt">-l</span>&lt;library1&gt; <span class="nt">-l</span>&lt;library2&gt; <span class="nt">-o</span> executable
如
g++ main.cpp <span class="nt">-lchn_lang</span> <span class="nt">-o</span> main
</pre></table></code></div></div><li><p>如果在使用<code class="language-plaintext highlighter-rouge">-l</code>指定库文件名称的时候，我们的动态链接库不在标准路径，则需要配置环境变量并添加<code class="language-plaintext highlighter-rouge">-L</code>指定库文件的目录路径：</p><ul><li><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>&lt;path_to_library&gt;:<span class="nv">$LD_LIBRARY_PATH</span>
如
<span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>./:<span class="nv">$LD_LIBRARY_PATH</span>
然后
g++ main.cpp <span class="nt">-L</span>./ <span class="nt">-lchn_lang</span> <span class="nt">-o</span> main
</pre></table></code></div></div><li><p>采用<code class="language-plaintext highlighter-rouge">-l</code>指定库文件名称会帮助我们把动态链接库的前缀<code class="language-plaintext highlighter-rouge">lib</code>和后缀<code class="language-plaintext highlighter-rouge">.so</code>补齐，所以此处不需要再添加。</p><li><p>搜索路径可以是绝对路径或相对路径。如果是完整的绝对路径（例如 <code class="language-plaintext highlighter-rouge">/path/to/library</code>），则链接器将使用该路径作为库文件的准确位置。如果是相对路径（例如 <code class="language-plaintext highlighter-rouge">./libraries</code> 或 <code class="language-plaintext highlighter-rouge">../libs</code>），则链接器将在当前工作目录下搜索库文件。</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230619203556.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/QQ%E6%88%AA%E5%9B%BE20230619203556.png" alt="QQ截图20230619203556" class="lazyload" data-proofer-ignore></a></p></ul><li><p>如果我们的库文件的名称并不是标准化，如<code class="language-plaintext highlighter-rouge">lib___.so</code>形式，则可以在<code class="language-plaintext highlighter-rouge">-l</code>命令后添加冒号<code class="language-plaintext highlighter-rouge">:</code>。然后放入库文件的全名附带后缀</p><ul><li><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>g++ main.cpp <span class="nt">-L</span>./ <span class="nt">-l</span>:somethingchn_lang.so <span class="nt">-o</span> main
</pre></table></code></div></div></ul></ul></ul><p>如果此时我们有多个动态链接库文件，并且都有同名符号，则链接顺序和符号强度决定了具体调用的函数。比如：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>g++ main2.cpp <span class="nt">-L</span>./ <span class="nt">-lchn_lang</span> <span class="nt">-leng_lang</span> <span class="nt">-o</span> main2
g++ main2.cpp <span class="nt">-L</span>./ <span class="nt">-leng_lang</span> <span class="nt">-lchn_lang</span> <span class="nt">-o</span> main2
</pre></table></code></div></div><p>第一种输出<code class="language-plaintext highlighter-rouge">chinese</code>而第二种输出<code class="language-plaintext highlighter-rouge">english</code></p><p>具体的一些讨论可以参考这两篇文章：<a href="https://xuhongxu.com/2018/09/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%87%8D%E5%90%8D%E9%97%AE%E9%A2%98/">动态链接库的符号重名问题</a> 和 <a href="https://www.cnblogs.com/kernel_hcy/archive/2010/01/27/1657411.html">强弱符号和强弱引用</a></p><h2 id="有用的文章"><span class="mr-2">有用的文章</span><a href="#有用的文章" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size">动态链接静态链接和二进制大小</a></p><p><a href="https://huweicai.com/dynamic-linking/">动态链接的原理</a></p><h1 id="标识符-限定标识符有限定名称查找无限定名称查找和adl-实参依赖查找">标识符， 限定标识符，有限定名称查找，无限定名称查找和ADL 实参依赖查找</h1><h2 id="标识符"><span class="mr-2">标识符</span><a href="#标识符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C++编译器将文件代码源文件解析后，将代码分解为<code class="language-plaintext highlighter-rouge">identifier</code><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#fn:1">1</a>、数值、运算符等，其中<code class="language-plaintext highlighter-rouge">identifier</code>是由非数字开头、任意字符数字和下划线组成的部分，其用来组成<code class="language-plaintext highlighter-rouge">声明</code>、<code class="language-plaintext highlighter-rouge">表达式</code>、<code class="language-plaintext highlighter-rouge">name</code>和<code class="language-plaintext highlighter-rouge">qualified identifier</code>。</p><p>在<code class="language-plaintext highlighter-rouge">声明</code>中<code class="language-plaintext highlighter-rouge">identifier</code>:</p><ul><li>不能时语法关键字<li>不要以双下划线（<code class="language-plaintext highlighter-rouge">__</code>）或者下划线（<code class="language-plaintext highlighter-rouge">_</code>）开头，以免和编译器或者标准库的内部声明冲突，可以参见<code class="language-plaintext highlighter-rouge">17.6.4.3 [reserved.names]</code></ul><p><code class="language-plaintext highlighter-rouge">identifier</code>在表达式中除了表示一些简单的函数和对象外，还可以是：</p><ul><li>函数写法的重载运算符名。比如 <code class="language-plaintext highlighter-rouge">operator+</code> or <code class="language-plaintext highlighter-rouge">operator new</code>;<li>the name of an operator function, such as <code class="language-plaintext highlighter-rouge">operator+</code> or <code class="language-plaintext highlighter-rouge">operator new</code>;<li>用户定义转换函数的名字，比如 <code class="language-plaintext highlighter-rouge">operator bool</code>;<li>用户定义字面量运算符的名字 比如 <code class="language-plaintext highlighter-rouge">operator "" _km</code>;<li><code class="language-plaintext highlighter-rouge">~</code>字符后随类名，如<code class="language-plaintext highlighter-rouge">~MyClass</code>;<li><code class="language-plaintext highlighter-rouge">~</code> 字符后随decltype说明符，比如<code class="language-plaintext highlighter-rouge">~decltype(str)</code>;<li>模板名后随包含模板实参的角括号 比如<code class="language-plaintext highlighter-rouge">MyTemplate&lt;int&gt;</code>;<li>作用域解析操作符<code class="language-plaintext highlighter-rouge">::</code>限定的标识符 例如 <code class="language-plaintext highlighter-rouge">std::string</code> or <code class="language-plaintext highlighter-rouge">::tolower</code>.</ul><h2 id="限定标识符"><span class="mr-2">限定标识符</span><a href="#限定标识符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">qualified identifier(限定标识符)</code>是由域解析符<code class="language-plaintext highlighter-rouge">::</code>标识与<code class="language-plaintext highlighter-rouge">class</code>名、枚举类名、<code class="language-plaintext highlighter-rouge">namespace</code>或者<code class="language-plaintext highlighter-rouge">decltype</code>表达式限定的一类<code class="language-plaintext highlighter-rouge">identifier</code>。</p><p>比如:</p><ul><li><code class="language-plaintext highlighter-rouge">std::string::npos</code><li><code class="language-plaintext highlighter-rouge">::tolower</code><li><code class="language-plaintext highlighter-rouge">::std::cout</code><li><code class="language-plaintext highlighter-rouge">boost::signals2::connection</code></ul><h2 id="名称"><span class="mr-2">名称</span><a href="#名称" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">name</code>是指下面的一个实体或标签：</p><ul><li>一个标识符<code class="language-plaintext highlighter-rouge">identifier</code><li>操作符函数 (<code class="language-plaintext highlighter-rouge">operator+</code>, <code class="language-plaintext highlighter-rouge">operator new</code>);<li><a href="http://doc.bccnsoft.com/docs/cppreference2015/en/cpp/language/cast_operator.html">用户定义的转换函数</a> (<code class="language-plaintext highlighter-rouge">operator bool</code>);<li><a href="http://doc.bccnsoft.com/docs/cppreference2015/en/cpp/language/user_literal.html">用户定义的字面值转换符</a> (<code class="language-plaintext highlighter-rouge">operator "" _km</code>);<li>模板 id (<code class="language-plaintext highlighter-rouge">name&lt;arg, arg&gt;</code>).<li><code class="language-plaintext highlighter-rouge">goto</code>语句指向的<code class="language-plaintext highlighter-rouge">label</code></ul><p>当编译器遇到一个未知的<code class="language-plaintext highlighter-rouge">name</code>时，会进行<code class="language-plaintext highlighter-rouge">name lookup</code><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#fn:2">2</a>，例如，当编译<code class="language-plaintext highlighter-rouge">std::cout &lt;&lt; std::endl;</code>时：</p><ul><li>因为<code class="language-plaintext highlighter-rouge">std</code>左侧没有<code class="language-plaintext highlighter-rouge">::</code>进行限定，则对<code class="language-plaintext highlighter-rouge">std</code>进行<code class="language-plaintext highlighter-rouge">unqualified name lookup</code>，发现其是一个声明在头文件<code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code>中的<code class="language-plaintext highlighter-rouge">namespace</code><li>因为<code class="language-plaintext highlighter-rouge">cout</code>左侧有<code class="language-plaintext highlighter-rouge">::</code>进行限定且其限定的域为一个<code class="language-plaintext highlighter-rouge">namespace</code>，则对<code class="language-plaintext highlighter-rouge">cout</code>进行<code class="language-plaintext highlighter-rouge">qualified name lookup</code>，发现其是一个声明在<code class="language-plaintext highlighter-rouge">namespace std</code>中的变量<li>因为<code class="language-plaintext highlighter-rouge">endl</code>左侧有<code class="language-plaintext highlighter-rouge">::</code>进行限定且其限定的域为一个<code class="language-plaintext highlighter-rouge">namespace</code>，则对<code class="language-plaintext highlighter-rouge">endl</code>进行<code class="language-plaintext highlighter-rouge">qualified name lookup</code>，发现其是一个声明在<code class="language-plaintext highlighter-rouge">namespace std</code>中的函数模板<li><code class="language-plaintext highlighter-rouge">&lt;&lt;</code>没有限定且为一个函数，对<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>进行<code class="language-plaintext highlighter-rouge">argument-dependent lookup</code>，发现其是一个声明在<code class="language-plaintext highlighter-rouge">namespace std</code>中的函数模板声明</ul><p><strong>其主要规则是，如果目标是一个<code class="language-plaintext highlighter-rouge">qualified identifier(限定标识符)</code>，进行<code class="language-plaintext highlighter-rouge">Qualified name lookup</code><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#fn:3">3</a>，否则进行<code class="language-plaintext highlighter-rouge">Unqualified name lookup</code><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#fn:4">4</a>，对于函数还可能进行<code class="language-plaintext highlighter-rouge">Argument-dependent lookup</code><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#fn:5">5</a></strong></p><h2 id="有限定名称查找-qualified-name-lookup"><span class="mr-2">有限定名称查找 Qualified name lookup</span><a href="#有限定名称查找-qualified-name-lookup" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>当遇到未知的<code class="language-plaintext highlighter-rouge">qualified identifier(限定标识符)</code>时，会去其对应的限定符区域内进行查找，比如命名空间、类作用域、枚举空间等。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 解析"cout"时，去命名空间std中进行查找</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">A</span><span class="o">::</span><span class="n">type</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// 解析"type"时，去A类作用域中查找</span>
</pre></table></code></div></div><blockquote><p>如果<code class="language-plaintext highlighter-rouge">::</code>左侧没有限定符，则去全局命名空间进行查找，这样就避免了被本地声明遮盖的情况：</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">std</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fail</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  <span class="c1">// Error: unqualified lookup for 'std' finds the struct</span>
    <span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ok</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>  <span class="c1">// OK: ::std finds the namespace std</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>当然，在解析<code class="language-plaintext highlighter-rouge">::</code>右手侧的<code class="language-plaintext highlighter-rouge">name</code>之前需要先解析<code class="language-plaintext highlighter-rouge">::</code>左手侧的<code class="language-plaintext highlighter-rouge">name</code>（除非使用了<code class="language-plaintext highlighter-rouge">decltype</code>表达式或者<code class="language-plaintext highlighter-rouge">::</code>左侧为空）。<strong>至于带<code class="language-plaintext highlighter-rouge">::</code>的<code class="language-plaintext highlighter-rouge">name</code>查找时<code class="language-plaintext highlighter-rouge">qualified name lookup</code>还是<code class="language-plaintext highlighter-rouge">unqualified name lookup</code>，取决于<code class="language-plaintext highlighter-rouge">::</code>左侧的<code class="language-plaintext highlighter-rouge">name</code>。当<code class="language-plaintext highlighter-rouge">::</code>左侧<code class="language-plaintext highlighter-rouge">name</code>为<code class="language-plaintext highlighter-rouge">namespace</code>、<code class="language-plaintext highlighter-rouge">class</code>、<code class="language-plaintext highlighter-rouge">枚举</code>、<code class="language-plaintext highlighter-rouge">实例化的模板</code>时，为<code class="language-plaintext highlighter-rouge">qualified name lookup</code>。</strong></p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">A</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">A</span><span class="p">;</span>
    <span class="n">A</span><span class="o">::</span><span class="n">n</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>   <span class="c1">// OK: 对"A"进行"unqualified lookup"时，忽略了本地变量A</span>
    <span class="n">A</span> <span class="n">b</span><span class="p">;</span>         <span class="c1">// 错误: 对"A"进行"unqualified lookup"会指向本地变量A</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// A 前面需要增加tag "struct" 进行限定，以避免被本地变量A遮盖</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">qualified name</code>用于<a href="https://en.cppreference.com/w/cpp/language/declarations">声明</a>时，当同在一个声明中的<code class="language-plaintext highlighter-rouge">unqualified name</code>需要进行<code class="language-plaintext highlighter-rouge">unqualified lookup</code>时，在<code class="language-plaintext highlighter-rouge">qualified name</code>对应的类作用域、命名空间进行查找。不在同一个声明中的<code class="language-plaintext highlighter-rouge">unqualified name</code>，不会受到这个影响。同时也不受声明类型的影响。</p></blockquote><p>上面这一段话比较难描述，需要结合一个例子来理解：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">X</span> <span class="p">{};</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">X</span> <span class="p">{};</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">X</span> <span class="n">arr</span><span class="p">[</span><span class="n">number</span><span class="p">];</span>
<span class="p">};</span>
<span class="n">X</span> <span class="n">C</span><span class="o">::</span><span class="n">arr</span><span class="p">[</span><span class="n">number</span><span class="p">],</span>
    <span class="n">brr</span><span class="p">[</span><span class="n">number</span><span class="p">];</span>  <span class="c1">// 错误: "X"经过`unqualified name`解析为`::X`与`C::arr`对应的`C::X`不同。</span>
<span class="n">C</span><span class="o">::</span><span class="n">X</span> <span class="n">C</span><span class="o">::</span><span class="n">arr</span><span class="p">[</span><span class="n">number</span><span class="p">],</span> <span class="n">brr</span><span class="p">[</span><span class="n">number</span><span class="p">];</span>  <span class="c1">// OK: `C::arr`的长度为50，`brr`的长度为100</span>
<span class="c1">// `C::arr[number]`中的`number`受同一个声明中的"qualified name"`C::arr`</span>
<span class="c1">// 的影响，回去类作用域`C`中查找，得到`C::number`，也就是50。而`brr[number]`</span>
<span class="c1">// 与`C::arr[number]`不是同一个声明，则不受这种影响，得到`::number`，也就是100</span>
</pre></table></code></div></div><blockquote><p>如果 <code class="language-plaintext highlighter-rouge">::</code> 后随字符 <code class="language-plaintext highlighter-rouge">~</code> 再跟着一个标识符（也就是说指定了析构函数或伪析构函数），那么该标识符将在与 <code class="language-plaintext highlighter-rouge">::</code> 左边的名字相同的作用域中查找。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">I</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">I1</span><span class="p">,</span> <span class="n">I2</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="o">~</span><span class="n">A</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">A</span> <span class="n">AB</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">C</span><span class="o">::</span><span class="n">I</span><span class="o">::~</span><span class="n">I</span><span class="p">();</span>  <span class="c1">// 解析`~I()`时，使用`C::I`这个`name`相同的域`C::`，则找到了`C::I`</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">I1</span><span class="o">::~</span><span class="n">I2</span><span class="p">();</span>  <span class="c1">// 解析`~I2()`时，使用`::I1`这个`name`相同的域，则找到了`::I2`</span>
    <span class="n">AB</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">AB</span><span class="o">::~</span><span class="n">AB</span><span class="p">();</span>  <span class="c1">// ~ 之后的名字 AB 在 :: 前面的 AB 的同一个作用域中查找</span>
                  <span class="c1">// 也就是说从当前的作用域中查找，因此查找结果是 ::AB</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>当<code class="language-plaintext highlighter-rouge">::</code>左侧为枚举类时，则<code class="language-plaintext highlighter-rouge">::</code>右侧的<code class="language-plaintext highlighter-rouge">name</code>必须属于这个枚举类，否则为<code class="language-plaintext highlighter-rouge">ill-formed</code></p></blockquote><blockquote><p><code class="language-plaintext highlighter-rouge">qualified name lookup</code>还可以被用来调用被隐藏的方法，这种调用方式不会调用虚函数：</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">B</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">b</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>     <span class="c1">// calls D::foo (virtual dispatch)</span>
    <span class="n">b</span><span class="p">.</span><span class="n">B</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>  <span class="c1">// calls B::foo (static dispatch)</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>模板参数进行解析时，从当前域进行解析</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">foo</span> <span class="p">{};</span>
    <span class="k">struct</span> <span class="nc">X</span> <span class="p">{};</span>
<span class="p">}</span>  <span class="c1">// namespace N</span>
<span class="n">N</span><span class="o">::</span><span class="n">foo</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// 错误："X"被解析为"::X"，而不是"N::X"</span>
</pre></table></code></div></div><blockquote><p>对一个<code class="language-plaintext highlighter-rouge">namespace N</code>进行<code class="language-plaintext highlighter-rouge">qualified name lookup</code>时，首先考虑<code class="language-plaintext highlighter-rouge">namespace N</code>内的声明和<a href="https://en.cppreference.com/w/cpp/language/namespace#Inline_namespaces"><code class="language-plaintext highlighter-rouge">inline namespace members</code></a>。如果没有匹配的，其次考虑<a href="https://en.cppreference.com/w/cpp/language/namespace#Using-directives"><code class="language-plaintext highlighter-rouge">using-directives</code></a>导入到<code class="language-plaintext highlighter-rouge">namespace N</code>中的声明</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">Y</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>  <span class="c1">// namespace Y</span>
<span class="k">namespace</span> <span class="n">Z</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">}</span>  <span class="c1">// namespace Z</span>
<span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">Y</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// namespace A</span>
<span class="k">namespace</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">Z</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// namespace B</span>
<span class="k">namespace</span> <span class="n">AB</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">A</span><span class="p">;</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">B</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// namespace AB</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AB</span><span class="o">::</span><span class="n">g</span><span class="p">();</span>  <span class="c1">// 首先考虑"AB::g"，则不再对namespace A、B进行查找</span>
    <span class="n">AB</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">// 首先在namespace AB中查找，未匹配，然后到namespace A、B中查找，查找到"A::f"和"B::f"，</span>
               <span class="c1">// 有匹配，则不再对namespace Y进行查找。然后在"A::f"和"B::f"中间选择了"A::f(int)"。</span>
    <span class="n">AB</span><span class="o">::</span><span class="n">x</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 首先在namespace AB中查找，未匹配。然后到namespace A、B中查找，未匹配。</span>
              <span class="c1">// 然后到namespace Y、Z中查找，未匹配。然后报错。</span>
    <span class="n">AB</span><span class="o">::</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 首先在namespace AB中查找，未匹配。然后到namespace A、B中查找，匹配到"A::i"和"B::i"</span>
              <span class="c1">// 存在冲突，报错。</span>
    <span class="n">AB</span><span class="o">::</span><span class="n">h</span><span class="p">(</span><span class="mf">16.8</span><span class="p">);</span>  <span class="c1">// 首先在namespace AB中查找，未匹配。然后到namespace A、B中查找，未匹配。</span>
                  <span class="c1">// 然后到namespace Y、Z中查找，匹配到"Y::h"和"Z::h"，选择"Z::h(double)"</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>在<code class="language-plaintext highlighter-rouge">namespace</code>中进行<code class="language-plaintext highlighter-rouge">qualified name lookup</code>时，允许通过不同途径匹配到相同的类型</p></blockquote><pre><code class="language-C++">namespace A {
    int a;
}  // namespace A
namespace B {
    using namespace A;
}  // namespace B
namespace D {
    using A::a;
}  // namespace D
namespace BD {
    using namespace B;
    using namespace D;
}  // namespace BD
void g() {
    BD::a++;  // 首先在 namespace BD 中查找，未匹配。然后到 namespace B、D中查找，未匹配。
              // 再下面，namespace B、D都同时指向了 namespace A，则在 namespace A 中匹
              // 配到 A::a，选择 "A::a"
}
</code></pre><h2 id="无限定名称查找"><span class="mr-2">无限定名称查找</span><a href="#无限定名称查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">unqualified name</code>只要指那些左侧没有<code class="language-plaintext highlighter-rouge">::</code>域符号限定的<code class="language-plaintext highlighter-rouge">name</code>。在搜索时，在相关命名空间、<code class="language-plaintext highlighter-rouge">using</code>引入的命名空间等域进行，直到找到一个匹配的类型则停止。</p><p>当遇到一个未知的<code class="language-plaintext highlighter-rouge">unqualified name</code>时，会从当前文件域、命名空间开始查找，具体情形比较简单。下面列出一些需要特殊注意的点：</p><blockquote><p>一个变量的定义在其命名空间<code class="language-plaintext highlighter-rouge">X</code>外时且定义语句中引用了<code class="language-plaintext highlighter-rouge">unqualified name</code>，解析这个<code class="language-plaintext highlighter-rouge">unqualified name</code>时，首先从变量命名空间<code class="language-plaintext highlighter-rouge">X</code>开始查找。有点类似ADL，但是注意区别。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">X</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// 声明，不是定义</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 在解析x的定义时，其引用了unqualified name “n”，先从其定义域"X"开始搜索，首先发现 n=1</span>
<span class="p">};</span>  <span class="c1">// namespace X</span>

<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>     <span class="c1">// 如果X::n不存在时，则匹配::n，否则被遮盖。</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// X::x的定义式，X::x的定义在其命名空间"X"外，且引用了unqualified name “n”，</span>
               <span class="c1">// 在解析"n"时，匹配X::n，则X::x为1</span>
</pre></table></code></div></div><blockquote><p>当在命名空间外定义一个<code class="language-plaintext highlighter-rouge">非成员函数</code>时，如果函数内引用了<code class="language-plaintext highlighter-rouge">unqualified name</code>时，解析这个<code class="language-plaintext highlighter-rouge">unqualified name</code>时，依次搜索其函数定义之前的：<code class="language-plaintext highlighter-rouge">本地代码块</code>、<code class="language-plaintext highlighter-rouge">代码块外层定义变量</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">命名空间</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">外层命名空间</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">全局域</code>，直到找到一个匹配的<code class="language-plaintext highlighter-rouge">name</code>，在函数定义之后的相关域不在搜索范围内。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 3: 查找"命名空间"，如果将①②注释掉，这句定义存在，则"i"的定义匹配此处，则i=3</span>
    <span class="p">}</span>  <span class="c1">// namespace N</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="c1">// 4: 查找"外层命名空间"，如果将①②③注释掉，这句定义存在，则"i"的定义匹配此处，则i=4</span>
<span class="p">}</span>  <span class="c1">// namespace A</span>

<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>  <span class="c1">// 5: 查找"全局域"，如果将①②③④注释掉，这句定义存在，则"i"的定义匹配此处，则i=5</span>

<span class="c1">// 在命名空间外定义了一个非成员函数f()，这个例子的注释需要按照序号来看。</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">N</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 2: 其次查找"外层代码块"，如果将①注释掉，这句定义存在，则"i"的定义匹配此处，则i=2</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 1: 首先查找“本地代码块”，如果这句定义存在，则"i"的定义匹配此处，则i=1</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 0: 在代码块中引用了unqualified name "i"，则需要查找"i"的定义</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// int i; // 如果将5移动到f()定义之后则不参与"i"的查找</span>

<span class="k">namespace</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="c1">// int i; // 如果将3移动到f()定义之后则不参与"i"的查找</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace A</span>
</pre></table></code></div></div><blockquote><p>对于在类的定义中所使用的<code class="language-plaintext highlighter-rouge">unqualified name</code>，当出现于除了在成员函数体、成员函数的默认实参、成员函数的异常规定、默认成员初始化器、契约条件 (C++20 起)或者嵌套类的定义（包括嵌套类从之派生的基类的名字）以外的任何位置时，要在下列作用域中查找：</p><ul><li>类体之中直到这次使用点之前的部分以及其基类的整个类体<li>基类的整个类体，找不到声明时，递归到基类的基类中<li>当这个类是嵌套类时，其外围类体中直到这个类的声明之前的部分以及外围类的基类的整个类体<li>当这个类是局部类或局部类的嵌套类时，定义了这个类的块作用域中直到其定义点之前的部分<li>当这个类是命名空间的成员，或者命名空间成员类的嵌套类，或者命名空间成员函数的局部类时，查找这个命名空间作用域中直到这个类、其外围类或函数的定义之前的部分。若所查找的是由友元声明所引入的名字：这种情况下仅考虑其最内层的外围命名空间，否则的话，对外围命名空间的查找将照常持续直到全局作用域。</ul></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">M</span> <span class="p">{</span>
    <span class="c1">// const int i = 1; // 找不到这个</span>
    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="c1">// const const int i = 3; // 找到了第三个（但之后会被访问检查所拒绝）</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace M</span>
<span class="c1">// const int i = 5; // 找到了第五个</span>
<span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
    <span class="c1">// const int i = 4; // 找到了第四个</span>
    <span class="k">class</span> <span class="nc">Y</span> <span class="o">:</span> <span class="k">public</span> <span class="n">M</span><span class="o">::</span><span class="n">B</span> <span class="p">{</span>
        <span class="c1">// static const int i = 2; // 找到了第二个</span>
        <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
            <span class="c1">// static const int i = 1; // 找到了第一个</span>
            <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">// use of i</span>
            <span class="c1">// static const int i = 1; // 找不到这个</span>
        <span class="p">};</span>
        <span class="c1">// static const int i = 2; // 找不到这个</span>
    <span class="p">};</span>
    <span class="c1">// const int i = 4; // 找不到这个</span>
<span class="p">}</span>  <span class="c1">// namespace N</span>
<span class="c1">// const int i = 5; // 找不到这个</span>
</pre></table></code></div></div><blockquote><p>当在类作用域外定义一个<code class="language-plaintext highlighter-rouge">成员函数</code>时，如果函数内引用了<code class="language-plaintext highlighter-rouge">unqualified name</code>时，解析这个<code class="language-plaintext highlighter-rouge">unqualified name</code>时，依次搜索其函数定义之前的：<code class="language-plaintext highlighter-rouge">本地代码块</code>、<code class="language-plaintext highlighter-rouge">代码块外层定义变量</code>、<code class="language-plaintext highlighter-rouge">类作用域</code>、<code class="language-plaintext highlighter-rouge">基类作用域</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">命名空间</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">外层命名空间</code>、函数定义之前的<code class="language-plaintext highlighter-rouge">全局域</code>，直到找到一个匹配的<code class="language-plaintext highlighter-rouge">name</code>，在函数定义之后的相关域不在搜索范围内。注意跟上面<code class="language-plaintext highlighter-rouge">非成员函数</code>的区别。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 4: 如果1 2 3不存在，”i“匹配此处</span>
<span class="p">};</span>
<span class="k">namespace</span> <span class="n">M</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 6: 如果1 2 3 4 5不存在，”i“匹配此处</span>
    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 5: 如果1 2 3 4不存在，”i“匹配此处</span>
        <span class="k">class</span> <span class="nc">X</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>     <span class="c1">// 3: 如果1 2不存在，”i“匹配此处</span>
            <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// 0: class X中声明了一个函数f()</span>
            <span class="c1">// int i; // 将3移动到这里也OK，类成员的可见性受声明的位置的影响。</span>
        <span class="p">};</span>
        <span class="c1">// int i; // 5移动到这里也可以，跟f()实现代码的位置有关，与f()声明的位置无关</span>
    <span class="p">}</span>  <span class="c1">// namespace N</span>
<span class="p">}</span>  <span class="c1">// namespace M</span>

<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 7: 如果1 2 3 4 5 6 7不存在，”i“匹配此处</span>

<span class="c1">// 定义class X中声明的函数f()</span>
<span class="kt">void</span> <span class="n">M</span><span class="o">::</span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 2: 如果2不存在，”i“匹配此处</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">// 2: 如果2存在，”i“首先匹配此处</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// int i; // 如果这句存在，1 2都不存在，也不会匹配此处，因为其出现在调用i的代码块之后</span>
<span class="p">}</span>
<span class="k">namespace</span> <span class="n">M</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
    	<span class="c1">// int i; // 5移动到这里不匹配，其出现在f()实现代码之后</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace M</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">虚继承的优先性</code>，这个概念用定义来讲非常麻烦，简单来讲就是：如果一个类A由类B派生而来、类B虚继承自类C，则在类A中进行非限定查找时，类B中的符号会隐藏遮盖掉类C中的name，如果类A还通过其他非虚继承的方式继承了类C，则类B不会隐蔽遮盖类C中的相同name，发生歧义错误。</p></blockquote><pre><code class="language-C++">struct X {
    void f();
};
struct B1 : virtual X {
    void f();
};
struct B2 : virtual X {};
struct D : B1, B2 {
    void foo() {
        X::f();  // OK，调用了 X::f（有限定查找）
        f();     // OK，调用了 B1::f（无限定查找）
/*
C++98 规则：B1::f 隐藏 X::f，因此即便从 D 通过 B2 可以访问到 X::f，它也不能从 D 中的名字查找所找到。
C++11 规则：在 D 中对 f 的查找集合并未找到任何东西，继续处理其基类。 在 B1 中对 f 的查找集合找到了 B1::f，并且完成查找合并时替换了空集，此时在 C 中 对 f 的查找集合包含 B1 中的 B1::f。在 B2 中对 f 的查找集合并未找到任何东西，继续处理其基类。在 X 中对 f 的查找找到了 X::f合并时替换了空集，此时在 B2 中对 f 的查找集合包含 X 中的 X::f。当向 C 中合并时发现在 B2 的查找集合中的每个子对象（X）都是已经合并的各个子对象（B1）的基类，因此 B2 的集合被丢弃。C 剩下来的就是在 B1 中所找到的 B1::f (如果使用 struct D : B2, B1，则最后的合并将会替换掉。C 此时已经合并的 X 中的 X::f，因为已经加入到 C 中的每个子对象（就是 X）都是新集合（B1）中的至少一个子对象的基类，其最终结果是一样的：C 的查找集合只包含在 B1 中找到的 B1::f）
*/
    }
};
#include &lt;iostream&gt;

struct X {
    void f() { std::cout &lt;&lt; "X::f()" &lt;&lt; std::endl; }
};
struct B1 : virtual X {
    void f() { std::cout &lt;&lt; "B1::f()" &lt;&lt; std::endl; }
};
struct B2 : X {};
struct D : B1, B2 {
    void foo() {
        X::f();  // OK，调用了 X::f（有限定查找）
        f();  // 由于D还通过B2的渠道非虚继承了X，则X::f()不会被B1::f()遮盖掉，所以此处发生歧义错误。
    };
};

struct V {
    int v;
};
struct A {
    int a;
    static int s;
    enum { e };
};
struct B : A, virtual V {};
struct C : A, virtual V {};
struct D : B, C {};

void f(D &amp;pd) {
    ++pd.v;        // OK：只有一个 v，因为只有一个虚基类子对象
    ++pd.s;        // OK：只有一个静态的 A::s，即便在 B 和 C 中都找到了它
    int i = pd.e;  // OK：只有一个枚举符 A::e，即便在 B 和 C 中都找到了它
    ++pd.a;        // 错误，有歧义：B 中的 A::a 和 C 中的 A::a
}
</code></pre><blockquote><p>类的静态成员定义时，如果引用了<code class="language-plaintext highlighter-rouge">unqualified name</code>，其查找过程与类成员函数中<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找顺序相同</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>  <span class="c1">// 找到了 X::n，将 X::x 设置为 1 而不是 2</span>
</pre></table></code></div></div><blockquote><p>当一个类的友元函数被定义在类作用域内部时，该友元函数中引用的<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找顺序与该类的成员函数中的<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找顺序相同。当类的友元函数被定义在类作用域外部时，该友元函数中引用的<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找顺序与其所在命名空间的其他函数中的<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找顺序相同。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 3: 当1 2不存在时，f1中的"i"匹配此处</span>
            <span class="c1">// 3: 当1 2不存在时，f2中的"i"也不会匹配此处</span>
<span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 2: 当这句定义存在时，1不存在时，f1中的"i"匹配此处</span>
                            <span class="c1">// 2: 当1不存在时，f2中的"i"也不会匹配此处</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 1: 当这句定义存在时，f1中的"i"匹配此处</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 0: 友元函数f1(int)被定义在类X作用域内部时，"i"的查找顺序与X的成员函数查找顺序相同</span>
    <span class="p">}</span>
    <span class="k">friend</span> <span class="kt">int</span> <span class="nf">f2</span><span class="p">();</span>
    <span class="c1">// static const int i = 2; // ②移动到此处也OK</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 1: 当这句定义存在时，f2中的"i"匹配此处</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 0: 友元函数f2(int)被定义在类X作用域外部时，"i"的查找顺序f2(int)所在命名空间的普通函数的查找顺序相同</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>当一个类A的成员函数被声明为类B的友元，且该声明中包含<code class="language-plaintext highlighter-rouge">unqualified name</code>，则对<code class="language-plaintext highlighter-rouge">unqualified name</code>进行查找时：</p><ul><li>如果<code class="language-plaintext highlighter-rouge">unqualified name</code>不是任何模板的参数，则首先去类作用域A中进行查找<li>如果在类作用域A中未匹配或者其实模板参数，则去类作用域B中进行查找</ul></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// 这个类的成员函数被作为友元</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">AT</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">AT</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">f3</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// 这个类授予友元关系</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">char</span> <span class="n">AT</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">float</span> <span class="n">BT</span><span class="p">;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">f1</span><span class="p">(</span><span class="n">AT</span><span class="p">);</span>  <span class="c1">// 对 "AT" 的查找时，先到类作用域A中进行查找，匹配"A::AT"</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">f2</span><span class="p">(</span><span class="n">BT</span><span class="p">);</span>  <span class="c1">// 对 "BT" 的查找时，先到类作用域A中进行查找，未匹配，</span>
                            <span class="c1">// 再去类作用域B中查找，匹配"B::BT"</span>
    <span class="k">friend</span> <span class="kt">void</span>
    <span class="n">A</span><span class="o">::</span><span class="n">f3</span><span class="o">&lt;</span><span class="n">AT</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// 对 "AT" 的查找时，"AT"是模板参数，则直接去类作用域B中查找，匹配"B::AT"</span>
<span class="p">};</span>
</pre></table></code></div></div><blockquote><p><code class="language-plaintext highlighter-rouge">unqualified name</code>被当做函数默认参数时，查找其定义时，首先考虑同一函数声明中的形参:</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

   <span class="nl">public:</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">r</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>       <span class="c1">// 将 X::r 初始化为指代 X::a</span>
          <span class="n">b</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>       <span class="c1">// 将 X::b 初始化为形参 i 的值</span>
          <span class="n">i</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>       <span class="c1">// 将 X::i 初始化为形参 i 的值</span>
          <span class="n">j</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span>  <span class="c1">// 将 X::j 初始化为 X::i 的值</span>
    <span class="p">{}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// 错误：对 a 的查找找到了形参 a，而不是 ::a</span>
                          <span class="c1">// 但在默认实参中不允许使用形参</span>
</pre></table></code></div></div><blockquote><p>在枚举类定义时，<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找首先考虑当前枚举类的作用域</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">RED</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">color</span> <span class="p">{</span>
    <span class="n">RED</span><span class="p">,</span>
    <span class="n">GREEN</span> <span class="o">=</span> <span class="n">RED</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>  <span class="c1">// RED 找到了 color::RED ，而不是 ::RED ，因此 GREEN = 2</span>
    <span class="n">BLUE</span> <span class="o">=</span> <span class="o">::</span><span class="n">RED</span> <span class="o">+</span> <span class="mi">4</span>  <span class="c1">// 通过 qualified name lookup 找到 ::RED ， BLUE = 11</span>
<span class="p">};</span>
</pre></table></code></div></div><blockquote><p>在”try-catch”语句中，<code class="language-plaintext highlighter-rouge">unqualified name</code>的查找跟函数体内引用的<code class="language-plaintext highlighter-rouge">unqualified name</code>查找一样。平行的代码块内的定义不可见。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>          <span class="c1">// 3</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 2</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// 不会匹配到该处</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="c1">// int n = 1;   // 1: 加入此处存在，则匹配该处</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 0: n 按1 2 3的顺序进行依次查找，匹配f的参数n，即2</span>
        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>对于在表达式中所使用的重载运算符（比如在 <code class="language-plaintext highlighter-rouge">a+b</code> 中使用的 operator+），其查找规则和对在如<code class="language-plaintext highlighter-rouge">operator+(a,b)</code>这样的显式函数调用表达式中所使用的运算符是有所不同的：当处理表达式时要分别进行两次查找：对非成员的运算符重载，也对成员运算符重载（对于同时允许两种形式的运算符）。然后将这两个集合和在重载解析所述内建的运算符重载以平等的方式合并到一起。而当使用显式函数调用语法时（如<code class="language-plaintext highlighter-rouge">operator+(a,b)</code>），则进行常规的<code class="language-plaintext highlighter-rouge">unqualified name lookup</code>：</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
<span class="kt">void</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">);</span>  <span class="c1">// 用户定义的非成员 operator+</span>

<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>  <span class="c1">// 用户定义的成员 operator+</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">A</span> <span class="n">a</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">B</span><span class="o">::</span><span class="n">f</span><span class="p">()</span>  <span class="c1">// B 的成员函数定义</span>
<span class="p">{</span>
    <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// 错误：在成员函数中的常规名字查找</span>
                      <span class="c1">// 找到了 B 的作用域中的 operator+ 的声明</span>
                      <span class="c1">// 并于此停下，而不会达到全局作用域</span>
    <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>            <span class="c1">// OK：成员查找找到了 B::operator+，非成员查找</span>
                      <span class="c1">// 找到了 ::operator+(A,A)，重载决议选中了 ::operator+(A,A)</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="注入类名"><span class="mr-2">注入类名</span><a href="#注入类名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>在一个类作用域中，当前类的名称被当做公开的成员名一样对待 也就是说一个类的名字会以<strong>unqualified-name</strong>的形式，被注入到该类的作用域内。</p></blockquote><p>因此我们在类（类模板）的作用域内可以通过<strong>unqualified-name</strong>的形式来指代该类。然而，<strong>qualified-name</strong>的形式则不可以用来指代该类，因为这种形式被用来指代<em>构造函数</em>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">X</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">X</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// OK ： X</span>
               <span class="c1">// 指代注入类名，在"X"的作用域中，"X"被当做公开成员，注意体会这个"公开成员的含义"</span>
        <span class="o">::</span><span class="n">X</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>  <span class="c1">// 错误：在全局作用域"::"中，"struct X"被"int X"遮盖</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//-------------------------另外一个例子---------------------</span>
<span class="kt">int32_t</span> <span class="n">C</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
   <span class="nl">private:</span>
    <span class="kt">int64_t</span> <span class="n">i</span><span class="p">;</span>

   <span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">));</span>
        <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>  <span class="c1">// C is injeceted as an `unqualified-name`</span>
                           <span class="c1">// into the class scope</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;::</span><span class="n">C</span><span class="p">;</span>  <span class="c1">// '::C' refers to the global variable if it</span>
                        <span class="c1">// is qualified with '::'</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="kt">int32_t</span><span class="o">*&gt;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">k</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// auto p = &amp;C::C;</span>
        <span class="c1">// error: taking address of constructor 'constexpr C::C(C&amp;&amp;)'</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">size_t</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32_t</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>  <span class="c1">// f in not in the C class scope, thus 'C'</span>
                       <span class="c1">// refers to the global variable 'int32_t C'</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>在类继承的过程中，受到继承限制的控制</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">detail</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
    <span class="k">struct</span> <span class="nc">B</span> <span class="p">{};</span>
<span class="p">};</span>  <span class="c1">// namespace detail</span>

<span class="k">struct</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">detail</span><span class="o">::</span><span class="n">B</span><span class="p">,</span> <span class="k">private</span> <span class="n">detail</span><span class="o">::</span><span class="n">A</span> <span class="p">{};</span>

<span class="k">struct</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">a0</span><span class="p">;</span>  <span class="c1">// 错误：注入类名 A 受到“private”的修饰，变为非公开成员，不可访问</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">A</span><span class="o">*</span> <span class="n">a1</span><span class="p">;</span>  <span class="c1">// OK：不使用注入类名</span>
    <span class="n">B</span><span class="o">*</span> <span class="n">b0</span><span class="p">;</span>          <span class="c1">// OK：通过注入类名</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">B</span><span class="o">*</span> <span class="n">b1</span><span class="p">;</span>  <span class="c1">// OK：不使用注入类名</span>
<span class="p">};</span>
</pre></table></code></div></div><blockquote><p>在类模板中，类似普通类情形一样，可以被注入，当做模板名或者类型名。有下列3个情形之一时，注入的名称被当做当前模板名：</p><ul><li>它后面紧跟随 <code class="language-plaintext highlighter-rouge">&lt;</code> 符号（模板实例化标识）<li>它被当做一个模板模板参数(<code class="language-plaintext highlighter-rouge">template template parameter</code>)<li>它是友元类模板声明的详细类型指定符中的最后标识符。 此外其他情形，会被当做一个实际类类型被注入，其类型为该类模板实例化后的类型。</ul></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 注意体会这个例子</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="p">,</span> <span class="k">class</span><span class="p">&gt;</span> <span class="k">class</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;*</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// X后跟随"&lt;"，则X被当做模板 template&lt;class, class&gt; struct X 对待</span>
                   <span class="c1">// 同理，此处改为 X&lt;int, int&gt; *p 也是成立的，因为X是一个模板</span>
    <span class="k">using</span> <span class="n">a</span> <span class="o">=</span>
        <span class="n">A</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// X被当做模板A的模板模板参数，则X被当做模板 template&lt;class, class&gt; struct X 对待</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U2</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="k">class</span>
        <span class="nc">X</span><span class="p">;</span>  <span class="c1">// X被当友元模板类的标识符，则X被当做模板 template&lt;class, class&gt; struct X 对待，即::X</span>
            <span class="c1">// 此处含义为，当模板X实例化后，X&lt;T1,T2&gt;拥有友元X&lt;U1,U2&gt;，X&lt;U1,U2&gt;可以被实例化为多个类型</span>
    <span class="n">X</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>  <span class="c1">// 此处为以上三种情形之外，X被当做了一个实例化的类型名，其类型为X&lt;T1,T2&gt;。</span>
           <span class="c1">// 当X&lt;T1,T2&gt;被实例为X&lt;int,int&gt;时，q的类型为`X&lt;int,int&gt; *`</span>
           <span class="c1">// 当X&lt;T1,T2&gt;被实例为X&lt;double,double&gt;时，q的类型为`X&lt;double,double&gt; *`</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="adl实参依赖查找"><span class="mr-2">ADL实参依赖查找</span><a href="#adl实参依赖查找" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ADL主要适用于对<strong>unqualified-name</strong>的<strong>函数</strong>进行的名字查找。查找对象是一个在进行函数调用或者运算符调用的<strong>非成员函数</strong>。换句话说，ADL依据函数调用中的实参的数据类型查找未限定（unqualified）的函数名（或者函数模板名）。</p><h4 id="哪些不触发adl"><span class="mr-2">哪些不触发ADL</span><a href="#哪些不触发adl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>如果通常的未限定（unqualified）名字查找所产生的候选集包括下述情形，则不会启动依赖于实参的名字查找（ADL查找不会进行）：</p><blockquote><p>1.类成员声明（此种情形仅指普通的类成员函数，不指类成员运算符函数）</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">XA</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XA</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 在这里，可以通过ADL来找到xx::foo</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="nc">YA</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">foo</span><span class="p">;</span>
        <span class="k">static</span> <span class="kt">void</span> <span class="n">test</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
            <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 在这里，由于通过unqualified name lookup找到了</span>
                      <span class="c1">// 成员变量int foo，所以不会进行ADL，因此会出错</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>2.块作用域内的<strong>函数</strong>的声明，<strong>不含(using-declaration)</strong></p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
<span class="k">struct</span> <span class="nc">XA</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XA</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">zz</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"zz::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace zz</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// 1</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 此处正常进行ADL，不受到外部声明1的影响 因为1不在块作用域内</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">zz</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// 2</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 此处正常进行ADL，不受声明2的影响 因为2使用了using declaration</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>  <span class="c1">// 3</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// ERROR 此处由于该块作用域内中有不含using的声明，则不会进行ADL，所以会报错</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>3.<strong>任何不是函数或者函数模板的声明（例如函数对象或者另一个变量其名字与被查询的函数名字冲突）</strong></p><p><strong>注意，这个是CPO的要点。</strong></p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">XA</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XA</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">zz</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">foo_callable</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">xx</span><span class="o">::</span><span class="n">XA</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"zz::foo functor called for xx::XA"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">foo_callable</span> <span class="n">foo</span><span class="p">{};</span> <span class="c1">// 全局可用的CPO实例</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 　一切正常</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">zz</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// 由于该处声明，引入的是一个函数对象，则1处不会进行ADL，而是直接调用zz::foo</span>
        <span class="c1">// 去掉这个这正常调用xx::foo</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 1</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">yy</span><span class="o">::</span><span class="n">test1</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>4.当调用的函数被括号包围时</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">XA</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XA</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>  <span class="c1">// namespace xx</span>
<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// OK，此处进行ADL</span>
        <span class="p">(</span><span class="n">foo</span><span class="p">)(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// ERROR，由于foo被括号包围，故不进行ADL，这条规则在文档中没有提及，</span>
                    <span class="c1">// 不知道应该被归属于哪一条，所以单独拿出来。</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><h4 id="adl的查找范围"><span class="mr-2">ADL的查找范围</span><a href="#adl的查找范围" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>函数调用表达式</strong>的每个实参的<strong>类型</strong>用于<strong>确定</strong>命名空间与类的相关集合（associated set of namespaces and classes）并用于函数名字查找（这句话的意思简而言之就是<strong>ADL查找的集合范围如何确定</strong>）：</p><blockquote><p>1.基本类型（fundamental type）实参的命名空间与类的相关集合为空。</p></blockquote><p>这个的意思是，当参数的类型是基本类型时（例如 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">double</code> 等），ADL 的处理方式如下：</p><ol><li><strong>基本类型的命名空间和类集合为空</strong>：<ul><li>当 ADL 处理一个基本类型（如 <code class="language-plaintext highlighter-rouge">int</code>）的参数时，它不会将任何命名空间或类添加到与该类型相关联的查找集合中。基本类型不属于任何用户定义的命名空间或类，因此它们的关联命名空间和类集合为空。</ul><li><strong>ADL 对基本类型不起作用</strong>：<ul><li>由于基本类型没有相关的命名空间或类，因此 ADL 不会基于这些类型查找到任何附加的函数定义。换句话说，当函数参数是基本类型时，ADL 不会帮助找到在某个特定命名空间中定义的函数。</ul></ol><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>如果参数的命名空间为空，将其添加到查找集合内，但是查找时，会直接跳过空集。
</pre></table></code></div></div><blockquote><p>2.类类型（class type，指struct，class，union类型），相关集合包括</p><ol><li>类类型自身；<li>该类型的所有的直接或间接基类；<li>如果类类型 T 是另一个类 G 的成员（嵌套类型），则那个包含了类类型 T 的类 G；<li>该类类型的所有相关类的最内层外围命名空间。</ol></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">ADL</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func2</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">func1</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2.1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">struct</span> <span class="nc">B</span> <span class="p">{};</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">func3</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2.3"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">func4</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2.4"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>  <span class="c1">// namespace ADL</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ADL</span><span class="o">::</span><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">ADL</span><span class="o">::</span><span class="n">A</span><span class="o">::</span><span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">func1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 2.1</span>
    <span class="n">func2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 2.2</span>
    <span class="n">func3</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// 2.3</span>
    <span class="n">func4</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 2.4</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>3.如果实参是<a href="https://zh.cppreference.com/w/cpp/language/class_template">类模板</a>特化后得到的类型，在上述规则外，还检验下列规则，并添加其关联类与命名空间到集合：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>1. 类型模板形参（type template parameter）所对应的**模板实参**的类型，不包括非类型的模板形参、模板模板形参； 
1. 模板模板实参（template template argument）所在的命名空间； 
1. 模板模板实参所在的类（如果这个类包含了这个成员模板）。
1. 对于枚举类型的实参，添加枚举类型所在的命名空间到集合。如果枚举类型是一个类的成员类型，则添加该类到集合。
</pre></table></code></div></div></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">XType</span> <span class="p">{</span>
        <span class="n">XTypeA</span><span class="p">,</span>
        <span class="n">XTypeB</span><span class="p">,</span>
        <span class="n">XTypeC</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XType</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 4"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="n">AType</span> <span class="p">{</span>
            <span class="n">ATypeA</span><span class="p">,</span>
            <span class="n">ATypeB</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">foo1</span><span class="p">(</span><span class="n">AType</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 41"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span> <span class="n">foo</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">XTypeA</span><span class="p">);</span> <span class="p">}</span>      <span class="c1">// ADL</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span> <span class="p">{</span> <span class="n">foo1</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">::</span><span class="n">ATypeA</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// ADL</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>5.如果实参是类型 T 的指针或者是类型 T 的数组的指针，则检验类型 T 并添加其类与命名空间的关联集到集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">foo1</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 6.1.1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="n">A</span> <span class="n">x</span><span class="p">[])</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 6.1.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">foo3</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 6.2.1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">foo4</span><span class="p">(</span><span class="n">A</span> <span class="n">x</span><span class="p">[])</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo 6.2.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">A</span> <span class="n">aa</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">foo1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// ADL</span>
        <span class="n">foo2</span><span class="p">(</span><span class="n">aa</span><span class="p">);</span>  <span class="c1">// ADL</span>
        <span class="n">foo3</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// ADL</span>
        <span class="n">foo4</span><span class="p">(</span><span class="n">aa</span><span class="p">);</span>  <span class="c1">// ADL</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>6.如果实参是函数类型，那么检验函数参数类型与函数返回值类型，并添加其类与命名空间的关联集到集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
    
    <span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
    
    <span class="n">A</span> <span class="nf">func2</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">lookup1</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">A</span><span class="o">&amp;</span><span class="p">))</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx:lookup1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="kt">void</span> <span class="nf">lookup2</span><span class="p">(</span><span class="n">A</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)())</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx:lookup2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lookup1</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">func1</span><span class="p">);</span>  <span class="c1">// ok</span>
        <span class="n">lookup2</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">func2</span><span class="p">);</span>  <span class="c1">// ok</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>7.如果实参是类 X 的成员函数 F 的指针类型参数，那么该成员函数的形参类型、该成员函数返回值的类型、该成员函数所属类 X 的相关集合都被加入到关联集到集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">B</span><span class="p">;</span>
<span class="p">}</span><span class="err">　</span><span class="c1">// namespace x</span>

<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="n">x</span><span class="o">::</span><span class="n">B</span><span class="o">*</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">ff</span><span class="p">(</span><span class="n">x</span><span class="o">::</span><span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="k">friend</span> <span class="kt">void</span> <span class="n">lookup1</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">::*</span><span class="n">f</span><span class="p">)())</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::lookup1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">lookup2</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::lookup2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace x</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">lookup1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">::</span><span class="n">f</span><span class="p">);</span>  <span class="c1">// ok</span>
        <span class="n">lookup1</span><span class="p">(</span>
            <span class="nb">nullptr</span><span class="p">);</span>  <span class="c1">// failed，因为这条规则标明的是实参，此处实参是nullptr，则不会查找到对应的lookup1</span>
        <span class="n">lookup2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">::</span><span class="n">ff</span><span class="p">);</span>  <span class="c1">// ok</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>
</pre></table></code></div></div><blockquote><p>8.如果实参是类 X 的数据成员 T 的指针类型参数，那么该成员类型、该数据成员所属类 X 的相关集合都被加入到关联集到集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">lookup1</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="o">::*</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x::lookup1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span> <span class="n">lookup1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">::</span><span class="n">num</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// ok</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">yy</span><span class="o">::</span><span class="n">test0</span><span class="p">();</span> <span class="p">}</span>
</pre></table></code></div></div><blockquote><p>9.若参数是<a href="https://zh.cppreference.com/w/cpp/language/overloaded_address">重载函数集的取址表达式</a>（或对函数模板）的名称，则检验重载集中的每个元素，并添加其类与命名空间的关联集到集合。 1. 另外，若重载集为模板 id （带模板实参的模板名），则检验其所有类型模板实参与模板模板实参（但不含非类型模板实参），并添加其类与命名空间的关联集到集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">void</span> <span class="nf">lookup1</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x::lookup1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{};</span>                   <span class="c1">// ①</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span><span class="o">*</span><span class="p">)</span> <span class="p">{};</span>             <span class="c1">// ②</span>
    <span class="kt">void</span> <span class="nf">test0</span><span class="p">()</span> <span class="p">{</span> <span class="n">lookup1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// ok，由于重载f②的存在，namespace xx也被加入到ADL的集合中</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">yy</span><span class="o">::</span><span class="n">test0</span><span class="p">();</span> <span class="p">}</span>
</pre></table></code></div></div><blockquote><p>10.如果相关集合中的任何命名空间是<a href="https://zh.cppreference.com/w/cpp/language/namespace">内联命名空间</a>（inline namespace）, 则添加其外围命名空间到关联集合。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">adl</span> <span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">inner</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
    <span class="p">}</span>  <span class="c1">// namespace inner</span>

    <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">inner</span><span class="o">::</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"enclosed namespace added."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace adl</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">adl</span><span class="o">::</span><span class="n">inner</span><span class="o">::</span><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 因为 adl::inner 为 inline namespace，则将其最内存外围 namespace adl</span>
              <span class="c1">// 到查找关联集合中，则可以查找到 adl::func</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>11.如果相关集合中的一个命名空间直接包含了内联命名空间，则内联命名空间被增加到相关集合中。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">adl</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">inner</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"inline namespace added."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>  <span class="c1">// namespace inner</span>
<span class="p">}</span>  <span class="c1">// namespace adl</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">adl</span><span class="o">::</span><span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// namespace adl中包含 inline namespace adl::inner，</span>
              <span class="c1">// 则将 adl::inner 添加到查找关联集合中，则可以查找到 adl::inner::func</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>12.在确定命名空间与类的关联集后，为了进一步的 ADL 处理，<strong>忽略</strong>此集中所有于类中找到的<strong>声明</strong>，除了命名空间作用域的友元函数及函数模板，陈述于后述点2。以下列特殊规则，合并普通<a href="https://zh.cppreference.com/w/cpp/language/lookup">无限定查找</a>找到的声明集合，与在 ADL 所生成关联集的所有元素中找到的声明集合:</p><ol><li>忽略关联命名空间中的 <a href="https://zh.cppreference.com/w/cpp/language/namespace#using_.E6.8C.87.E4.BB.A4">using 指令</a><li>声明于关联类中的命名空间作用域友元函数（及函数模板）通过 ADL 可见，即使它们通过普通查找不可见。<li>忽略函数与函数模板外的所有名称（与变量不冲突）</ol></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">A</span><span class="p">;</span>
<span class="p">}</span><span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">x</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">xx</span><span class="o">::</span><span class="n">A</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x::f"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace x</span>

<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// 1</span>
    <span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">A</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
        <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// not ok, ADL时忽略1处using指令</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="n">yy</span><span class="o">::</span><span class="n">test0</span><span class="p">();</span> <span class="p">}</span>
</pre></table></code></div></div><blockquote><p>通过 ADL 查找到的<code class="language-plaintext highlighter-rouge">name</code>会和前面<code class="language-plaintext highlighter-rouge">unqualified name</code>普通查找到的合并到一起进行选择，如果存在歧义，会报错。</p></blockquote><p>ADL的核心是: <strong>在调用<em>函数</em>的时候，只要有一个参数的类型属于函数所在的命名空间，那么调用的时候就不用加命名空间前缀</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="nc">Empty</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">Empty</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 必须这么调用，foo(2)找不到A里面的foo</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">Empty</span><span class="p">{},</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// 因为第一参数的类型在A中，foo前面不用再加前缀</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// 等价于operator&lt;&lt; (std::cout, 1)</span>
    <span class="c1">// 由于ADL，可以找到std中的std::operator&lt;&lt; (std::ostream&amp;, int)</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="cpo-定制点对象"><span class="mr-2">CPO 定制点对象</span><a href="#cpo-定制点对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们在ADL中的不触发ADL的第三点中提到了CPO的关键要素。CPO本质上，就是一个<strong>能够正确解决复杂定制问题的functor对象</strong>。为了解决这个问题，我们需要屏蔽掉ADL调用。也就是说，我们把ADL的<strong>两步式（先using引入，再非限定调用）</strong>放到了定制点对象内部进行。而在外部我们并不使用ADL。</p><ol><li>它能够在编译期对于简单的无限定调用，根据实参的不同情况进行判断，并转发到正确的实现；<li>它能够检查实参与ADL重载（若存在）是否符合语法要求，并在需要的时候报错。</ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">special</span><span class="p">{};</span>
<span class="k">namespace</span> <span class="n">mystd</span><span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"foo(T)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">yb</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">myclass</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">myclass</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yb::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yb</span>

<span class="k">namespace</span> <span class="n">xx</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">XA</span> <span class="p">{};</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">XA</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"xx::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace xx</span>

<span class="k">namespace</span> <span class="n">yy</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yy::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">test0</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 　一切正常</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="n">zz</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">foo_callable</span> <span class="p">{</span>
            <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
            <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Args</span> <span class="o">&amp;&amp;</span><span class="p">...</span><span class="n">args</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
                <span class="c1">// using xx::foo;</span>
                <span class="c1">// using yb::foo;</span>
                <span class="c1">// using yy::foo;</span>
                <span class="c1">// 不用任何的using。因为我们传入的参数的namespace里都有一个叫foo的。所以正常ADL会找到的。</span>
                <span class="k">using</span> <span class="n">mystd</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span> <span class="c1">// 这个using是模拟swap例子里的using。</span>
                <span class="c1">// 使用这个using的原因是mystd里面没有special这个成员。所以ADL也找不到。</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"zz::foo"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
                <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>  <span class="c1">// 正常ADL</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="n">foo_callable</span> <span class="n">foo</span><span class="p">{};</span>  <span class="c1">// 全局可用的CPO实例</span>
    <span class="p">}</span>  <span class="c1">// namespace zz</span>

    <span class="kt">void</span> <span class="nf">test1</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">zz</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>  <span class="c1">// 由于该处声明，引入的是一个函数对象，则1处不会进行ADL，而是直接调用zz::foo</span>
        <span class="n">xx</span><span class="o">::</span><span class="n">XA</span> <span class="n">xa</span><span class="p">;</span>
        <span class="n">yb</span><span class="o">::</span><span class="n">myclass</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">xa</span><span class="p">);</span>  <span class="c1">// 1</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>   <span class="c1">// 2</span>
        <span class="n">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// 3</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">special</span><span class="p">{});</span> <span class="c1">// 4</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace yy</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">yy</span><span class="o">::</span><span class="n">test1</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>参考资料</p><p><a href="https://www.zhihu.com/question/518132411/answer/2360830245">定制点对象</a></p><p><a href="https://xyfu.me/posts/8f07748/">标识符、名字查找与实参依赖查找(ADL)</a></p><p><a href="https://lrita.github.io/2018/09/29/name-lookup-in-cpp11/#qualified-name-lookup">C++11中的name lookup</a></p><p><a href="https://zclll.com/index.php/cpp/cpo_niebloid.html">定制点对象和ADL</a></p><p><a href="https://quuxplusone.github.io/blog/2021/12/07/namespace-cpo/">O’Dwyer的介绍</a></p><h1 id="整理c的三种名称查找方式">整理C++的三种名称查找方式</h1><div class="table-wrapper"><table><thead><tr><th><strong>查找类型</strong><th><strong>触发形式</strong><th><strong>搜索范围</strong><th><strong>适用场景</strong><tbody><tr><td>限定名称查找 Qualified<td><code class="language-plaintext highlighter-rouge">a::b::x</code><td>仅 <code class="language-plaintext highlighter-rouge">::</code> 左侧指定作用域<td>精确控制符号来源<tr><td>非限定名称查找 Unqualified<td><code class="language-plaintext highlighter-rouge">x</code><td>由内向外逐层作用域<td>局部变量、类成员、全局量<tr><td>参数依赖查找 (ADL)<td><code class="language-plaintext highlighter-rouge">func(arg)</code><td>常规作用域 + <strong>参数类型命名空间</strong><td>函数调用（尤其运算符）</table></div><p>来自<a href="https://www.sandordargo.com/blog/2025/05/28/three-ways-of-name-lookups">参考</a></p><h1 id="不要重新打开std空间并且往里塞东西">不要重新打开std空间并且往里塞东西</h1><p>比如如何正确的特化<code class="language-plaintext highlighter-rouge">std::hash</code></p><p>不要这样</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{};</span>

<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>  <span class="c1">// Danger!</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">hash</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>要这样</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>参考<a href="https://quuxplusone.github.io/blog/2021/10/27/dont-reopen-namespace-std/">这里</a></p><h1 id="翻译单元">翻译单元</h1><p>在C++中，翻译单元指的是编译器处理的最小独立单元，通常对应一个源文件（<code class="language-plaintext highlighter-rouge">.cpp</code>或<code class="language-plaintext highlighter-rouge">.c</code>文件）以<strong>及其包含的所有头文件</strong>。具体来说，一个翻译单元包括以下内容：</p><ul><li>源代码文件自身的内容<li>源代码文件中<code class="language-plaintext highlighter-rouge">#include</code>的所有头文件（Header Files）的内容，这些头文件在预处理阶段会被展开替换到源文件中<li>宏定义（Macro Definitions）以及其他预处理器指令产生的文本替换</ul><p>在编译过程中，每个源代码文件都会形成一个独立的翻译单元，编译器对每个翻译单元独立进行词法分析、语法分析、语义分析等编译步骤，最后生成对应的<code class="language-plaintext highlighter-rouge">.o</code>（对象文件）或<code class="language-plaintext highlighter-rouge">.obj</code>（在Windows系统中）。链接器随后会把这些独立的翻译单元链接起来，形成可执行文件或库文件。</p><h1 id="stdstring-的不同编译器实现和比较">std::string 的不同编译器实现和比较</h1><p>https://devblogs.microsoft.com/oldnewthing/20240510-00/?p=109742Y3MOtw0Q:1716181180316&amp;q=cpp+weekly&amp;spell=1&amp;sa=X&amp;ved=2ahUKEwiLy_2MuZuGAxXha_UHHet8BmoQBSgAegQICBAB&amp;biw=1920&amp;bih=919&amp;dpr=1</p><h1 id="tcmalloc">TCMalloc</h1><p>http://blog.gerryyang.com/linux%20performance/2022/08/07/tcmalloc-in-action.html</p><h1 id="stdoptional-c17">std::optional （C++17)</h1><p>可选返回值的一个类型。要么有值要么没值。<strong>就是一个和bool一起打包的包装器</strong></p><p>一个大概示例</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">optional</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">_initialized</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">aligned_storage_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">_storage</span><span class="p">;</span>
<span class="nl">public:</span> 
<span class="c1">// operations </span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="初始化及简单实用示例"><span class="mr-2">初始化及简单实用示例</span><a href="#初始化及简单实用示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">//初始化为空</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">emptyInt</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">emptyDouble</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="c1">//直接用有效值初始化</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intOpt</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span> <span class="n">intOptDeduced</span><span class="p">{</span><span class="mf">10.0</span><span class="p">};</span> <span class="c1">// auto deduced</span>
<span class="c1">//使用make_optional</span>
<span class="k">auto</span> <span class="n">doubleOpt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="mf">10.0</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">complexOpt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>
<span class="c1">//使用in_place 后文会提到</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">complexOpt</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">in_place</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vectorOpt</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">in_place</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>
<span class="c1">//使用其它optional对象构造</span>
<span class="k">auto</span> <span class="n">optCopied</span> <span class="o">=</span> <span class="n">vectorOpt</span><span class="p">;</span>
</pre></table></code></div></div><p>简单使用</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">find_index</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span> <span class="c1">// 注意这个 也可以直接返回{}</span>
    <span class="c1">// std::nullopt 是 std::nullopt_t 类型的常量，用于指示 optional 不含值。</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="n">myvec</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="n">myvec</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// 判断是否有值方法1</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 获取值方法1</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">// 获取值方法2</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 判断是否有值方法2</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">optional</code> 对象在下列条件下<em>含值</em>：</p><ul><li>对象被以 <code class="language-plaintext highlighter-rouge">T</code> 类型的值或另一<em>含值</em> ﻿的 <code class="language-plaintext highlighter-rouge">optional</code> 初始化/赋值。</ul><p>对象在下列条件下<em>不含值</em>：</p><ul><li>对象被默认初始化。<li>对象被以 <a href="https://zh.cppreference.com/w/cpp/utility/optional/nullopt_t">std::nullopt_t</a> 类型的值或<em>不含值</em> ﻿的 <code class="language-plaintext highlighter-rouge">optional</code> 对象初始化/赋值。<li>调用了成员函数 <a href="https://zh.cppreference.com/w/cpp/utility/optional/reset">reset()</a>。</ul><h2 id="部分成员函数"><span class="mr-2">部分成员函数</span><a href="#部分成员函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>emplace()<ul><li>原位构造<ul><li>如果之前已含值，则先销毁再构造</ul></ul><li>reset()<ul><li>销毁值。</ul><li>swap()<ul><li>交换值<li>如果交换一个空值，则销毁原有值</ul></ul><h2 id="比较大小"><span class="mr-2">比较大小</span><a href="#比较大小" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对于定义了<code class="language-plaintext highlighter-rouge">&lt;</code>，<code class="language-plaintext highlighter-rouge">&gt;</code>，<code class="language-plaintext highlighter-rouge">==</code>操作符的类型，保存他们的<code class="language-plaintext highlighter-rouge">optional</code>对象也可以比较大小。如<code class="language-plaintext highlighter-rouge">optional&lt;int&gt;</code>之间比较大小和直接比较<code class="language-plaintext highlighter-rouge">int</code>数值的大小是一样的。<strong>比较特殊的是<code class="language-plaintext highlighter-rouge">std::nullopt</code>，在比较大小时，它总小于存储有效值的<code class="language-plaintext highlighter-rouge">optional</code>对象。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int2</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int3</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">int1</span> <span class="o">&lt;</span> <span class="n">int2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// true</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">int2</span> <span class="o">&gt;</span> <span class="n">int1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// true</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">int3</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// true</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">int3</span> <span class="o">&lt;</span> <span class="n">int1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// true</span>

</pre></table></code></div></div><h2 id="为什么需要make_optional-和stdin_place"><span class="mr-2">为什么需要make_optional 和std::in_place</span><a href="#为什么需要make_optional-和stdin_place" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先我们需要注意一点：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myclass</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">myclass</span><span class="p">()</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">mInt</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">myclass2</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">myclass2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myclass2</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass2</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">mInt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myclass2</span><span class="p">(</span><span class="n">myclass2</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">mInt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"move constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mInt</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">myclass3</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">myclass3</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myclass3</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass3</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">mInt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myclass3</span><span class="p">(</span><span class="n">myclass3</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">mInt</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">mInt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"move constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">mInt</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">sample</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">sample2</span><span class="p">{};</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// false</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample2</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">// false</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>注意，在这个情况下，这两种方法得到的结果都只是空的optional对象，而不是包含默认构造值的对象。</strong></p><p>所以此时， 我们可以这么写：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">sample3</span><span class="p">{</span><span class="n">myclass</span><span class="p">()};</span>
</pre></table></code></div></div><p>这种方法是可以工作的，我们将得到包含默认<code class="language-plaintext highlighter-rouge">myclass</code>对象的<code class="language-plaintext highlighter-rouge">optional</code>对象。但是在上面的代码中，将先构造出一个<code class="language-plaintext highlighter-rouge">myclass</code>的临时对象，然后临时对象被移入optional存储的对象中，带来了额外的开销。在这种情况下，我们就可以使用<code class="language-plaintext highlighter-rouge">std::in_place_t</code> / <code class="language-plaintext highlighter-rouge">std::make_optional</code>来“原地”构造optional底层存储的对象。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">sample4</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">in_place</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample4</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// true</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample4</span><span class="o">-&gt;</span><span class="n">mInt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 100</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">sample5</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_optional</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample5</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">// true</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sample5</span><span class="o">-&gt;</span><span class="n">mInt</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 100</span>
</pre></table></code></div></div><p>我们再继续看例子，</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass2</span><span class="o">&gt;</span> <span class="n">sample6</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">in_place</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">//1 OK</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass2</span><span class="o">&gt;</span> <span class="n">sample7</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="c1">//2 不OK</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass2</span><span class="o">&gt;</span> <span class="n">sample81</span><span class="p">;</span> <span class="c1">//3 OK 但是有拷贝</span>


<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass3</span><span class="o">&gt;</span> <span class="n">sample9</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">in_place</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">//4 OK</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myclass3</span><span class="o">&gt;</span> <span class="n">sample10</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">//5 OK</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>构造函数<th>编号<th>版本起<tbody><tr><td>constexpr optional() noexcept; <br />constexpr optional( std::nullopt_t]) noexcept;<td>(1)<td>(C++17 起)<tr><td>constexpr optional( const optional&amp; other );<td>(2)<td>(C++17 起)<tr><td>constexpr optional( optional&amp;&amp; other ) noexcept(<em>/* 见下文 */</em>);<td>(3)<td>(C++17 起)<tr><td> <td>(4)<td> <tr><td>template &lt; class U &gt; <br />optional( const optional<u>&amp; other );</u><td>(C++17 起) (C++20 前) (条件性 <code class="language-plaintext highlighter-rouge">explicit</code>)<td> <tr><td>template &lt; class U &gt; <br />constexpr optional( const optional<u>&amp; other );</u><td>(C++20 起) (条件性 <code class="language-plaintext highlighter-rouge">explicit</code>)<td> <tr><td> <td>(5)<td> <tr><td>template &lt; class U &gt; <br />optional( optional<u>&amp;&amp; other );</u><td>(C++17 起) (C++20 前) (条件性 <code class="language-plaintext highlighter-rouge">explicit</code>)<td> <tr><td>template &lt; class U &gt; <br />constexpr optional( optional<u>&amp;&amp; other );</u><td>(C++20 起) (条件性 <code class="language-plaintext highlighter-rouge">explicit</code>)<td> <tr><td>template&lt; class… Args &gt; <br />constexpr explicit optional( std::in_place_t, Args&amp;&amp;… args );<td>(6)<td>(C++17 起)<tr><td>template&lt; class U, class… Args &gt; <br />constexpr explicit optional( std::in_place_t, std::initializer_list<u> ilist, Args&amp;&amp;... args );</u><td>(7)<td>(C++17 起)<tr><td>template &lt; class U = T &gt; <br />constexpr optional( U&amp;&amp; value );<td>(8)<td>(C++17 起) (条件性 <code class="language-plaintext highlighter-rouge">explicit</code>)</table></div><p>第一个可以的原因是使用了<code class="language-plaintext highlighter-rouge">std::in_place</code>标签，匹配到了第6个构造函数</p><p>第二个不可以的原因是<code class="language-plaintext highlighter-rouge">std::optional</code>没有一个支持不带标签的同时是多参数的构造函数。</p><p>第三个可以的原因是因为额外加了花括号初始化，先初始化成<code class="language-plaintext highlighter-rouge">myclass2</code>对象然后拷贝，匹配的是第8个构造函数</p><p>第四个可以的原因是使用了标签。匹配到了第六个构造函数</p><p>第五个可以的原因是因为是单参数，所以匹配到了第八个构造函数。</p><p>所以， 针对不可拷贝或移动的对象，就必须使用<code class="language-plaintext highlighter-rouge">in_place</code>了</p><h3 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>核心来讲，有三个作用：</p><ol><li>区分到底是用<code class="language-plaintext highlighter-rouge">optional&lt;T&gt;</code>的默认构造函数还是<code class="language-plaintext highlighter-rouge">T</code>的默认构造函数。<ul><li>(参见<a href="https://link.zhihu.com/?target=http%3A//www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3527.html%23rationale.emplace">N3527</a>，<code class="language-plaintext highlighter-rouge">in_place_t</code>原本的名字是<code class="language-plaintext highlighter-rouge">emplace</code>。来自<a href="https://blog.csdn.net/yihuajack/article/details/117780569">这里</a> 和 <a href="https://stackoverflow.com/questions/49767940/why-do-stdoptional-constructors-use-stdin-place">这里</a>）</ul><li>允许原地构造需要多个入参的对象。<li>让不可拷贝或移动的对象也可以使用<code class="language-plaintext highlighter-rouge">optional</code></ol><p><code class="language-plaintext highlighter-rouge">std::inplace</code>在<code class="language-plaintext highlighter-rouge"> std::any</code> , <code class="language-plaintext highlighter-rouge">std::variant</code>等中亦有同样作用</p><p>所以如下代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">maybe</span><span class="p">(</span><span class="kt">bool</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// return myobj(10); // 一次构造+一次移动+一次析构 性能差</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//直接转发给optional，多参可以make_optional/in_place 性能好</span>

<span class="p">}</span>
</pre></table></code></div></div><p>第二种写法性能更好。来自<a href="https://felipe.rs/2021/09/19/std-optional-and-non-pod-types-in-cpp/">这里</a></p><h2 id="关于为什么需要nullopt"><span class="mr-2">关于为什么需要nullopt</span><a href="#关于为什么需要nullopt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://stackoverflow.com/questions/62933403/why-do-we-need-stdnullopt</p><p>部分参考：</p><p>https://blog.csdn.net/hhdshg/article/details/103433781</p><h2 id="如何往optional里面放入不可构造不可移动不可拷贝的对象"><span class="mr-2">如何往optional里面放入不可构造、不可移动、不可拷贝的对象？</span><a href="#如何往optional里面放入不可构造不可移动不可拷贝的对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://devblogs.microsoft.com/oldnewthing/20241115-00/?p=110527</p><p>https://github.com/wanghenshui/cppweeklynews/blob/dev/posts/173.md</p><p>有点复杂但又不那么复杂。</p><h2 id="optional移出元素需要注意的点"><span class="mr-2">optional移出元素需要注意的点</span><a href="#optional移出元素需要注意的点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>假设我有这种代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">myobj</span> <span class="nf">do_something</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">opt</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"--"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">opt</span><span class="p">;</span> <span class="c1">// 和opt.value()一样。不过现在会拷贝</span>
<span class="p">}</span>
<span class="n">myobj</span> <span class="nf">do_something2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">opt</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"--"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">value</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">do_something</code>会拷贝。假设<code class="language-plaintext highlighter-rouge">myobj</code>很大，又有不必要开销。我们自然会想要<code class="language-plaintext highlighter-rouge">do_something2</code>的方法，利用移动。但是我们到底应该移动什么？<strong>移动<code class="language-plaintext highlighter-rouge">optional</code>里面的<code class="language-plaintext highlighter-rouge">value</code>还是移动<code class="language-plaintext highlighter-rouge">optional</code>本身？</strong></p><p>假设这种情况：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">dummy</span><span class="p">(</span><span class="n">myobj</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"dummy"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">do_something3</span><span class="p">(</span><span class="kt">bool</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">opt</span><span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dummy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">value</span><span class="p">()));</span> <span class="c1">// opt.value，也就是myobj本身是垃圾值了</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">opt</span><span class="p">.</span><span class="n">has_value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// opt含值</span>
    <span class="c1">// 过了很久，插入一堆其他逻辑</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dummy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opt</span><span class="p">.</span><span class="n">value</span><span class="p">()));</span> <span class="c1">// 出问题了，move了两次</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们这时候移动的是<code class="language-plaintext highlighter-rouge">optional</code>包裹的值。请注意。第一次移动后，<code class="language-plaintext highlighter-rouge">optional</code>包裹的值可能是垃圾无效值。但是<code class="language-plaintext highlighter-rouge">optional</code>本身是含值的，所以我们就算判断<code class="language-plaintext highlighter-rouge">has_value</code>也无法解决这个问题。<strong>所以我们真正要做的应该是<code class="language-plaintext highlighter-rouge">move</code>这个<code class="language-plaintext highlighter-rouge">optional</code>本身。然后<code class="language-plaintext highlighter-rouge">move</code>后进行<code class="language-plaintext highlighter-rouge">reset</code>。</strong></p><p><a href="https://stackoverflow.com/questions/51805059/why-does-moving-stdoptional-not-reset-state">为什么optional不能像unique_ptr支持移动后自动重置状态?</a></p><p>一些关于这篇<a href="https://blog.tal.bi/posts/std-optional-move-pitfall">胡扯博客</a>的<a href="https://www.reddit.com/r/cpp/comments/1ju89ie/beware_when_moving_a_stdoptional/">讨论</a></p><h1 id="stdany">std::any</h1><p><strong>any就是一个包装任意类型的包装器</strong></p><p>std::any的libstdc++和msvc的内部实现细节差异挺大的。但是换汤不换药。</p><ul><li>msvc的代码分析在<a href="https://blog.csdn.net/haokan123456789/article/details/139158787">这里</a><li>libstdc++的源码在<a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/any">这里</a><li>any_cast为什么可以不用RTTI在<a href="https://stackoverflow.com/questions/51361606/stdany-without-rtti-how-does-it-work">这里</a><ul><li>其实说白了就是构造的时候有一个对应类型的manager。每个manager有个静态的函数模板。每一个类型自然有自己的独有一份合成的函数示例。然后比较类型的时候只需要比较函数地址就可以了。因为如果类型相同，则对应的manager函数的地址也相同。如果没有或者是不同的话自然就炸了。</ul></ul><h1 id="stdtuple的实现解析">std::tuple的实现解析</h1><p>https://mcyoung.xyz/2022/07/13/tuples-the-hard-way/</p><h2 id="tuple-的-make_tuple-和-构造函数的一个细微区别"><span class="mr-2">tuple 的 make_tuple 和 构造函数的一个细微区别</span><a href="#tuple-的-make_tuple-和-构造函数的一个细微区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>关于make_tuple可以查看EFF_STL章节</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">float</span> <span class="n">b</span><span class="p">{</span><span class="mf">2.3</span><span class="p">};</span>
<span class="kt">double</span> <span class="n">c</span><span class="p">{</span><span class="mf">3.2</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">};</span> <span class="c1">//c++17后可以不指定类模板参数</span>
<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
</pre></table></code></div></div><p>上面的代码就是在基本情况下使用构造函数和<code class="language-plaintext highlighter-rouge">makr_tuple</code>的基本语法。我们来看下较为复杂的情况</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__PRETTY_FUNCTION__</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
    <span class="kt">float</span> <span class="n">b</span><span class="p">{</span><span class="mf">2.3</span><span class="p">};</span>
    <span class="kt">double</span> <span class="n">c</span><span class="p">{</span><span class="mf">3.2</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">d</span><span class="p">{</span><span class="s">"hello"</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">d</span><span class="p">)};</span> <span class="c1">//c++17后可以不指定类模板参数</span>
    <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">d</span><span class="p">));</span>
    <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="n">func</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
void func(T) [with T = std::tuple&lt;std::reference_wrapper&lt;int&gt;, std::reference_wrapper&lt;float&gt;, std::reference_wrapper&lt;const double&gt;, std::reference_wrapper&lt;const std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;]
void func(T) [with T = std::tuple&lt;int&amp;, float&amp;, const double&amp;, const std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;&gt;]
*/</span>
</pre></table></code></div></div><p>我们注意到，使用普通的构造函数时，<code class="language-plaintext highlighter-rouge">tuple</code>里 <code class="language-plaintext highlighter-rouge">std::ref/cref</code>的类型没有变化。也就是每一个元素都是<code class="language-plaintext highlighter-rouge">std::reference_wrapper</code>类型。</p><p>但是在使用<code class="language-plaintext highlighter-rouge">make_tuple</code>的时候，<code class="language-plaintext highlighter-rouge">tuple</code>里的元素类型被脱去了，也就是”退化”成了对应底层类型的引用或<code class="language-plaintext highlighter-rouge">const</code>引用类型。我们可以看下源代码</p><p><a href="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241020212035.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-07-%E6%9D%82%E8%AE%B05.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241020212035.png" alt="微信图片_20241020212035" class="lazyload" data-proofer-ignore></a></p><p>我们可以看到，<code class="language-plaintext highlighter-rouge">make_tuple</code>会对参数的<code class="language-plaintext highlighter-rouge">reference_wrapper</code>类型进行脱去。</p><p>资料来自<a href="https://pvs-studio.com/en/blog/posts/cpp/1156/">这篇文章的 <em>Errors in object lifetime: tuples that shoot at your feet</em> 章节</a></p><h1 id="c中如何避免page-fault来降低延迟">C++中如何避免page fault来降低延迟</h1><p>https://johnnysswlab.com/latency-sensitive-application-and-the-memory-subsystem-part-2-memory-management-mechanisms</p><h1 id="协程">协程</h1><p><a href="https://lewissbaker.github.io/2022/08/27/understanding-the-compiler-transform">理解协程的代码转换</a></p><h1 id="让enum-class支持位运算">让enum class支持位运算</h1><p>让枚举支持位运算组合，就像传统c的用法那样，但是枚举类是强类型，转换很不方便，怎么办？实现<code class="language-plaintext highlighter-rouge">operator |</code></p><p>比如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="c1">// Define a templatized struct to contain a bool constexpr that controls</span>
<span class="c1">// when the operators get generated.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">FEnableBitmaskOperators</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">enable</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// This operator is only defined in the candidate set for a given type if the</span>
<span class="c1">// std::enable_if_t below evaluates to true, otherwise it is dropped.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">FEnableBitmaskOperators</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;::</span><span class="n">enable</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span>
    <span class="n">E</span> <span class="n">Lhs</span><span class="p">,</span> <span class="n">E</span> <span class="n">Rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">Lhs</span><span class="p">)</span> <span class="o">|</span>
                          <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">Rhs</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">// Rest of the operators...</span>

<span class="n">With</span> <span class="n">the</span> <span class="n">following</span> <span class="n">usage</span><span class="o">:</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">ERenderPass</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="c1">// Specialize the struct to enable the operators for our enum.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">FEnableBitmaskOperators</span><span class="o">&lt;</span><span class="n">ERenderPass</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">enable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Works!</span>
<span class="n">ERenderPass</span> <span class="n">Primary</span> <span class="o">=</span> <span class="n">ERenderPass</span><span class="o">::</span><span class="n">Geometry</span> <span class="o">|</span> <span class="n">ERenderPass</span><span class="o">::</span><span class="n">Lighting</span><span class="p">;</span>
</pre></table></code></div></div><p>实际上valkan cpp就是这么干的</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">BitType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">FlagTraits</span><span class="o">&lt;</span><span class="n">BitType</span><span class="p">&gt;</span><span class="o">::</span><span class="n">isBitmask</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">type</span> <span class="o">=</span> <span class="nb">true</span><span class="o">&gt;</span>
<span class="n">VULKAN_HPP_INLINE</span> <span class="n">VULKAN_HPP_CONSTEXPR</span> <span class="n">Flags</span><span class="o">&lt;</span><span class="n">BitType</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">|</span><span class="p">(</span> <span class="n">BitType</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">BitType</span> <span class="n">rhs</span> <span class="p">)</span> <span class="n">VULKAN_HPP_NOEXCEPT</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Flags</span><span class="o">&lt;</span><span class="n">BitType</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">lhs</span> <span class="p">)</span> <span class="o">|</span> <span class="n">rhs</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>来自<a href="https://github.com/wanghenshui/cppweeklynews/blob/dev/posts/115.md">这里</a>和<a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/a4cbf9c0279e6a95f1056e1a6d5ad10c8f3d2862/vulkan/vulkansc_enums.hpp#L202">这里</a></p><h1 id="ranges-和-view">ranges 和 view</h1><p>把ranges理解为一段区间的抽象。比如容器的两个迭代器范围内。所以vector、list都可以被称为range。因为它满足range的要求。</p><p>ranges的end一般叫sentinel哨位。原因是它的类型不一定必须和begin迭代器类型一致。因为sentinel不一定是迭代器。</p><p>range自带的算法一般是立即求值的。但是view不同。view（范围适配器）是惰性求值的。我们可以把view理解为惰性求值的规则管线。在迭代实际发生时才会进行计算。<strong>view是一种特殊的、轻量级的range。</strong></p><p><code class="language-plaintext highlighter-rouge">|</code>可以组成管线的原因是重载了<code class="language-plaintext highlighter-rouge">operator |</code></p><div class="table-wrapper"><table><thead><tr><th>特性<th><code class="language-plaintext highlighter-rouge">range</code><th><code class="language-plaintext highlighter-rouge">view</code><tbody><tr><td>是否是概念<td>✅ 是<td>✅ 是<tr><td>是否可以遍历<td>✅ 可以<td>✅ 可以<tr><td>是否拥有数据<td>可能有<td>❌ 通常没有（或只是引用）<tr><td>是否惰性计算<td>❌ 一般是立即<td>✅ 是惰性的<tr><td>是否轻量级<td>不一定<td>✅ 是<tr><td>能否组合管道<td>❌（要借助 ranges）<td>✅ 完美支持管道 .</table></div><ul><li>所有的 <strong>view 是 range</strong><li>但不是所有的 <strong>range 是 view</strong><li>view 是你能用 <code class="language-plaintext highlighter-rouge">|</code> 管道连接的东西（懒惰组合）<li>range 更像是 “你能遍历的容器或结构”的大集合</ul><h1 id="llvm的dense-map解析">LLVM的dense map解析</h1><p>https://zhuanlan.zhihu.com/p/669307116</p><p>讲的非常好</p><h1 id="c-abi的真正理解">C++ ABI的真正理解</h1><p>https://zhuanlan.zhihu.com/p/692886292</p><h1 id="asio-的使用技巧">ASIO 的使用技巧</h1><p>https://mmoemulator.com/p/going-super-sonic-with-asio/#skippable-preamble</p><h1 id="gcc的代码模型">GCC的代码模型</h1><p>https://eli.thegreenplace.net/2012/01/03/understanding-the-x64-code-models</p><h1 id="cmake杂记">CMAKE杂记</h1><p>普通库就是编译+链接，对象库只编译不链接，接口库不编译不链接。</p><h2 id="接口库的作用"><span class="mr-2">接口库的作用：</span><a href="#接口库的作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>当您在 CMake 中创建一个 INTERFACE 库并为其设置一些属性（如编译器选项、定义或<strong>包含目录</strong>），然后其他目标链接到这个 INTERFACE 库时，这些属性就会自动应用到链接到它的所有目标。</p><p>在您提到的情况中，假设有一个 <code class="language-plaintext highlighter-rouge">some_header.hpp</code> 被多个 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件包含，在 CMake 中使用 INTERFACE 库可以确保每次编译这些 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件时都使用相同的编译器选项。这种方式简化了管理编译选项的复杂性，因为您只需要在一个地方指定这些选项，而它们就会自动应用到所有依赖的目标上。</p><p>下面是一个具体示例：</p><p><strong>Step 1</strong>: 创建一个 INTERFACE 库，并设置属性。</p><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nb">add_library</span><span class="p">(</span>some_interface_lib INTERFACE<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span>some_interface_lib INTERFACE <span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span>/include<span class="p">)</span>
<span class="nb">target_compile_definitions</span><span class="p">(</span>some_interface_lib INTERFACE SOME_DEFINE=1<span class="p">)</span>
</pre></table></code></div></div><p><strong>Step 2</strong>: 确保你的目标链接到这个 INTERFACE 库。</p><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nb">add_executable</span><span class="p">(</span>some_executable main.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>some_executable PRIVATE some_interface_lib<span class="p">)</span>

<span class="nb">add_library</span><span class="p">(</span>some_other_lib some_other_source.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>some_other_lib PUBLIC some_interface_lib<span class="p">)</span>
</pre></table></code></div></div><p>在上面的例子中，无论是 <code class="language-plaintext highlighter-rouge">some_executable</code> 还是 <code class="language-plaintext highlighter-rouge">some_other_lib</code>，任何时候它们的编译单元包含了 <code class="language-plaintext highlighter-rouge">some_header.hpp</code>，都会自动应用 <code class="language-plaintext highlighter-rouge">some_interface_lib</code> 的属性，<strong>即添加了 <code class="language-plaintext highlighter-rouge">${CMAKE_CURRENT_SOURCE_DIR}/include</code> 到包含路径</strong>，以及定义了预处理器宏 <code class="language-plaintext highlighter-rouge">SOME_DEFINE=1</code>。</p><p>通过这种方式，CMake 保证了构建系统的一致性和易于维护，同时避免了在多个地方重复相同的编译配置。</p><h3 id="接口库示例"><span class="mr-2">接口库示例</span><a href="#接口库示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nb">add_library</span><span class="p">(</span>test_interface INTERFACE<span class="p">)</span> // 创建一个名为 test_interface 的接口库
// 这里没有指定源文件，因为接口库不生成二进制文件；它只用来携带相关的编译器和链接器选项。
<span class="nb">target_include_directories</span><span class="p">(</span>test_interface INTERFACE <span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span>/include<span class="p">)</span> // 为test_interface 添加包含目录
// 这使得任何链接到 test_interface 的目标都会在编译时包含 <span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span>/include 目录。
// 比如如果某一个其他的目标使用target_link_libraries命令来链接test_interface， 那么这个目标也会包含<span class="si">${</span><span class="nv">CMAKE_CURRENT_LIST_DIR</span><span class="si">}</span>/include 目录
</pre></table></code></div></div><p>这就是为什么header-only非常适合使用interface库。因为header-only没有源文件，自然不会有目标文件。当我的某个目标是一个header-only的库的时候，设置为接口库就相当于让每一个包含了这个header-only的库都自动使用同一份目录和编译选项（如有）</p><h2 id="其他参考文章"><span class="mr-2">其他参考文章</span><a href="#其他参考文章" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://juejin.cn/post/7385776238789099529">CMAKE简明教程</a></p><p><a href="https://aiden-dong.github.io/2019/07/20/CMake%E6%95%99%E7%A8%8B%E4%B9%8BCMake%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%BA%94%E7%94%A8/">CMake 从入门到应用</a></p><p><a href="https://elloop.github.io/tools/2016-04-10/learning-cmake-2-commands">常用CMAKE命令和简要说明</a></p><p><a href="https://subingwen.cn/cmake/CMake-primer/#1-CMake%E6%A6%82%E8%BF%B0">CMAKE保姆级教程1</a></p><p><a href="https://subingwen.cn/cmake/CMake-advanced/#2-2-2-while">CMAKE保姆级教程2</a></p><p><a href="https://a4z.gitlab.io/blog/2024/11/30/Print-all-CMake-variables.html">打印出cmake的所有变量</a></p><h1 id="memset-不可用于显式清除内存数据">memset 不可用于显式清除内存数据</h1><p>先看<a href="https://zh.cppreference.com/w/c/string/byte/memset">cppreference</a></p><blockquote><p>若 <code class="language-plaintext highlighter-rouge">memset</code> 所修改的对象在其生存期的剩余部分不再被访问，则此函数可以被优化掉（在<a href="https://zh.cppreference.com/w/c/language/as_if">如同</a>规则下）（例如 <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537">gcc 漏洞 8537</a>）。为此，此函数不能用于擦洗内存（例如以零填充存储密码的数组）。</p><p>对 <code class="language-plaintext highlighter-rouge">memset_explicit</code> 和 <code class="language-plaintext highlighter-rouge">memset_s</code> 禁止此优化：保证进行内存写。</p></blockquote><p>这个bug来自PPSSPP代码报告<a href="https://pvs-studio.com/en/blog/posts/cpp/1167/">这里</a>的N18</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">sha1_hmac</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keylen</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ilen</span><span class="p">,</span>
<span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="err"> </span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">sha1_context</span> <span class="n">ctx</span><span class="p">;</span>

<span class="err"> </span> <span class="n">sha1_hmac_starts</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">keylen</span> <span class="p">);</span>
<span class="err"> </span> <span class="n">sha1_hmac_update</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">ilen</span> <span class="p">);</span>
<span class="err"> </span> <span class="n">sha1_hmac_finish</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="n">output</span> <span class="p">);</span>

<span class="err"> </span> <span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">sha1_context</span> <span class="p">)</span> <span class="p">);</span> <span class="c1">// &lt;&lt;!</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为memset 存在Dead Store Elimination，所以这个memset可能会被优化掉，导致内存数据并没有被清除</p><h1 id="stdlaunder">std::launder</h1><p>什么是<a href="https://miyuki.github.io/2016/10/21/std-launder.html">launder</a></p><p><a href="https://pvs-studio.com/en/blog/posts/cpp/1160/">launder和const、编译器的常量传播之间的神秘关系 查看Const and optimizations一节</a></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">alignas</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">B</span><span class="p">)];</span> <span class="c1">//必须和B对齐不然炸了</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="n">A</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// 用 placement new 在同一块内存构造另一个类型</span>
    <span class="n">B</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="n">B</span><span class="p">;</span>

    <span class="c1">// 直接访问 b-&gt;y 是 **未定义行为**！</span>
    <span class="c1">// 因为优化器认为这块内存“本来是 A”，没有新对象被构造</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 正确做法</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这个东西的核心就是<strong>刷新编译器的“类型视角”</strong>：<strong>告诉它这里是新构造出来的对象</strong>，也就是强制编译器 <strong>重新加载指针指向对象</strong>；可以查看标准文档的 17.6.5[ptr.launder]</p><h1 id="range-based-for-loop的临时范围初始化器的雷">range based for loop的临时范围初始化器的雷</h1><p>查看<a href="https://stackoverflow.com/questions/72510589/a-temporary-object-in-range-based-for-loop">这里</a>和<a href="https://stackoverflow.com/questions/51436155/range-based-for-loop-on-a-temporary-range/51440883#51440883">这里</a>。弄清楚何时会导致引用绑定的临时对象失效。以及在<a href="https://pvs-studio.com/en/blog/posts/cpp/1156/">这里的<em>Errors in object lifetime: lifetime extension</em>章节</a>看一下临时对象的生命周期被临时范围初始化器错误的延长</p><p>以及这里的<a href="https://pvs-studio.com/en/blog/posts/cpp/1149/">Errors in object lifetime: a fly in the syntactic sugar (range-based for)</a>一章看范围for循环的生命周期问题。</p><p>其实说白了核心是一点：</p><blockquote><p>总而言之，<strong>临时量的生存期不能以进一步“传递”来延续</strong>：从绑定了该临时量的引用或数据成员初始化的<strong>第二引用不影响临时量的生存期</strong>。</p></blockquote><p>范围初始化器可以抽象看成是这样的形式：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cm">/*
属性(可选) for ( 初始化语句(可选) 项声明 : 范围初始化器 ) 语句        
*/</span>
<span class="p">{</span>
    <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="cm">/* range */</span> <span class="o">=</span> <span class="err">范围初始化器</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="cm">/* begin */</span> <span class="o">=</span> <span class="cm">/* 首表达式 */</span><span class="p">,</span> <span class="cm">/* end */</span> <span class="o">=</span> <span class="cm">/* 尾表达式 */</span><span class="p">;</span>
        <span class="cm">/* begin */</span> <span class="o">!=</span> <span class="cm">/* end */</span><span class="p">;</span> <span class="o">++</span><span class="cm">/* begin */</span><span class="p">){</span>
            <span class="err">项声明</span> <span class="o">=</span> <span class="err">*/</span><span class="o">*</span> <span class="n">begin</span> <span class="err">*/</span><span class="p">;</span>
            <span class="err">语句</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>假设我们有这种代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Shape</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">using</span> <span class="n">VertexList</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">Shape</span><span class="p">(</span><span class="n">VertexList</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">vertexes</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{}</span>

    <span class="k">const</span> <span class="n">VertexList</span><span class="o">&amp;</span> <span class="n">Vertexes</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="c1">// 1 返回const&amp;</span>
        <span class="k">return</span> <span class="n">vertexes</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">VertexList</span> <span class="n">vertexes</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Shape</span> <span class="nf">MakeShape</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Shape</span> <span class="p">{</span> <span class="n">Shape</span><span class="o">::</span><span class="n">VertexList</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">MakeShape</span><span class="p">().</span><span class="n">Vertexes</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 2 注意这种范围初始化器初始方式</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">v</span> <span class="o">:</span> <span class="n">MakeShape</span><span class="p">().</span><span class="n">vertexes</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 3 注意这种范围初始化器初始方式</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
7363 0
-1948417267 -1125936379
0 0
1 1
 
1 0
0 1
0 0
1 1
*/</span>
</pre></table></code></div></div><p>我们注意到方法2输出垃圾值。方法3是OK的 这就是雷点。</p><p>我们已经知道了，<strong>临时量的生存期不能以进一步“传递”来延续</strong>：从绑定了该临时量的引用或数据成员初始化的<strong>第二引用不影响临时量的生存期</strong>。我们手动“扩展一下”这个范围循环</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="cm">/* range */</span> <span class="o">=</span> <span class="n">MakeShape</span><span class="p">().</span><span class="n">Vertexes</span><span class="p">();</span> <span class="c1">// 方法2</span>
<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="cm">/* range */</span> <span class="o">=</span> <span class="n">MakeShape</span><span class="p">().</span><span class="n">vertexes</span><span class="p">;</span> <span class="c1">// 方法3</span>
</pre></table></code></div></div><p>我们已经发现端倪。方法2的<code class="language-plaintext highlighter-rouge">Vertexes()</code>函数调用返回的临时对象已经绑定到了函数返回值的<code class="language-plaintext highlighter-rouge">const &amp;</code>虽然后续被绑定到了<code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> 但是无法被二次延长。方法3当中没有方法2那种函数返回值从中作梗，所以正确的被<code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code>延长了生命周期。</p><h2 id="如何避免这个雷"><span class="mr-2">如何避免这个雷</span><a href="#如何避免这个雷" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>记得对任何const类型的函数进行rvalue限定的重载<li>针对范围for循环的范围初始化器，一定仅使用变量本身或者它的成员变量。<li>C++20后使用新语法<li>如果有机会，使用<code class="language-plaintext highlighter-rouge">std::ranges::for_each</code></ol><h1 id="浮点数的各种判断是否为0">浮点数的各种判断是否为0</h1><p>看周刊<a href="https://github.com/wanghenshui/cppweeklynews/blob/dev/posts/171.md">这一期</a>，代码在<a href="https://godbolt.org/z/jcqc38qqW">这里</a></p><h1 id="算术运算溢出相关的未定义行为">算术运算溢出相关的未定义行为</h1><p>https://pvs-studio.com/en/blog/posts/cpp/1136/</p><h1 id="c中fx-有多少种可能">C++中，f(x) 有多少种可能？</h1><p>https://biowpn.github.io/bioweapon/2024/11/12/what-does-f-x-mean.html 强烈建议看一下</p><h1 id="proxy库">Proxy库</h1><ol><li>https://redhand.com.cn/2025/01/02/proxy-convension/</ol><h1 id="ecs模式的数据结构设计">ECS模式的数据结构设计</h1><ul><li><a href="https://docs.google.com/presentation/d/1PbCH2IRg8lW08JlUz-xQEQjTo_Fr5n9QZOTEjGqZnuU/edit?pli=1#slide=id.g35f391192_00">PPT</a><li><a href="https://www.youtube.com/watch?v=b9hNKFj5R3Y">讲座</a><li>一个复合稀疏密集数据结构的样例</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">DenseSparseArray</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 插入元素（假设 entity 是唯一标识）</span>
    <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">entity</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entity</span> <span class="o">&gt;=</span> <span class="n">sparse</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">sparse</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">entity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// -1 表示无效索引</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">dense</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="n">dense</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">entity</span><span class="p">,</span> <span class="n">value</span><span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 删除元素</span>
    <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">entity</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">entity</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">dense_idx</span> <span class="o">=</span> <span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">];</span>
            <span class="k">auto</span><span class="o">&amp;</span> <span class="n">last</span> <span class="o">=</span> <span class="n">dense</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>

            <span class="c1">// 将要删除的元素与最后一个元素交换</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">dense</span><span class="p">[</span><span class="n">dense_idx</span><span class="p">],</span> <span class="n">last</span><span class="p">);</span>
            <span class="n">sparse</span><span class="p">[</span><span class="n">last</span><span class="p">.</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="n">dense_idx</span><span class="p">;</span>

            <span class="n">dense</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 访问元素</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">uint32_t</span> <span class="n">entity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">contains</span><span class="p">(</span><span class="n">entity</span><span class="p">));</span>
        <span class="k">return</span> <span class="n">dense</span><span class="p">[</span><span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">]].</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 判断是否存在</span>
    <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">entity</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">entity</span> <span class="o">&lt;</span> <span class="n">sparse</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">sparse</span><span class="p">[</span><span class="n">entity</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 迭代器支持</span>
    <span class="k">auto</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">dense</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">auto</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">dense</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">struct</span> <span class="nc">Element</span> <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">entity</span><span class="p">;</span>
        <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sparse</span><span class="p">;</span>  <span class="c1">// 稀疏数组（存储索引）</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span> <span class="n">dense</span><span class="p">;</span> <span class="c1">// 密集数组（实际数据）</span>
<span class="p">};</span>

<span class="n">enseSparseArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">;</span>

<span class="n">arr</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>  <span class="c1">// 插入 entity=100</span>
<span class="n">arr</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">77</span><span class="p">);</span>  <span class="c1">// 插入 entity=200</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span> <span class="c1">// 输出 42</span>

<span class="n">arr</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>       <span class="c1">// 删除 entity=100</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历所有有效元素</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">entity</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="匿名联合体">匿名联合体</h1><p>在<a href="https://github.com/facebook/folly/blob/main/folly/futures/detail/Core.h">folly</a>中，有这样一段代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ResultHolder</span> <span class="p">{</span>
 <span class="nl">protected:</span>
  <span class="n">ResultHolder</span><span class="p">()</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">ResultHolder</span><span class="p">()</span> <span class="p">{}</span>
  <span class="c1">// Using a separate base class allows us to control the placement of result_,</span>
  <span class="c1">// making sure that it's in the same cache line as the vtable pointer and the</span>
  <span class="c1">// callback_ (assuming it's small enough).</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">Try</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result_</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></table></code></div></div><p>这个类里面的union叫做<a href="https://zh.cppreference.com/w/cpp/language/union#.E5.8C.BF.E5.90.8D.E8.81.94.E5.90.88.E4.BD.93">匿名联合体</a>。为啥要把result用union包一下？<strong>目的是防止T类型没有默认构造函数导致编译错误。因为匿名联合体内的成员不会被默认初始化。</strong></p><blockquote><p>https://zh.cppreference.com/w/cpp/language/default_initialization</p><p>在默认初始化章节中提到了。</p><p>包括标准库文档的11.9.3[class.base.init]节:</p><ul><li>otherwise, if the entity is an anonymous union or a variant member (11.5.2), no initialization is performed;</ul></blockquote><p><strong>同时。如果一个类包含了一个匿名联合体，则这个匿名联合体不会被初始化</strong></p><blockquote><p>https://zh.cppreference.com/w/cpp/language/constructor</p><p>在开始执行组成构造函数体的复合语句之前，所有直接基类、虚基类和非静态数据成员的初始化均已结束。这些对象的非默认初始化只能在成员初始化器列表指定。对于不能默认初始化的基类，和不能以默认初始化或以其<a href="https://zh.cppreference.com/w/cpp/language/data_members#.E6.88.90.E5.91.98.E5.88.9D.E5.A7.8B.E5.8C.96">默认成员初始化器</a>（如果有）(C++11 起)初始化的非静态数据成员，例如引用和 const 限定的类型的成员，必须指定成员初始化器。（注意，类模板实例化的非静态数据成员的默认成员初始化器，当成员类型或初始化器待决时可能是无效的。)(C++11 起)<strong>对没有成员初始化器或默认成员初始化器(C++11 起)的匿名联合体或变体成员不进行初始化。</strong></p></blockquote><p><strong>一定要区分联合体和匿名联合体</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ResultHolder</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">result_</span><span class="p">;</span>
  <span class="p">};</span>  <span class="c1">// 匿名联合体</span>
  <span class="k">union</span> <span class="n">s</span><span class="p">{</span>
      <span class="n">T</span> <span class="n">result_</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// 联合体 但是这里只有声明没有定义</span>
  <span class="n">s</span> <span class="n">s_</span><span class="p">;</span> <span class="c1">//定义 但是报错。因为不是匿名联合体依旧会被尝试初始化</span>
<span class="p">};</span>
</pre></table></code></div></div><p>我们可以看一个简化版的最小实现</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="c1"> // for placement new</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 禁止默认构造</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A("</span> <span class="o">&lt;&lt;</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="s">") constructed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A destroyed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// folly 风格的 ResultHolder</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ResultHolder</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">ResultHolder</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// 允许默认构造，但不会初始化 result_</span>
  <span class="o">~</span><span class="n">ResultHolder</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// 不能换成</span>
	 <span class="c1">// result_.~T();</span>
     <span class="c1">// 因为我们不能确保T被构造过。生命周期管理需要对称，T是手动构造就必须手动析构。</span>
  <span class="p">}</span> <span class="c1">// 允许默认析构，但需要手动析构 result_</span>

  <span class="c1">// 使用 匿名union 避免默认构造，同时不提供额外的默认构造函数</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">result_</span><span class="p">;</span>
  <span class="p">};</span>
    <span class="c1">// T result_; // 如果用这种就会报错</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 由于 result_ 没有默认构造，需要手动构造</span>
  <span class="n">ResultHolder</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">holder</span><span class="p">;</span>
  <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">holder</span><span class="p">.</span><span class="n">result_</span><span class="p">)</span> <span class="n">A</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// 使用 placement new 构造 A</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A.x = "</span> <span class="o">&lt;&lt;</span> <span class="n">holder</span><span class="p">.</span><span class="n">result_</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

  <span class="c1">// 手动调用析构，否则会产生未定义行为</span>
  <span class="n">holder</span><span class="p">.</span><span class="n">result_</span><span class="p">.</span><span class="o">~</span><span class="n">A</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h1 id="thread-local-线程存储期的性能瓶颈">thread local 线程存储期的性能瓶颈</h1><p>https://yosefk.com/blog/cxx-thread-local-storage-performance.html 这篇文章详细介绍了TLS (thread local storage)对象的性能瓶颈。说白了：</p><p>tls对象在有类/构造函数维护 + fpic共享库需要额外调用__tls_get_addr 成为性能瓶颈</p><p>优化指南</p><ul><li>TLS对象尽可能合并<li>不要为TLS写构造函数<li>为频繁访问的对象使用__attribute__((visibility(“hidden”)))<li>为关键变量使用__attribute__((tls_model(“initial-exec”)))<li>如果不是共享库，不要使用fpic （静态库链接到二进制，可以去掉）<li>考虑使用编译器加速 比如-mtls-dialect=gnu2<li>使用pthread key分配+自定义pthread_getspecifc绕过</ul><h1 id="设计几种迭代器">设计几种迭代器</h1><p>https://johnfarrier.com/7-interesting-and-powerful-uses-for-c-iterators/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=7-interesting-and-powerful-uses-for-c-iterators</p><p>个人理解里面有几种还是很有意思的。比如：</p><h2 id="无限序列迭代器适用于生成一些数字"><span class="mr-2">无限序列迭代器，适用于生成一些数字</span><a href="#无限序列迭代器适用于生成一些数字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">fibonacci_iterator</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

   <span class="nl">public:</span>
    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&amp;</span><span class="p">;</span>

    <span class="n">fibonacci_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 注意这里写的是前置自增</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">b</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">long</span> <span class="kt">long</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Always true for infinite sequences</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">fibonacci_iterator</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">fibonacci_iterator</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 前置自增</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="类似于transform作用的迭代器适配器"><span class="mr-2">类似于transform作用的迭代器适配器</span><a href="#类似于transform作用的迭代器适配器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Iter</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Func</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">transform_iterator</span> <span class="p">{</span>
    <span class="n">Iter</span> <span class="n">it</span><span class="p">;</span>
    <span class="n">Func</span> <span class="n">func</span><span class="p">;</span>

   <span class="nl">public:</span>
    <span class="k">using</span> <span class="n">iterator_category</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">Func</span><span class="p">(</span>
        <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">Iter</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">;</span>  <span class="c1">// 萃取一下函数调用的返回类型</span>
    <span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">value_type</span><span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">;</span>

    <span class="n">transform_iterator</span><span class="p">(</span><span class="n">Iter</span> <span class="n">iter</span><span class="p">,</span> <span class="n">Func</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">it</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span> <span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 还是，前置自增</span>
        <span class="o">++</span><span class="n">it</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">reference</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// 注意 这重载的是解引用操作符。不是乘法。乘法是二元，解引用是一元。</span>
        <span class="c1">// 这里的目的是搭配一些STL库的算法。比如copy是解引用赋值。</span>
        <span class="c1">// 返回reference类型的原因是解引用操作符希望返回一个引用，这样才能被赋值。</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">transform_iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">it</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span><span class="p">{};</span>
    <span class="k">auto</span> <span class="n">square</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">transform_iterator</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">square</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">transform_iterator</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">square</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span>
                  <span class="n">squares</span><span class="p">));</span>  <span class="c1">// 用back inserter往里面插。因为一开始没初始化，所以直接给迭代器</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">squares</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="就地过滤迭代器-in-place-filter"><span class="mr-2">就地过滤迭代器 in-place filter</span><a href="#就地过滤迭代器-in-place-filter" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">filtering_iterator</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">vec_it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>  <span class="c1">// 简化实现。实际上应该使用模板参数</span>
    <span class="n">vec_it</span> <span class="n">current</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">threshold</span><span class="p">;</span>

   <span class="nl">public:</span>
    <span class="n">filtering_iterator</span><span class="p">(</span><span class="n">vec_it</span> <span class="n">begin</span><span class="p">,</span> <span class="n">vec_it</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">th</span><span class="p">)</span> <span class="o">:</span> <span class="n">current</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">end</span><span class="p">),</span> <span class="n">threshold</span><span class="p">(</span><span class="n">th</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">advance</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">filtering_iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">==</span> <span class="n">end</span> <span class="o">?</span> <span class="n">end</span> <span class="o">:</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 如果是end就返回end,不然就+1</span>
        <span class="n">advance</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">current</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">filtering_iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">current</span><span class="p">;</span> <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">advance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">current</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 跳过小于阈值的元素</span>
            <span class="c1">// 这里用 != 而不是 &lt;是因为只有随机迭代器支持关系性比较</span>
            <span class="c1">// 另外只能+1，不然迭代器失效就炸了。如果要+n的话需要再套一个while</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">threshold</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Filtered values: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">filtering_iterator</span> <span class="nf">it</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">threshold</span><span class="p">);</span>
         <span class="n">it</span> <span class="o">!=</span> <span class="n">filtering_iterator</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">threshold</span><span class="p">);</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 注意一点，我们用迭代器一般都是在for循环语句内现场创建，而不是在外面创建再传进去</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++%E6%9D%82%E8%AE%B0%20-%205%20-%20Sterben_01&url=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B05%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++%E6%9D%82%E8%AE%B0%20-%205%20-%20Sterben_01&u=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B05%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B05%2F&text=C++%E6%9D%82%E8%AE%B0%20-%205%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 class A { public: virtual std::string clsname() { return &quot;A&quot;; } std::string clsname2() { return &quot;A&quot;; } void test() { std::cout &amp;lt;&amp;lt; &quot;A, &quot; &amp;lt;&amp;lt; clsname()...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ModernC++Design/" class="btn btn-outline-primary" prompt="上一篇"><p>Modern C++ Design 笔记</p></a> <a href="/posts/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/" class="btn btn-outline-primary" prompt="下一篇"><p>响应式设计</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
