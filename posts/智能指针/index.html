<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="智能指针" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="智能指针" /><meta property="og:description" content="智能指针" /><link rel="canonical" href="/posts/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" /><meta property="og:url" content="/posts/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-20T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="智能指针" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-02-10T05:26:23-06:00","datePublished":"2022-07-20T01:55:00-05:00","description":"智能指针","headline":"智能指针","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},"url":"/posts/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"}</script><title>智能指针 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>智能指针</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>智能指针</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1658300100" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/07/20 </em> </span> <span> 更新于 <em class="" data-ts="1739186783" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/02/10 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="20066 字"> <em>111 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="智能指针">智能指针</h1><p>我们不爱裸指针的原因：</p><ol><li>裸指针的声明没办法告诉我们它指向的是单个对象还是数组。<li>没办法知道用完这个裸指针后要不要销毁它指向的对象。<li>没办法知道怎么销毁这个裸指针，是用<code class="language-plaintext highlighter-rouge">operator delete</code>还是什么其它自定义的途径。<li>参照原因1，没办法知道该用<code class="language-plaintext highlighter-rouge">delete</code>还是<code class="language-plaintext highlighter-rouge">delete[]</code>，如果用错了，结果未定义。<li>很难保证调用路径上恰好销毁这个指针一次，可能内存泄露，也可能double free。<li>通常没办法知道裸指针是否是空悬指针，即是否指向已销毁的对象。</ol><p>智能指针就是来解这些问题的，它们用起来像裸指针，但能避免以上的很多陷阱。C++11中有4种智能指针：<code class="language-plaintext highlighter-rouge">std::auto_ptr</code>、<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>、<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>、<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>。其中<code class="language-plaintext highlighter-rouge">std::auto_ptr</code>已经过时了，C++11中可以被<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>取代了。</p><h1 id="unique_ptr"><code class="language-plaintext highlighter-rouge">unique_ptr</code></h1><p><code class="language-plaintext highlighter-rouge">std::unique_ptr</code>体现了<strong>显式所有权</strong>的语义：</p><ul><li>非空的<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>总是拥有它指向的对象<li>移动一个<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>会将源指针持有的所有权移交给目标指针；<li>不允许复制<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>；（无拷贝构造和拷贝赋值）<ul><li>注意可以通过直接初始化使用裸指针构造一个<code class="language-plaintext highlighter-rouge">unique_ptr</code> (如下面的<code class="language-plaintext highlighter-rouge">ptr3</code>)</ul><li>只允许移动<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>（只有移动构造和移动赋值）<li>非空的<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>总是销毁它持有的资源，默认是通过<code class="language-plaintext highlighter-rouge">delete</code>。</ul><p><strong>所以使用 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 管理具备专属所有权的资源。<code class="language-plaintext highlighter-rouge">unique_ptr</code>的作用基本上就是帮助你进行资源释放（析构）</strong></p><h2 id="创建指针"><span class="mr-2">创建指针</span><a href="#创建指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">deleter</span><span class="p">(</span><span class="n">myobj</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"deleter called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>        <span class="c1">//需要在这里删掉new出来的内容 如果不写的话会内存泄漏。因为智能指针不再执行自己的释放资源的函数。改为执行这个函数。但是这个函数里面如果没有释放资源就会内存泄漏。</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">mydeleter</span><span class="p">{</span> 		<span class="c1">//自定义删除器类。functor</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"deleter called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>        
            <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">;</span>                                         <span class="c1">//空指针</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>                        	<span class="c1">//错误。智能指针构造函数是explicit的。禁止隐式转换，所以不允许带有隐式转换的拷贝初始化。但是可以用直接初始化</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3</span><span class="p">(</span><span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>                           <span class="c1">//ok</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3_1</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">ptr3</span><span class="p">);</span> 						<span class="c1">//使用move拷贝初始化</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3_2</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr3</span><span class="p">));</span>						<span class="c1">//使用move直接初始化</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">myobj</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">ptr4</span><span class="p">(</span><span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">deleter</span><span class="p">);</span> <span class="c1">//自定义删除器。注意需要在自定义删除器内部进行资源释放，因为使用自定义删除器后，智能指针不会接管释放资源。注意这里传入的是函数指针，会使unique_ptr整体增大，变成两个指针。正确使用应该是下面那种定义类型。</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="p">,</span> <span class="n">mydeleter</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;&gt;</span> <span class="n">ptr4_1</span><span class="p">(</span><span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>       <span class="c1">//自定义删除器。注意，这里在尖括号内传入的是仿函数类型。这样会直接使用类型的可调用对象做为删除器。这样效率很高，少一个指针</span>
    <span class="c1">//所以写自定义删除器的意义是如果你想在某一个资源的析构函数或者是释放资源的同时执行其他动作，就需要写这个。因为，资源的释放阶段是全部交给智能指针接管的。</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>    	<span class="c1">//错误 使用make方法。make_unique是把传入参数完美转发至对象构造函数。只需要传递参数即可，无需再次new。</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>                 <span class="c1">//使用make方法。make方法无法使用自定义删除器和大括号初始化（列表初始化）</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5_1</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span> 				<span class="c1">//使用make方法。直接初始化</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span><span class="p">(</span><span class="n">ptr3</span><span class="p">);</span>                                   <span class="c1">//禁止拷贝。因为只能有一个unique_ptr指向一个资源。所有权语义。</span>
    <span class="n">ptr5</span> <span class="o">=</span> <span class="n">ptr3</span><span class="p">;</span>													<span class="c1">//禁止拷贝赋值。</span>
    
    <span class="c1">//------------------------------------------------------------------------</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a_ptr</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span> <span class="c1">//使用直接初始化</span>
    <span class="n">a_ptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">//依旧可以。这里调用的是operator=，参数是unique_ptr&lt;int&gt;&amp;&amp;。因为make_unique会按值返回一个unique_ptr对象，所以是右值。并且unique_ptr&amp; operator=( unique_ptr&amp;&amp; r )会先把自己的资源释放掉，再接管新的资源，此处不会有内存泄漏。</span>
<span class="p">}</span>         
</pre></table></code></div></div><p>关于<code class="language-plaintext highlighter-rouge">make</code>方法无法使用大括号初始化（列表初始化）可以用<code class="language-plaintext highlighter-rouge">auto</code>先把大括号接住（推导出一个<code class="language-plaintext highlighter-rouge">list initializer</code>类型），然后把<code class="language-plaintext highlighter-rouge">auto</code>声明的变量拿过来用。(使用列表初始化构造)。</p><p><strong>注意，正确使用自定义删除器应该是定义一个类型并且这个类型需要是空基类而不是传入一个函数指针，这也是为什么<code class="language-plaintext highlighter-rouge">unique_ptr</code>把删除器当作类型一部分的原因</strong>。如果传入函数指针的话，智能指针大小将会是16。因为他会额外包含一个指针。这里最后提到。</p><ul><li>关于自定义删除器的意思是：<strong>智能指针不再调用自己的函数来释放资源。改为调用你指定的函数。</strong><ul><li><strong>但是要注意，因为智能指针不再调用自己的函数释放资源，你必须在你自己定义的函数内释放对应的资源。</strong></ul></ul><h3 id="unique_ptr做为自定义对象的成员时如何构造"><span class="mr-2">unique_ptr做为自定义对象的成员时，如何构造</span><a href="#unique_ptr做为自定义对象的成员时如何构造" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">u_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num</span><span class="p">)){}</span> <span class="c1">//可以，使用make方法直接初始化</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="n">num</span><span class="p">)){}</span> <span class="c1">//可以，直接使用构造函数初始化</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">){}</span> <span class="c1">//可以</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">){</span>
            <span class="n">u_ptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">num</span><span class="p">);</span> <span class="c1">//可以。使用operator=搭配make_unique方法。看上面横线下方的例子。</span>
        <span class="p">}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span> <span class="c1">//可以。使用裸指针直接初始化</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">num</span><span class="p">)){}</span> <span class="c1">//可以，使用move</span>
    
    
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span>  <span class="c1">//不可以，禁止拷贝初始化</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">),</span> <span class="n">u_ptr</span><span class="p">(</span><span class="n">num</span><span class="p">){}</span> <span class="c1">//不行。unique_ptr没有这个构造函数</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhsstr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">str</span><span class="p">(</span><span class="n">rhsstr</span><span class="p">){</span>
            <span class="n">u_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//不可以。没有形参为裸指针的operator=函数。</span>
        <span class="p">}</span>
        
<span class="p">};</span>
</pre></table></code></div></div><ul><li>传入裸指针的时候注意double free问题。</ul><h3 id="使用get来获取内部包含的普通指针"><span class="mr-2">使用<code class="language-plaintext highlighter-rouge">get()</code>来获取内部包含的普通指针</span><a href="#使用get来获取内部包含的普通指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   
<span class="n">ptr5</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></table></code></div></div><h4 id="所有智能指针都可以通过解引用直接获取值和普通指针一样"><span class="mr-2">所有智能指针都可以通过解引用直接获取值。和普通指针一样。</span><a href="#所有智能指针都可以通过解引用直接获取值和普通指针一样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h2 id="release和reset"><span class="mr-2">release()和reset()</span><a href="#release和reset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="release"><span class="mr-2">release()</span><a href="#release" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">u.release()</code>是放弃对指针的控制权，返回指针，并将u置空。意思是释放后会返回裸指针，我们可以继续使用。（释放所有权，但是指向的对象不会被销毁）</ul><h3 id="reset"><span class="mr-2">reset()</span><a href="#reset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">reset</span><span class="p">(</span> <span class="n">pointer</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">()</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><p>给定指向 <code class="language-plaintext highlighter-rouge">*this</code> 所管理对象的指针 <code class="language-plaintext highlighter-rouge">current_ptr</code> ，进行下列行动，以此顺序：</p><ol><li>保存当前指针的副本 <code class="language-plaintext highlighter-rouge">old_ptr = current_ptr</code><li>以传入参数重写当前指针 <code class="language-plaintext highlighter-rouge">current_ptr = ptr</code>。<li>若<strong>旧指针非空</strong>，则删除先前管理的对象 <code class="language-plaintext highlighter-rouge">if(old_ptr != nullptr) get_deleter()(old_ptr)</code> 。</ol><ul><li><code class="language-plaintext highlighter-rouge">u.reset()</code>销毁u指向的对象，并将u置为空。意思是释放后无法继续使用。<li><p><code class="language-plaintext highlighter-rouge">u.reset(q)</code>销毁u原来指向的对象，令u获取q指向对象的所有权。（q的所有权被接管后会成为空指针）</p><ul><li>注意这个要这么用</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="nf">int</span> <span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="k">new</span> <span class="nf">int</span> <span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="n">ptr2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">//等同于 ptr2 = move(ptr1);</span>
<span class="n">ptr2</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span> <span class="c1">//错误！！！不能这么用。</span>
</pre></table></code></div></div></ul><p>强调一下上面<code class="language-plaintext highlighter-rouge">reset()</code>的顺序。之所以是这个顺序是为了保证抛出异常的时候，新的对象需要被当前指针接管。这样就算再删除旧的对象的时候发生了异常，新的对象已经被当前指针接管了，不会产生悬空对象的问题。因为前两步都是指针之间的赋值，不会有什么异常的可能。但是删除销毁对象的时候则可能出现问题。</p><h3 id="operatorstdnullptr_t"><span class="mr-2">operator=(std::nullptr_t)</span><a href="#operatorstdnullptr_t" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">u = nullptr</code>和使用<code class="language-plaintext highlighter-rouge">reset</code>等效<ul><li>https://zh.cppreference.com/w/cpp/memory/unique_ptr/operator%3D</ul></ul><h2 id="可能的实现"><span class="mr-2">可能的实现</span><a href="#可能的实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>查看<code class="language-plaintext highlighter-rouge">uptr.cpp</code>。简陋版本。</p><h2 id="unique_ptr-做为函数入参如何传递比较好"><span class="mr-2">unique_ptr 做为函数入参如何传递比较好？</span><a href="#unique_ptr-做为函数入参如何传递比较好" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>看情况。</p><ul><li>一般情况强烈建议使用值传递。因为这显示了所有权转移。但是可能允许使用右值引用为形参。</ul><p>如：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Base</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">next</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span>
</pre></table></code></div></div><p>这时候我可以合法传递临时对象：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Base</span> <span class="nf">newBase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Base</span><span class="p">));</span>
</pre></table></code></div></div><p>传递非临时对象依旧必须使用<code class="language-plaintext highlighter-rouge">move</code>， <strong>但是会引发一个问题，让调用者困惑。</strong>:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">Base</span> <span class="nf">newBase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">nextBase</span><span class="p">));</span>
</pre></table></code></div></div><p>这个问题在于。在这一行之后，我们应该期望nextBase已经为空。因为move在那。但是这并不能保证。需要看函数内的代码。</p><ul><li>什么时候这一行会使得move过的指针<strong>不为空</strong>：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">funca</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptr</span><span class="p">){</span> <span class="c1">//注意我们的形参不是值传递，而是右值引用。所以我们没有拷贝，也没有赋值。什么都没做。引用传递不构造新对象对吧？右值引用也是引用呀。所以funca什么都没做。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="n">funca</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr1</span><span class="p">));</span> <span class="c1">//记住，这里move仅仅是static_cast成了一个右值引用的形式。这时候允许传入funca。具体是否要调用移动构造需要看funca是值传递还是引用传递。</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"not null"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
输出：
called 
not null
10
*/</span>
</pre></table></code></div></div><p>上面的代码看到，我们传入函数后没有对指针产生任何操作。所以是引用传入，然后什么也没干。从头到尾也只有第一行的<code class="language-plaintext highlighter-rouge">ptr1</code>和其在函数头的引用<code class="language-plaintext highlighter-rouge">ptr</code>在管理同一份资源。由于入参是引用，也没有double free。</p><p><strong>记住move只是把参数变为右值。至于什么时候触发移动构造或移动赋值，则需要我们进行赋值或构造的动作。在这里没有任何赋值或构造的动作，自然不会触发移动。</strong></p><ul><li>什么时候这一行会使得move过的指针<strong>为空</strong>：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">v</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="n">v</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">rhs</span><span class="p">)){}</span> <span class="c1">//注意这里，我们产生了构造动作。调用了移动构造。</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">funca</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&amp;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called "</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span> <span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="n">v</span> <span class="n">obj</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr1</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ptr1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"not null"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"null"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
输出
null
*/</span>
</pre></table></code></div></div><p>从上面的代码看到，我们的<code class="language-plaintext highlighter-rouge">v</code>类构造函数再次使用了<code class="language-plaintext highlighter-rouge">move</code>把入参移动赋值给了类内的<code class="language-plaintext highlighter-rouge">ptr</code>。因为这里有了构造动作，所以调用了移动构造。所以这时候入参的<code class="language-plaintext highlighter-rouge">rhs</code>会被移动到<code class="language-plaintext highlighter-rouge">ptr</code>。所以构造对象后，外部的<code class="language-plaintext highlighter-rouge">ptr1</code>为空。</p><ul><li><strong>所以如果使用右值引用做为入参，则调用方不能仅通过函数签名确定传入的智能指针的所有权是否会被转移，依旧需要看函数内部执行了什么，会产生困惑。</strong><li><p><strong>如果按照值传递，则传入前需要move接管所有权。此时外部的智能指针已经无效。函数返回后指向的资源会被释放。意味着这个指针（里面包裹的指针）一旦传入函数就不能在函数返回后继续使用。因为已经无效。</strong></p><li><strong>如果按照引用传递，则表明需要在该函数内修改传入的智能指针。所以又想要在函数调用后继续使用该指针，又不想修改传入的智能指针，最好的办法是使用常量左值引用。</strong></ul><p>https://stackoverflow.com/questions/8114276/how-do-i-pass-a-unique-ptr-argument-to-a-constructor-or-a-function</p><p>https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r33-take-a-unique_ptrwidget-parameter-to-express-that-a-function-reseats-thewidget</p><h1 id="shared_ptr"><code class="language-plaintext highlighter-rouge">shared_ptr</code></h1><p><code class="language-plaintext highlighter-rouge">std::shared_ptr</code>内部有引用计数，被复制时，引用计数+1（因为多个指针指向了同一个对象），有<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>析构时，引用计数-1，当引用计数为0时，析构持有的对象。引用就是计算有多少个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>指向了同一个对象。</p><ul><li><strong>注意，计数器为0释放资源的时候是通过控制块内的指向对象的指针释放的 （通过管理指针）。而不是通过外层的指向对象的指针释放的。（而不是通过存储指针）</strong></ul><p>引用计数的存在有以下性能影响：</p><ul><li><code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的大小是裸指针的两倍：一个指针指向持有的对象，一个指针指向控制块。<li>引用计数使用的内存必须动态分配，原因是<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的引用计数是非侵入式的，必须要独立在对象外面。用<code class="language-plaintext highlighter-rouge">std::make_shared</code>能避免这次单独的内存分配。<li>引用计数的加减必须是原子的，因此你必须假设读写引用计数是有成本的。</ul><p>注意，不是所有<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的构造都会增加引用计数，移动构造就不会。因此移动构造一个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>要比复制一个更快。</p><p>与<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>类似，<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的默认销毁动作也是<code class="language-plaintext highlighter-rouge">delete</code>，且也可以接受自定义的销毁器。但与<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>不同的是，<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的销毁器类型不必作为它的模板参数之一。</p><p>因此<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>要比<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>使用更灵活，比如不同销毁器的<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>可以放到同一个容器中，而<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>则不可以。</p><p>另外，不同的销毁器不会改变<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的大小。<code class="language-plaintext highlighter-rouge">std::shared_ptr</code><strong>内部需要为引用计数单独开辟一块内存</strong>，那么这块内存中再放一个销毁器也没什么额外开销。实际上这块内存被称为”控制块”，它里面包含以下元素：</p><ul><li>引用计数<li>弱引用计数 (由<code class="language-plaintext highlighter-rouge">weak_ptr</code>控制)<li>其它数据，包括：<ul><li>自定义销毁器<li>内存分配器<li><strong>一个指向对象的指针。但是这个指针的类型是对象的原始类型。</strong>这个指针可以叫管理指针。<ul><li>比如<code class="language-plaintext highlighter-rouge">shared_ptr&lt;father&gt; ptr(new child)</code>。这里控制块内指向对象的指针是<code class="language-plaintext highlighter-rouge">child</code>类的。而控制块外部另一个指向对象的指针是<code class="language-plaintext highlighter-rouge">father</code>类的。至于为什么，看下面的副作用。</ul></ul></ul><p>控制块的创建规则为：</p><ul><li><code class="language-plaintext highlighter-rouge">std::make_shared</code>总会创建一个控制块。<li>通过一个独享所有权的指针（如<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>或<code class="language-plaintext highlighter-rouge">std::auto_ptr</code>）创建出的<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>总会创建一个控制块。<ul><li>如<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>转为<code class="language-plaintext highlighter-rouge">shared_ptr</code>时会创建控制块，因为<code class="language-plaintext highlighter-rouge">unique_ptr</code>本身不使用控制块，同时<code class="language-plaintext highlighter-rouge">unique_ptr</code>置空）</ul><li>通过裸指针创建的<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>会创建控制块。<ul><li>这意味从同一个裸指针出发来构造不止一个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>时会创建多重的控制块，也意味着对象会被析构多次。如果想从一个己经拥有控制块的对象出发创建一个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>，可以传递一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>或<code class="language-plaintext highlighter-rouge">weak_ptr</code>而非裸指针作为构造函数的实参，这样则不会创建新的控制块。</ul><li><strong>再次重申，<code class="language-plaintext highlighter-rouge">shared_ptr</code>对象并不包含控制块本身，它包含的是指向控制块的指针。由此会引出<code class="language-plaintext highlighter-rouge">make</code>方法的缺点。</strong></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/shared_ptr.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/shared_ptr.png" alt="shared_ptr" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20220728115439.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20220728115439.png" alt="QQ截图20220728115439" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/1449936-20211201093930856-124882834-16591462032631.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/1449936-20211201093930856-124882834-16591462032631.png" alt="1449936-20211201093930856-124882834" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>从上图我们可以看到，一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>会有两个指针指向同一块堆区内存。一个是外面的那个指针叫做存储指针，一个是控制块里面的那个指针叫管理指针。两者类型并不一定相同。</strong><li><strong><code class="language-plaintext highlighter-rouge">shared_ptr</code> 持有的指针是通过 <code class="language-plaintext highlighter-rouge">get()</code>返回的（也就是外层的指针）；而控制块所持有的指针/对象则是最终引用计数归零时会被删除的那个。两者并不一定相等。</strong></ul><h2 id="创建指针-1"><span class="mr-2">创建指针</span><a href="#创建指针-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>       <span class="c1">//创建共享指针     </span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>               <span class="c1">//通过共享指针直接初始化共享指针。两个指针指向同一个数据，所以不新建控制块。引用计数+1</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>              <span class="c1">//可以通过赋值方法拷贝初始化共享指针。两个指针指向同一个数据，所以不新建控制块。引用计数+1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>           <span class="c1">//使用use_count查看引用计数。输出3</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>           <span class="c1">//输出3</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>           <span class="c1">//输出3</span>

<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr4</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>     <span class="c1">//使用make方法创建</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr4_1</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>    <span class="c1">//使用make方法直接初始化</span>
<span class="n">ptr4</span> <span class="o">=</span> <span class="n">ptr3</span><span class="p">;</span>                                        <span class="c1">//可以拷贝赋值。此时ptr4的控制块引用计数为0。因为被3覆盖了。所以ptr4指向的原始资源析构。ptr4此时和ptr3指向同一资源</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr4</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>                     <span class="c1">//共享控制块，此时为4。</span>

<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>            	<span class="c1">//不可以。禁止隐式转换。智能指针构造函数是explicit的。所以不允许使用带有隐式转换的拷贝初始化。但可以使用直接初始化</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5_1</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>    			<span class="c1">//可以 裸指针直接初始化</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr6</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">deleter</span><span class="p">);</span>      <span class="c1">//自定义删除器。无需指定类型名。</span>
</pre></table></code></div></div><h3 id="使用get来获取内部包含的普通指针-1"><span class="mr-2">使用<code class="language-plaintext highlighter-rouge">get()</code>来获取内部包含的普通指针</span><a href="#使用get来获取内部包含的普通指针-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>这个获取的指针指的是存储指针而非管理指针。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   
<span class="n">ptr5</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></table></code></div></div><h3 id="reset-1"><span class="mr-2">reset()</span><a href="#reset-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>当函数没有实参时，该函数会使当前 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针。当然，如果指向对象的引用计数为0，则释放资源。<strong>注意这个重置为空指针的行为包括剥离与原控制块的访问权限！！因为它已经是空指针，没有理由继续和源对象的控制块有关联。所以就算此时指向的对象计数仍不为0，但是由于此时是空指针，访问空指针的控制块自然会返回引用计数为0。因为空的shared_ptr对象没有控制块</strong><ul><li><strong>注意，释放资源是通过控制块内的指向对象的指针释放的 （通过管理指针）。而不是通过外层的指向对象的指针释放的。（而不是通过存储指针）</strong><ul><li>但是reset会置空整个指针。包括控制块。所以意思是存储指针和管理指针都会被剥离（满足条件时释放资源）</ul><li>通过新建临时对象后调用<code class="language-plaintext highlighter-rouge">swap()</code>实现。<code class="language-plaintext highlighter-rouge">shared_ptr().swap(*this);</code><ul><li><code class="language-plaintext highlighter-rouge">shared_ptr</code>的默认构造函数是<code class="language-plaintext highlighter-rouge">default</code>的。也就是什么都不做。不给控制块分配空间也不持有任何数据。</ul></ul><li>当为函数传递一个新申请的堆内存时，则调用该函数的<code class="language-plaintext highlighter-rouge"> shared_ptr </code>对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</ul><p>举例:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>		<span class="c1">//创建指针</span>
<span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>										<span class="c1">//它将引用计数减少1，同时将当前对象重置为一个空指针。如果引用计数变为0，则释放内存并且删除指针。</span>
<span class="n">p1</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">34</span><span class="p">));</span>							<span class="c1">//它将原对象引用计数减少1后指向新空间。</span>
</pre></table></code></div></div><p>注意：置空包括对控制块置空</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared1</span><span class="p">(</span><span class="n">shared</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//输出2</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//输出2</span>
<span class="n">shared1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="c1">//把shared1指向对象的引用计数器-1，并且置空shared1指针。包括指向对象的指针和指向控制块的指针</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//置空shared1输出0</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 	<span class="c1">//输出1</span>
</pre></table></code></div></div><p>我们看到，把<code class="language-plaintext highlighter-rouge">shared1</code>指向对象的引用计数器-1，并且置空<code class="language-plaintext highlighter-rouge">shared1</code>指针。包括指向对象的指针和指向控制块的指针。所以此时我们打印<code class="language-plaintext highlighter-rouge">shared1</code>的引用计数是0，如果打印<code class="language-plaintext highlighter-rouge">shared</code>的引用计数则是正常的1.</p><h4 id="unique"><span class="mr-2">unique()</span><a href="#unique" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>判断是否还有其他的共享指针指向当前指针指向的对象。</ul><h2 id="注意事项"><span class="mr-2">注意事项</span><a href="#注意事项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="通过一个裸指针创建两个stdshared_ptr会创建两个控制块进而导致这个裸指针会被析构两次"><span class="mr-2">通过一个裸指针创建两个<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>，会创建两个控制块，进而导致这个裸指针会被析构两次！</span><a href="#通过一个裸指针创建两个stdshared_ptr会创建两个控制块进而导致这个裸指针会被析构两次" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>所以</p><ol><li><p>不要直接用裸指针构造<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>，尽量用<code class="language-plaintext highlighter-rouge">std::make_shared</code>直接创建指针。当然在需要自定义的销毁器时不能用<code class="language-plaintext highlighter-rouge">std::make_shared</code>。</p><li><p>非要用<code class="language-plaintext highlighter-rouge">new</code>构造<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>的话，尽量直接new，不要传入已有的裸指针变量。比如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">myobj</span><span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> 
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>	<span class="c1">//ptr2有控制块</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>	<span class="c1">//ptr3也有控制块！这样会创建第二个。</span>
   
<span class="c1">//所以尽量直接这样new</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr4</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></table></code></div></div></ol><ul><li>有一种场景下，我们可能无意间创建了对应同一指针的两个控制块。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;&gt;</span> <span class="n">processedWidgets</span><span class="p">;</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">processedWidgets</code>表示所有处理过的<code class="language-plaintext highlighter-rouge">Widget</code>。进一步假设<code class="language-plaintext highlighter-rouge">Widget</code>有一个成员函数<code class="language-plaintext highlighter-rouge">process</code>：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">process</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">processedWidgets</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">// this is wrong!</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>如果被调用<code class="language-plaintext highlighter-rouge">process</code>的<code class="language-plaintext highlighter-rouge">Widget</code>对象本身就被<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>所管理，上面那行代码会导致它又创建了一个新的控制块。这种情况下我们应该令<code class="language-plaintext highlighter-rouge">Widget</code>继承自<code class="language-plaintext highlighter-rouge">std::enable_shared_from_this</code>，它允许创建一个指向自身控制块的<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Widget</span><span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">process</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">processedWidgets</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">shared_from_this</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>通过栈对象创建<code class="language-plaintext highlighter-rouge">shared_ptr</code>的时候一定要注意传入自定义删除器（接管资源管理）。因为共享指针在引用计数清零时会去<code class="language-plaintext highlighter-rouge">delete</code>指向的对象。但此时是个指向栈对象的指针。栈对象不能被<code class="language-plaintext highlighter-rouge">delete</code></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">deleter</span><span class="p">(</span><span class="n">myobj</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"deleter called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">//这里不能delete了 因为是栈对象。</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="n">deleter</span><span class="p">);</span> <span class="c1">//接管资源管理</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr1</span><span class="p">).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>不要将<code class="language-plaintext highlighter-rouge">this</code>指针返回给<code class="language-plaintext highlighter-rouge">shared_ptr</code></strong>。当希望将<code class="language-plaintext highlighter-rouge">this</code>指针托管给<code class="language-plaintext highlighter-rouge">shared_ptr</code>时，类需要继承自<code class="language-plaintext highlighter-rouge">std::enable_shared_from_this</code>，并且从<code class="language-plaintext highlighter-rouge">shared_from_this()</code>中获得<code class="language-plaintext highlighter-rouge">shared_ptr</code>指针。</ul><h2 id="并发安全"><span class="mr-2">并发安全</span><a href="#并发安全" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>多线程对同一个共享指针“写”是不安全的</strong></p><p>当我们在多线程回调中修改shared_ptr指向的时候。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">fn</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&amp;</span> <span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(..)</span> <span class="p">{</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">other_sp</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">sp</span> <span class="o">=</span> <span class="n">other_sp2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">shared_ptr</code>内数据指针要修改指向，<code class="language-plaintext highlighter-rouge">sp</code>原先指向对象的引用计数的值要减去1，<code class="language-plaintext highlighter-rouge">other_sp</code>指向的引用计数值要加1。<strong>然而这几步操作加起来并不是一个原子操作</strong>，如果多线程都在修改<code class="language-plaintext highlighter-rouge">sp</code>的指向的时候，那么有可能会出问题。比如在导致计数在操作减一的时候，其内部的指向，已经被其他线程修改过了。引用计数的异常会导致某个管理的对象被提前析构，后续在使用到该数据的时候触发core dump。</p><p>当然如果你没有修改指向的时候，是没有问题的。</p><p>https://juejin.cn/post/7038581008945872927</p><h2 id="shared_ptr做为函数入参是用值传递还是引用传递--最好使用值传递但是要具体情况具体分析"><span class="mr-2">shared_ptr做为函数入参是用值传递还是引用传递？ – 最好使用值传递。但是要具体情况具体分析。</span><a href="#shared_ptr做为函数入参是用值传递还是引用传递--最好使用值传递但是要具体情况具体分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>首先，对<code class="language-plaintext highlighter-rouge">shared_ptr</code>进行拷贝并不耗费特别多的资源。<li>其次，使用拷贝正是保证了在<code class="language-plaintext highlighter-rouge">shared_ptr</code>对象的作用域中，它一定能指向一个有效的内存对象这一假设。<li>假设：<strong>如果我们使用引用传递了这个智能指针，我们在作用域内正在使用这个智能指针的过程中，由于引用计数没有增加，那么可能导致在多线程中，外部的这个资源已经被释放了。</strong>因为可能外部的剩下的指向这个资源的智能指针已经超出了生命周期。<li>但是，如果可以确定不会有释放问题，则可以用引用传递稍微的减少开销。但是意义小。</ul><h3 id="所以传递shared_ptr参数在一般情况下还是用传值更好但是依旧要具体情况具体分析"><span class="mr-2">所以，传递shared_ptr参数在一般情况下还是用传值更好！但是依旧要具体情况具体分析。</span><a href="#所以传递shared_ptr参数在一般情况下还是用传值更好但是依旧要具体情况具体分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="函数返回值为shared_ptr解析"><span class="mr-2">函数返回值为shared_ptr解析</span><a href="#函数返回值为shared_ptr解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func1</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">func1</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//返回1</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p>为什么引用计数是1？</p><ul><li>因为求值运算符从右向左计算，所以首先调用函数，函数返回一个临时的智能指针。所以首先我们<code class="language-plaintext highlighter-rouge">func1</code>函数内<code class="language-plaintext highlighter-rouge">make_shared</code>生成（构造，调用构造）一个对象，此时引用计数为1。<li>然后<code class="language-plaintext highlighter-rouge">return</code>产生（拷贝初始化，调用拷贝构造）了一个临时对象，这时候引用计数为2<li>然后离开<code class="language-plaintext highlighter-rouge">func1</code>，对象被析构（调用析构），引用计数-1，此时为1。<li>然后回到<code class="language-plaintext highlighter-rouge">main</code>，拷贝构造（拷贝初始化，调用拷贝构造）给<code class="language-plaintext highlighter-rouge">ptr1</code>。引用计数+1，此时为2。同时，因为函数的返回值是临时对象，所以函数返回后会被销毁（调用析构）。引用计数-1，现在依旧是1。+1和-1其实是几乎同步发生的。因为是拷贝到栈帧后直接释放临时对象栈帧。</ul><h2 id="可能的实现-1"><span class="mr-2">可能的实现</span><a href="#可能的实现-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>查看<code class="language-plaintext highlighter-rouge">sptr.cpp</code>。简陋版本。</p><h2 id="enable_shared_from_this"><span class="mr-2">enable_shared_from_this</span><a href="#enable_shared_from_this" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>查看模板的21.2</p><p>注意使用问题：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">st</span><span class="o">:</span><span class="k">public</span> <span class="n">enable_shared_from_this</span><span class="o">&lt;</span><span class="n">st</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">st</span><span class="o">&gt;</span> <span class="n">getptr</span><span class="p">(){</span>
        <span class="k">return</span> <span class="n">shared_from_this</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">st</span> <span class="n">obj</span><span class="p">;</span><span class="c1">//错误</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">st</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">(</span><span class="k">new</span> <span class="n">st</span><span class="p">);</span><span class="c1">//正确</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">st</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">getptr</span><span class="p">();</span> <span class="c1">//别搞混了。访问储存的对象的成员函数用-&gt;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//访问shared_ptr本身的成员函数用.</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">shared_from_this</code>只能用在已经被托管在<code class="language-plaintext highlighter-rouge">shared_ptr</code>的对象上。具体原理在分析部分有。<li><strong>不能在构造自身的时候或构造函数中使用</strong>。<ul><li>核心原因：我们是继承自<code class="language-plaintext highlighter-rouge">enable_shared_from_this</code>。它先初始化，就算它初始化的时候储存的<code class="language-plaintext highlighter-rouge">weak_ptr</code>是延迟实例化，但是在我们自己的类被完全构造前，我们是不能构建<code class="language-plaintext highlighter-rouge">shared_ptr</code>指向自己的。因为构造函数未完成就是对象构建未完成。我们也不能使用<code class="language-plaintext highlighter-rouge">shared_ptr</code>储存一个不完整对象类型本身。因为此时<code class="language-plaintext highlighter-rouge">this</code>是不完整的</ul></ul><blockquote><p>只容许在先前共享的对象，即 <a href="http://zh.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 所管理的对象上调用 <code class="language-plaintext highlighter-rouge">shared_from_this</code> 。（特别是不能在构造 *this 期间 <code class="language-plaintext highlighter-rouge">shared_from_this</code> 。）</p></blockquote><p><a href="https://youtu.be/HglJp8cOOKY?si=Or59cZHBc4ukaD8R&amp;t=594">视频资料:Traps with Smart Pointers</a></p><p>http://hahaya.github.io/use-enable-shared-from-this</p><p>https://blog.csdn.net/gong_xucheng/article/details/26839069</p><p>https://www.cnblogs.com/fortunely/p/16370208.html</p><p>https://stackoverflow.com/questions/31924396/why-shared-from-this-cant-be-used-in-constructor-from-technical-standpoint</p><h1 id="weak_ptr"><code class="language-plaintext highlighter-rouge">weak_ptr</code></h1><p>有时候我们需要一种类似<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>，但又不参与这个共享对象的所有权的智能指针。这样它就需要能知道共享对象是否已经销毁了。这就是<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>。</p><ul><li><strong><code class="language-plaintext highlighter-rouge">std::weak_ptr</code>不是单独存在的，它不能解引用，也不能检测是否为空，它就是配合<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>使用的</strong>。</ul><p><code class="language-plaintext highlighter-rouge">std::weak_ptr</code>没有解引用和访问成员的功能。也就是不可以操作数据。而且不提供<code class="language-plaintext highlighter-rouge">get()</code>函数来获得裸指针。它只获得资源的观测权，不共享资源，它的构造不会引起指针强引用计数的增加。同样，在<code class="language-plaintext highlighter-rouge">weak_ptr</code>析构时也不会导致强引用计数的减少</p><p>一般来说，<code class="language-plaintext highlighter-rouge">weak_ptr</code>需要通过<code class="language-plaintext highlighter-rouge">shared_ptr</code>来创建。这样这两个指针会指向同一个数据。但是<code class="language-plaintext highlighter-rouge">weak_ptr</code>不会涉及到<code class="language-plaintext highlighter-rouge">shared_ptr</code>的强引用计数</p><ul><li><strong>使用<code class="language-plaintext highlighter-rouge">shared_ptr</code>创建了一个<code class="language-plaintext highlighter-rouge">weak_ptr</code>后，计数器内的弱引用计数器会+1， <code class="language-plaintext highlighter-rouge">weak_ptr</code>析构后，弱引用计数器会-1</strong></ul><h3 id="创建指针-2"><span class="mr-2">创建指针</span><a href="#创建指针-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>                 <span class="c1">//可以 直接初始化</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>                <span class="c1">//可以 隐式隐式转换后使用拷贝初始化。</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr4</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>                 <span class="c1">//可以 弱指针初始化弱指针</span>
<span class="n">ptr4</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">;</span>                                <span class="c1">//可以 拷贝赋值</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr5</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>         <span class="c1">//不可以使用裸指针初始化弱指针。   </span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr7</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">test1</span><span class="p">(</span><span class="n">ptr7</span><span class="p">);</span>                <span class="c1">//不可以使用unique指针初始化弱指针</span>
</pre></table></code></div></div><ul><li>可以使显式使用构造函数通过<code class="language-plaintext highlighter-rouge">weak_ptr</code>对象构建<code class="language-plaintext highlighter-rouge">shared_ptr</code>但是非常不推荐</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sptr</span><span class="p">(</span><span class="n">wkptr</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="reset-lock-use_count-expired"><span class="mr-2">reset(), lock(), use_count(), expired()</span><a href="#reset-lock-use_count-expired" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="use_count"><span class="mr-2"><code class="language-plaintext highlighter-rouge">use_count()</code></span><a href="#use_count" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><code class="language-plaintext highlighter-rouge">use_count()</code>返回对应弱指针绑定的共享指针的<strong>强引用计数</strong>。</ul><p>举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>       <span class="c1">//创建共享指针    </span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>   			<span class="c1">//引用计数+1</span>
<span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr3</span><span class="p">(</span><span class="n">ptr1</span><span class="p">);</span>                 <span class="c1">//创建弱指针</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//输出2</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//输出2</span>
</pre></table></code></div></div><p><strong>既然<code class="language-plaintext highlighter-rouge">weak_ptr</code>并不改变其所共享的<code class="language-plaintext highlighter-rouge">shared_ptr</code>实例的引用计数，那就可能存在<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向的对象被释放掉这种情况。这时，就不能使用<code class="language-plaintext highlighter-rouge">weak_ptr</code>直接访问对象。那么如何判断<code class="language-plaintext highlighter-rouge">weak_ptr</code>指向对象是否存在呢？使用<code class="language-plaintext highlighter-rouge">lock()</code> 或 <code class="language-plaintext highlighter-rouge">expired()</code>来进行判断。</strong></p><h4 id="lock--原子地检测对象是否有效并返回一个共享指针"><span class="mr-2"><code class="language-plaintext highlighter-rouge">lock()</code> – <strong>原子地</strong>检测对象是否有效并返回一个共享指针。</span><a href="#lock--原子地检测对象是否有效并返回一个共享指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>它能<strong>原子地</strong>检测对象是否有效。如果对象存在，<code class="language-plaintext highlighter-rouge">lock()</code>函数返回一个指向共享对象的<code class="language-plaintext highlighter-rouge">shared_ptr</code>(引用计数会增1)，否则返回一个空<code class="language-plaintext highlighter-rouge">shared_ptr</code>。所以<code class="language-plaintext highlighter-rouge">lock()</code>并不是简单的判断。它是通过查看控制块的强引用计数判断的。</ul><h4 id="expired--检测所指向的对象是否被销毁"><span class="mr-2"><code class="language-plaintext highlighter-rouge">expired()</code> – 检测所指向的对象是否被销毁</span><a href="#expired--检测所指向的对象是否被销毁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><code class="language-plaintext highlighter-rouge">expired()</code>函数用来判断所指对象是否已经被销毁。如果<code class="language-plaintext highlighter-rouge">use_count()</code>是0，则为<code class="language-plaintext highlighter-rouge">true</code>。</ul><h4 id="reset-2"><span class="mr-2">reset()</span><a href="#reset-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>将对应的弱指针置空。</ul><h1 id="使用lock和显式使用构造函数通过weak_ptr对象构建shared_ptr的区别">使用<code class="language-plaintext highlighter-rouge">lock()</code>和显式使用构造函数通过<code class="language-plaintext highlighter-rouge">weak_ptr</code>对象构建<code class="language-plaintext highlighter-rouge">shared_ptr</code>的区别</h1><ul><li>使用<code class="language-plaintext highlighter-rouge">lock()</code>的时候，如果其资源已被释放（强引用计数已为0），则会构造一个空的<code class="language-plaintext highlighter-rouge">shared_ptr</code>并返回。<li>如果显式使用构造函数，如果其资源已被释放（强引用计数已为0），则此构造函数会抛出异常。</ul><h1 id="几种指针的大小">几种指针的大小</h1><ul><li><code class="language-plaintext highlighter-rouge">unique_ptr</code>的大小是一个指针或两个指针<ul><li>一个指针的时候是不使用自定义删除器 或 使用了仿函数作为自定义删除器<li>两个指针大小的时候是使用了函数指针做为自定义删除器</ul><li><code class="language-plaintext highlighter-rouge">shared_ptr</code>的大小是两个指针。第一个指针指向的是对象，第二个指针指向的是控制块<li><code class="language-plaintext highlighter-rouge">weak_ptr</code>的大小是两个指针。<strong>推测原因：</strong>第一个指针指向的是对象，第二个指针指向的是控制块。因为<code class="language-plaintext highlighter-rouge">weak_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>，继承自同一个基类 <code class="language-plaintext highlighter-rouge">_Ptr_base</code>。这个基类有两个变量。一个是对象类型的指针<code class="language-plaintext highlighter-rouge">element_type* _Ptr</code>, 一个是指向控制块的指针<code class="language-plaintext highlighter-rouge">_Ref_count_base* _Rep</code></ul><h1 id="weak_ptr和shared_ptr共享控制块"><code class="language-plaintext highlighter-rouge">weak_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>共享控制块</h1><p>直到释放为止（手动或超出作用域），无论对应的共享指针和其指向的资源是否存在，弱指针都一直存在。只要弱指针还在，共享指针的控制块的弱引用计数就会在。控制块就不会被释放。所以这会产生下面的一个make方法的缺点。</p><h1 id="unique_ptr和shared_ptr之间的转换"><code class="language-plaintext highlighter-rouge">unique_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code>之间的转换</h1><ol><li><code class="language-plaintext highlighter-rouge">shared_ptr</code> 不可以转换为 <code class="language-plaintext highlighter-rouge">unique_ptr</code><ol><li>原因非常简单。转换的时候不能保证<code class="language-plaintext highlighter-rouge">shared_ptr</code>的对象现在只被一个指针拥有。而<code class="language-plaintext highlighter-rouge">unique_ptr</code>必须保证独占所有权。这种由宽到窄的所有权语义转换是说不过去的。</ol><li><code class="language-plaintext highlighter-rouge">unique_ptr</code>可以转换为 <code class="language-plaintext highlighter-rouge">shared_ptr</code>。 使用<code class="language-plaintext highlighter-rouge">move</code></ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myUnique</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="c1">//shared_ptr&lt;int&gt; myShared = move(myUnique); 也可以</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myShared</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">myUnique</span><span class="p">));</span>
    <span class="k">if</span><span class="p">(</span><span class="n">myUnique</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"unique释放"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myShared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
<span class="cm">/*输出 
unique释放 
1
*/</span>
</pre></table></code></div></div><ol><li><code class="language-plaintext highlighter-rouge">unique_ptr</code><strong>也可以隐式转换为</strong> <code class="language-plaintext highlighter-rouge">shared_ptr</code>。</ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></table></code></div></div><h1 id="shared_ptr指针的循环引用问题"><code class="language-plaintext highlighter-rouge">shared_ptr</code>指针的循环引用问题</h1><p>如下面代码所示：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">bptr</span><span class="p">;</span>
        <span class="o">~</span><span class="n">A</span><span class="p">(){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A destory"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="c1">//weak_ptr&lt;A&gt; aptr;</span>
    	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">aptr</span><span class="p">;</span>
        <span class="o">~</span><span class="n">B</span><span class="p">(){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B destory"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">aptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="p">{</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">classA</span><span class="p">(</span><span class="k">new</span> <span class="n">A</span><span class="p">());</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">classB</span><span class="p">(</span><span class="k">new</span> <span class="n">B</span><span class="p">());</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classA</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//1</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classB</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//1</span>
        <span class="n">classA</span><span class="o">-&gt;</span><span class="n">bptr</span> <span class="o">=</span> <span class="n">classB</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classA</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//1</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classB</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//2</span>
        <span class="n">classB</span><span class="o">-&gt;</span><span class="n">aptr</span> <span class="o">=</span> <span class="n">classA</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classA</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//2	//换成弱指针之后这里为1。因为弱指针不计数</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">classB</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">//2</span>
        <span class="c1">//所有的析构都不会执行。</span>
       	<span class="c1">//换成弱指针，所有析构正常执行。</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>当我们在两个类中互相包含一个指向对方类的<code class="language-plaintext highlighter-rouge">shared_ptr</code>的时候，会发生互相引用。这导致了每一个对象的引用计数都会永远至少保持为1。可以理解为两个指针互相都想让对方放开，但是两个人都必须等对方放开了自己才能放开对方。这样就发生了内存泄漏。</p><p>解决方案就是把其中一个类的共享指针换成弱指针。因为弱指针的引用不会增加计数。所以那个类的引用计数会到0从而正确释放。</p><p>如上面代码，把B的共享指针换成弱指针即可。</p><h1 id="more-effective-c-条款21">More Effective C++ 条款21</h1><p>先做一下介绍，<code class="language-plaintext highlighter-rouge">std::make_shared</code>是在C++11中增加的，但<code class="language-plaintext highlighter-rouge">std::make_unique</code>却是在C++14中增加的。如果你想在C++11中就用上<code class="language-plaintext highlighter-rouge">std::make_unique</code>，自己写一个简单版的也不难：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span><span class="n">Ts</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">params</span><span class="p">)...));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这个版本不支持数组，不支持自定义的销毁器，但这些都不重要，它足够用了。但要记住的是，不要把它放到<code class="language-plaintext highlighter-rouge">namespace std</code>下面。</p><p>这两个make函数的功能就不解释了，和它们类似的还有一个<code class="language-plaintext highlighter-rouge">std::allocate_shared</code>。</p><h2 id="make方法的优点"><span class="mr-2">make方法的优点</span><a href="#make方法的优点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h4 id="make方法是把传入参数完美转发至对象构造函数只需要传递参数即可无需再次new"><span class="mr-2">make方法是把传入参数完美转发至对象构造函数。只需要传递参数即可，无需再次new。</span><a href="#make方法是把传入参数完美转发至对象构造函数只需要传递参数即可无需再次new" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>第一个好处：不需要重复写一遍类型。所有程序员都知道：不要重复代码。代码越少，bug越少。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="nf">upw1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">upw2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>

<span class="k">auto</span> <span class="nf">spw1</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw2</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>第二个好处：异常安全性。想象我们有两个函数：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">computePriority</span><span class="p">();</span>
</pre></table></code></div></div><p>调用代码很可能长成这个样子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">computePriority</span><span class="p">());</span> <span class="c1">// potential resource leak!</span>
</pre></table></code></div></div><p>上面这行代码有内存泄漏的风险，为什么？根据C++标准，在<code class="language-plaintext highlighter-rouge">processWidget</code>的参数求值过程中，我们只能确定下面几点：</p><ul><li><code class="language-plaintext highlighter-rouge">new Widget</code>一定会执行，即一定会有一个<code class="language-plaintext highlighter-rouge">Widget</code>对象在堆上被创建。<li><code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;Widget&gt;</code>的构造函数一定会执行。<li><code class="language-plaintext highlighter-rouge">computePriority</code>一定会执行。</ul><p><code class="language-plaintext highlighter-rouge">new Widget</code>的结果是<code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;Widget&gt;</code>构造函数的参数，因此前者一定早于后者执行。除此之外，编译器不保证其它操作的顺序，即有可能执行顺序为：</p><ol><li><code class="language-plaintext highlighter-rouge">new Widget</code><li>执行<code class="language-plaintext highlighter-rouge">computePriority</code><li>构造<code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;Widget&gt;</code></ol><p>如果第2步抛异常，第1步创建的对象还没有被<code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;Widget&gt;</code>管理，就会发生内存泄漏。</p><p>如果这里我们用<code class="language-plaintext highlighter-rouge">std::make_shared</code>，就能保证<code class="language-plaintext highlighter-rouge">new Widget</code>和<code class="language-plaintext highlighter-rouge">std::shared_ptr&lt;Widget&gt;</code>是一起完成的，中间不会有其它操作插进来，即不会有不受智能指针保护的裸指针出现：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">computePriority</span><span class="p">());</span> <span class="c1">// no potential resource leak</span>
</pre></table></code></div></div><ul><li><strong>第三个好处：更高效。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nl">std:</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
</pre></table></code></div></div><p>这行代码中，我们以为只有一次内存分配，实际发生了两次，第二次是在分配<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>控制块。<strong>我们前文提到过，共享指针的控制块是单独建立在堆上的。所以如果使用直接<code class="language-plaintext highlighter-rouge">new</code>的方式，在分配完我们想要分配的变量后，系统会再次分配一块空间给控制块。所以分配了两次内存。</strong></p><p>但是如果用<code class="language-plaintext highlighter-rouge">std::make_shared</code>，它会把<code class="language-plaintext highlighter-rouge">Widget</code>对象和控制块合并为一次内存分配。<strong>但是这也会成为缺点</strong></p><h2 id="make方法的缺点"><span class="mr-2">make方法的缺点</span><a href="#make方法的缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>第一个缺点：无法传入自定义删除器。</p><ul><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">_Args</span><span class="p">&gt;</span>
    <span class="kr">inline</span> <span class="k">typename</span> <span class="n">_MakeUniq</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">__single_object</span>
    <span class="nf">make_unique</span><span class="p">(</span><span class="n">_Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">__args</span><span class="p">){</span> 
        <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">_Tp</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__args</span><span class="p">)...));</span> 
    <span class="p">}</span>
</pre></table></code></div></div><li>这里返回的是默认删除器类型的<code class="language-plaintext highlighter-rouge">unique_ptr</code>。<li>来自<a href="https://www.misteo.top/2020/11/30/std-unique-ptr%E4%BD%BF%E7%94%A8incomplete-type%E7%9A%84%E6%8A%A5%E9%94%99%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%A3%E5%86%B3/">这里</a></ul><li>第二个缺点：无法使用列表初始化。必须用<code class="language-plaintext highlighter-rouge">auto</code>先推导出来一个<code class="language-plaintext highlighter-rouge">initializer_list</code>然后把初始化列表传入。<li><strong>第三个缺点：对象和控制块分配在一块内存上，减少了内存分配的次数，但也导致对象和控制块占用的内存也要一次回收掉</strong>。即，如果还有<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>存在，控制块就要在（因为控制块中有一块弱引用，储存着弱指针的引用），对象占用的内存也没办法回收。如果对象比较大，且<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>在对象析构后还可能长期存在，那么这种开销是不可忽视的。也就是假如<code class="language-plaintext highlighter-rouge">shared_ptr</code>本身被析构了（因为自己和控制块是分开的），<code class="language-plaintext highlighter-rouge">weak_ptr</code>可能过了很久才被析构。这样这一大块内存就都要存在，因为用<code class="language-plaintext highlighter-rouge">make</code>方法分配的是一整块</ul><p>如果我们因为前面这三个缺点而不能使用<code class="language-plaintext highlighter-rouge">std::make_shared</code>，那么我们要保证，智能指针的构造一定要单独一个语句。回到之前<code class="language-plaintext highlighter-rouge">processWidget</code>的例子中，假设我们有个自定义的销毁器<code class="language-plaintext highlighter-rouge">void cusDel(Widget* ptr);</code>，因此不能使用<code class="language-plaintext highlighter-rouge">std::make_shared</code>，那么我们要这么写来保证异常安全性：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">cusDel</span><span class="p">);</span>
<span class="n">processWidget</span><span class="p">(</span><span class="n">spw</span><span class="p">,</span> <span class="n">computePriority</span><span class="p">());</span>
</pre></table></code></div></div><p>但这么写还不够高效，这里我们明确知道<code class="language-plaintext highlighter-rouge">spw</code>就是给<code class="language-plaintext highlighter-rouge">processWidget</code>用的，那么可以使用<code class="language-plaintext highlighter-rouge">std::move</code>，将其转为右值，来避免对引用计数的修改：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">,</span> <span class="n">cusDel</span><span class="p">);</span>
<span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> <span class="n">computePriority</span><span class="p">());</span>
</pre></table></code></div></div><ul><li>不适于使用 <code class="language-plaintext highlighter-rouge">make</code> 系列函数的场景包括<ul><li>需要定制删除器，<li>期望直接传递大括号初始化物<li>需要自定义内存管理（自定义删除器）<li>内存紧张的系统<li>非常大的对象<li>存在比指涉到相同对象的 <code class="language-plaintext highlighter-rouge">std: :shared_ptr</code> 生存期史久的 <code class="language-plaintext highlighter-rouge">std: :weak_ptr</code></ul></ul><h1 id="稍微具体说一下自定义删除器为什么用类的时候不增加大小用函数指针的时候会增加大小">稍微具体说一下自定义删除器为什么用类的时候不增加大小，用函数指针的时候会增加大小</h1><p>先看一下<code class="language-plaintext highlighter-rouge">unique_ptr</code>的析构</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">_Compressed_pair</span><span class="o">&lt;</span><span class="n">_Dx</span><span class="p">,</span> <span class="n">pointer</span><span class="o">&gt;</span> <span class="n">_Mypair</span><span class="p">;</span> 		<span class="c1">//mypair定义。_Dx是自定义删除器类型</span>
<span class="o">~</span><span class="n">unique_ptr</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_Mypair</span><span class="p">.</span><span class="n">_Myval2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_Mypair</span><span class="p">.</span><span class="n">_Get_first</span><span class="p">()(</span><span class="n">_Mypair</span><span class="p">.</span><span class="n">_Myval2</span><span class="p">);</span> <span class="c1">// call deleter</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里用<code class="language-plaintext highlighter-rouge">_Get_first</code>把<code class="language-plaintext highlighter-rouge">_Mypair</code>的第一个数据也就是自定义删除器提取出来，然后用<code class="language-plaintext highlighter-rouge">（）</code>创建临时对象，然后把数据塞入这个临时对象的<code class="language-plaintext highlighter-rouge">operator()</code>里面完成资源释放。</p><p><strong>但是这个_Compressed_pair</strong>有两个特化版本。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// store a pair of values, deriving from empty first</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty2</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">=</span> <span class="n">is_empty_v</span><span class="o">&lt;</span><span class="n">_Ty1</span><span class="p">&gt;</span> <span class="o">&amp;&amp;</span> 
                                         <span class="o">!</span><span class="n">is_final_v</span><span class="o">&lt;</span><span class="n">_Ty1</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">_Compressed_pair</span> <span class="k">final</span> <span class="o">:</span> <span class="k">private</span> <span class="n">_Ty1</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">_Ty2</span> <span class="n">_Myval2</span><span class="p">;</span>
    
    <span class="c1">// ... the rest of impl</span>
<span class="p">}</span>

<span class="c1">// store a pair of values, not deriving from first</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">_Compressed_pair</span><span class="o">&lt;</span><span class="n">_Ty1</span><span class="p">,</span> <span class="n">_Ty2</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="k">final</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">_Ty1</span> <span class="n">_Myval1</span><span class="p">;</span>
    <span class="n">_Ty2</span> <span class="n">_Myval2</span><span class="p">;</span>
    
    <span class="c1">// ... the rest of impl</span>
<span class="p">}</span>


</pre></table></code></div></div><p>先看第二个版本，这个很直观，基本就是普通的 <code class="language-plaintext highlighter-rouge">std::pair</code> 的定义。</p><p>而当 <code class="language-plaintext highlighter-rouge">_Ty1</code> (自定义删除器)是一个空类时，则会特化为第一个版本。这里 <code class="language-plaintext highlighter-rouge">_Ty2</code> 依然作为一个普通的成员，但 <code class="language-plaintext highlighter-rouge">_Ty1</code> 却通过继承的方式内嵌到 <code class="language-plaintext highlighter-rouge">_Compressed_pair</code> 中。乍一看这好像有点不伦不类，毕竟从概念上来说 <code class="language-plaintext highlighter-rouge">_Compressed_pair</code> 和 <code class="language-plaintext highlighter-rouge">_Ty1</code> 似乎不应该是继承的关系。但注意这里用的是 private 继承，相较于 public 继承表达的 <code class="language-plaintext highlighter-rouge">is-a</code> 关系，private 继承隐含的意思其实是 <code class="language-plaintext highlighter-rouge">is-implemented-in-terms-of</code>，即「由…实现出」。这就说得通了，<code class="language-plaintext highlighter-rouge">_Ty1</code> 是组成 <code class="language-plaintext highlighter-rouge">_Compressed_pair</code> 的一部分，反过来 <code class="language-plaintext highlighter-rouge">_Compressed_pair</code> 是由 <code class="language-plaintext highlighter-rouge">_Ty1</code> 实现的。这也是为什么很多情况下，组合和 private 继承这两种设计可以互换的原因，详细内容可以参阅 《Effective C++》Item 38。</p><p><strong>空类继承不会增加体积。因为有空基类优化。所以传入一个仿函数（无成员变量，所以是空类）的时候会匹配到第一个模板，使用空基类优化使得不需要额外空间。</strong></p><p><strong>所以如果自定义删除器传入一个函数指针，因为不是空类而是一个函数指针，会被匹配到第二个模板。所以会把函数指针在<code class="language-plaintext highlighter-rouge">_Ty1 _Myval1;</code>这里存下来。就多了一个指针。</strong></p><h2 id="为什么删除器是unique_ptr的模板参数之一是类型的一部分-而shared_ptr不是"><span class="mr-2">为什么删除器是unique_ptr的模板参数之一(是类型的一部分), 而shared_ptr不是？</span><a href="#为什么删除器是unique_ptr的模板参数之一是类型的一部分-而shared_ptr不是" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">D</span> <span class="o">=</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">unique_ptr</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="n">unique_ptr</span> <span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">,</span>
        <span class="k">typename</span> <span class="n">conditional</span><span class="o">&lt;</span><span class="n">is_reference</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;&gt;</span> <span class="n">del</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="k">class</span> <span class="nc">shared_ptr</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="p">...</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">U</span><span class="p">,</span> <span class="k">class</span> <span class="nc">D</span><span class="p">&gt;</span> 
    <span class="n">shared_ptr</span> <span class="p">(</span><span class="n">U</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">D</span> <span class="n">del</span><span class="p">);</span> <span class="c1">//删除器只是构造函数参数的一部分，而不是shared_ptr类型的一部分</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>首先，为了尽可能让<code class="language-plaintext highlighter-rouge">unique_ptr</code>的性能贴近裸指针，比如在删除器为非函数指针的时候，可以触发空基类优化，使得无需额外空间。其次，主要的一点是<code class="language-plaintext highlighter-rouge">unique_ptr</code>的删除器是编译时绑定的，所以我们必须显式指定其类型。而<code class="language-plaintext highlighter-rouge">shared_ptr</code>的删除器是运行期绑定的，所以不需要。正因为共享指针的删除器是运行时绑定，则必须要有一个额外的指针（控制块）指向（保存）删除器来让共享指针可以访问。因为删除器的类型是运行时绑定所以直到运行的时候才能知道。所以调用删除器的时候会有一次额外的寻址操作。</p><p>另外，正因为如此，<code class="language-plaintext highlighter-rouge">unique_ptr</code>的删除器，在使用<code class="language-plaintext highlighter-rouge">reset</code>更换的时候只可以更换同类型的删除器。而<code class="language-plaintext highlighter-rouge">shared_ptr</code>的删除器可以在<code class="language-plaintext highlighter-rouge">reset</code>的时候随意更换。因为类成员类型在运行期间是不可以改变的。而删除器的类型不是共享指针的一部分。</p><p>（此部分参照了c++ primer P.599)</p><p>https://fuzhe1989.github.io/2017/05/19/cpp-different-role-of-deleter-in-unique-ptr-and-shared-ptr/</p><p>https://stackoverflow.com/questions/24365250/why-does-stdunique-ptr-need-to-be-specialized-for-dynamic-arrays</p><h1 id="lambda和智能指针之间的联系-小米面经">lambda和智能指针之间的联系 （小米面经）</h1><h2 id="用lambda捕获uniqueptr应该怎么做--必须按照引用捕获"><span class="mr-2">用lambda捕获uniquePtr应该怎么做 – 必须按照引用捕获</span><a href="#用lambda捕获uniqueptr应该怎么做--必须按照引用捕获" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>lambda我们知道，如果按值捕获，他会对捕获的对象进行一个拷贝。因为可以把lambda对象理解为一个匿名类，那么捕获的变量就是这个匿名类的成员变量。这个匿名类重载了<code class="language-plaintext highlighter-rouge">operator()</code>并且设置其为<code class="language-plaintext highlighter-rouge">const</code></strong></p><p>但是，unique_ptr是所有权语义。它不允许被拷贝。所以必须按照引用捕获。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">unique</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">a</span><span class="p">;};</span> <span class="c1">//报错，因为unique_ptr不允许拷贝。</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">a</span><span class="p">;};</span>
    <span class="n">lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出15</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是这样做也不好，会有语义问题。参考：https://zhuanlan.zhihu.com/p/101938827 和 下面的问题</p><h2 id="lambda捕获uniqueptr后如何避免调用lambda时uniqueptr的指针已失效--使用c14的移动捕获通用捕获使用带有初始化器的捕获符捕获仅可移动的类型"><span class="mr-2">lambda捕获uniquePtr后如何避免调用lambda时uniquePtr的指针已失效 – 使用c++14的移动捕获（通用捕获）[使用带有初始化器的捕获符捕获仅可移动的类型。]</span><a href="#lambda捕获uniqueptr后如何避免调用lambda时uniqueptr的指针已失效--使用c14的移动捕获通用捕获使用带有初始化器的捕获符捕获仅可移动的类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>也是为了解决上面的语义问题，我们应该把unique_ptr移入到lambda， 如果想的话也可以再移回原指针。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">unique</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">temp_unique</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">unique</span><span class="p">)](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="k">mutable</span><span class="p">{</span>  <span class="c1">//注释1</span>
        <span class="n">temp_unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">temp_unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">unique</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">temp_unique</span><span class="p">);</span> <span class="c1">//注释2</span>
        <span class="p">};</span>
    <span class="n">lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">unique</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//上面这个例子并不太好。因为我们做的事情是：引用捕获unique，然后把unique移动到一个新建的lambda内局部变量temp上。</span>
<span class="c1">//然后对temp进行处理，然后再移动到unique上。这也是为什么必须有一个&amp;来引用捕获unique。这完全脱裤子放屁</span>
<span class="c1">//所以正常这种情况下的使用方式应该是移动进lambda后，外部不会再使用该智能指针</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">unique</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="n">temp_unique</span> <span class="o">=</span> <span class="n">move</span><span class="p">(</span><span class="n">unique</span><span class="p">)](</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="k">mutable</span><span class="p">{</span>  <span class="c1">//移动进来</span>
        <span class="n">temp_unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">temp_unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">temp_unique</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//对数据处理。</span>
        <span class="p">};</span>
    <span class="n">lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="c1">//外部并不会再次使用unique指针。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>注释1<ul><li>这里有一个看起来很奇怪的东西。<code class="language-plaintext highlighter-rouge">temp_unique = move(unique)</code>。这个东西叫做带有初始化器的捕获符（列表）[来自校友赖斯理大佬的博客https://lesleylai.info/zh/c++-lambda/#fn-3]<li>等号左侧是表达式中数据成员的名称，这个是由你自由决定的。等号右侧是初始化表达式，用于初始化数据成员。<strong>等号左右两侧的作用域是不同的，左侧的作用域在lambda表达式中，而右侧的作用域在表达式定义的区域</strong>。在上面的例子中，等号左侧的<code class="language-plaintext highlighter-rouge">temp_unique </code>指的是lambda中的数据成员，而右侧则是在lambda表达式上方定义的<code class="language-plaintext highlighter-rouge">unique</code>。因此<code class="language-plaintext highlighter-rouge">temp_unique = move(unique)</code>意味着在lambda中创建一个数据成员<code class="language-plaintext highlighter-rouge">temp_unique</code>，并且用<code class="language-plaintext highlighter-rouge">std::move</code>一个本地变量的<code class="language-plaintext highlighter-rouge">unique</code>以初始化这个数据成员。</ul><li>注释2<ul><li>这里不可以写成<code class="language-plaintext highlighter-rouge">unique(move(temp_unique));</code>因为这个叫函数调用。调用了一个叫<code class="language-plaintext highlighter-rouge">unique</code>的函数。</ul></ul><h2 id="用lambda捕获sharedptr要怎么做--值捕获避免调用时sharedptr对象已销毁"><span class="mr-2">用lambda捕获sharedPtr要怎么做 – 值捕获，避免调用时sharedPtr对象已销毁</span><a href="#用lambda捕获sharedptr要怎么做--值捕获避免调用时sharedptr对象已销毁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>创建shared_ptr的引用不会改变其强引用计数器或弱引用计数器。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared2</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出2</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;&amp;</span> <span class="n">sharedref</span> <span class="o">=</span> <span class="n">shared</span><span class="p">;</span> <span class="c1">//创建引用</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//依旧输出2</span>
</pre></table></code></div></div><p>所以假如我们按照引用捕获了（再次强调，引用捕获相当于在匿名类内部创建了一个入参的引用类型的类成员变量），我们也知道了创建shared_ptr的引用不会改变其强引用计数器或弱引用计数器。所以会导致计数器并不会增加。这样，有可能外部该<code class="language-plaintext highlighter-rouge">shared_ptr</code>的计数器已经清零并且析构了，我们内部才刚要进行调用。</p><p>比如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//错误地按照引用捕获</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
    <span class="p">};</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">//计数器-1，如果为0就释放。此时已经释放了</span>
    <span class="n">lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//崩溃</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shared</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"in lambda:"</span> <span class="o">&lt;&lt;</span><span class="n">shared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出1</span>
    <span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"out lambda:"</span> <span class="o">&lt;&lt;</span><span class="n">shared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出2</span>
    <span class="n">shared</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">//reset的是全局作用域的shared。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"out lambda:"</span> <span class="o">&lt;&lt;</span><span class="n">shared</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出0 不要惊讶</span>
    <span class="n">lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>不要惊讶为什么输出0后lambda内部输出1。我们解释一下</p><p>首先我们按值捕获一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>，相当于两个指针共享一份数据和一个数据块。<code class="language-plaintext highlighter-rouge">reset</code>全局作用域的<code class="language-plaintext highlighter-rouge">shared</code>后，我们提到过，这个<code class="language-plaintext highlighter-rouge">reset</code>不仅会给引用计数-1，而且会把自己置空，也就是自己的指向控制器的指针置空，自然就是0。详细的看一下上面<code class="language-plaintext highlighter-rouge">reset</code>使用部分。</p><p>但是我们<code class="language-plaintext highlighter-rouge">lambda</code>作用域内的<code class="language-plaintext highlighter-rouge">shared</code>依旧存在，所以它的引用计数器是正常的1。</p><h2 id="捕获sharedptr时如果不想延长对象生命周期怎么做先赋值给weakptr再捕获"><span class="mr-2">捕获sharedPtr时如果不想延长对象生命周期怎么做（先赋值给weakPtr,再捕获）</span><a href="#捕获sharedptr时如果不想延长对象生命周期怎么做先赋值给weakptr再捕获" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这问题好没劲。</p><p>就是假设有一个情况，我们这个lambda挺无关紧要的，我不希望在外面我想释放<code class="language-plaintext highlighter-rouge">shared_ptr</code>的时候还要等lambda里面的<code class="language-plaintext highlighter-rouge">shared_ptr</code>释放后再释放。我们就可以新建一个<code class="language-plaintext highlighter-rouge">weak_ptr</code>, 然后把这个<code class="language-plaintext highlighter-rouge">weak_ptr</code>传入lambda。j记得每次使用的时候需要先用<code class="language-plaintext highlighter-rouge">lock</code>或者<code class="language-plaintext highlighter-rouge">expired</code>判断一下是否有效。</p><h1 id="实现一个简单的make_unique">实现一个简单的make_unique</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="c1">//变长参数模板</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">my_make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span> <span class="c1">//函数会返回unique_ptr</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span> <span class="c1">//使用完美转发至对象的构造函数。构造智能指针。</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="实现一个简单的make_shared">实现一个简单的make_shared</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="c1">//变长参数模板</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">my_make_shared</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span> <span class="c1">//函数会返回unique_ptr</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span> <span class="c1">//使用完美转发至对象的构造函数。构造智能指针。</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="shared_ptr不能直接协变">shared_ptr不能直接协变</h1><ul><li><code class="language-plaintext highlighter-rouge">shared_ptr</code>不能直接协变，需要转换一下。参考<a href="https://stackoverflow.com/questions/6924754/return-type-covariance-with-smart-pointers">这篇文章</a></ul><p>个人理解是因为他找不到<code class="language-plaintext highlighter-rouge">shared_ptr&lt;Base&gt;</code>和<code class="language-plaintext highlighter-rouge">shared_ptr&lt;Derive&gt;</code>之间的直接联系</p><h1 id="通过构造函数创建shared_ptr对象一个非常牛逼的副作用-shared_ptr-可以正确地通过基类指针析构整个对象即使基类没有定义基类析构函数为虚析构">通过构造函数创建<code class="language-plaintext highlighter-rouge">shared_ptr</code>对象一个非常牛逼的副作用 ：<code class="language-plaintext highlighter-rouge">shared_ptr</code> 可以正确地通过基类指针析构整个对象，即使基类没有定义基类析构函数为虚析构。</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="c1">// no virtual here</span>
    <span class="o">~</span><span class="n">Base</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"~Base</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="o">~</span><span class="n">Derived</span><span class="p">()</span>
    <span class="p">{</span>
    	<span class="n">printf</span><span class="p">(</span><span class="s">"~Derived</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="n">Derived</span><span class="p">());</span> <span class="c1">//输出 ~Base 和 ~Derived</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">sp2</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">//输出 ~Base 和 ~Derived</span>
    <span class="n">Base</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span> <span class="c1">//只输出~Base</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这个“特性”目前是 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 独有的，<code class="language-plaintext highlighter-rouge">make_shared</code>也可以。我们可以通过研究代码来理解为什么可以这样做。</p><p>我们提到过，控制块内有一个储存数据实际类型的指针。从一开始 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 的构造函数到这里的 <code class="language-plaintext highlighter-rouge">_Ref_count</code>，所有相关函数都是 template，类型逐层传递保证 <code class="language-plaintext highlighter-rouge">_Ref_count::_Ptr</code> 是 heap 对象的<strong>实际类型</strong>，这意味着这个 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 实现了在内部保存了管理对象的实际类型，并且 <code class="language-plaintext highlighter-rouge">_Ref_count::_Destroy()</code> 是直接对实际类型进行 <code class="language-plaintext highlighter-rouge">delete</code>。</p><p>所以，哪怕基类的析构函数不是 virtual，<code class="language-plaintext highlighter-rouge">sp</code> 一样能够正确析构。</p><p>假设我们现在有个例子是</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">father</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">child</span><span class="p">);</span>
</pre></table></code></div></div><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054220.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054220.png" alt="微信图片_20221121054220" class="lazyload" data-proofer-ignore></a></p><ul><li>从上图我们看到了，模板类的类型也就是<code class="language-plaintext highlighter-rouge">shared_ptr&lt;&gt;</code>里面写的是<code class="language-plaintext highlighter-rouge">_Ty</code>，而放到构造函数里面的也就是<code class="language-plaintext highlighter-rouge">new</code>的对象的类型是<code class="language-plaintext highlighter-rouge">_Ux</code>。<code class="language-plaintext highlighter-rouge">_UX</code>的类型会被自动推导不必显式指定。因为是函数模板。<ul><li><code class="language-plaintext highlighter-rouge">new child</code>返回的指针类型是<code class="language-plaintext highlighter-rouge">child</code></ul></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054225.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054225.png" alt="微信图片_20221121054225" class="lazyload" data-proofer-ignore></a></p><ul><li>上图的析构是调用<code class="language-plaintext highlighter-rouge">_Decref</code></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121054320.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121054320.png" alt="QQ截图20221121054320" class="lazyload" data-proofer-ignore></a></p><ul><li><code class="language-plaintext highlighter-rouge">_Decref</code>会在资源真正需要被销毁的时候调用<code class="language-plaintext highlighter-rouge">_Destroy</code></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054230.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20221121054230.png" alt="微信图片_20221121054230" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>这里的传入<code class="language-plaintext highlighter-rouge">_Ref_count</code>的<code class="language-plaintext highlighter-rouge">_Ty</code>类型就是刚才传入的<code class="language-plaintext highlighter-rouge">_Ux</code>。也就是实际数据类型<code class="language-plaintext highlighter-rouge">child</code>。调用<code class="language-plaintext highlighter-rouge">_Destroy</code>的时候直接<code class="language-plaintext highlighter-rouge">delete</code>的是<code class="language-plaintext highlighter-rouge">child</code>。所以可以正确释放。</strong><li><code class="language-plaintext highlighter-rouge">_Ref_count_base</code>就是控制块基类。</ul><p><a href="https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/">大佬的<code class="language-plaintext highlighter-rouge">shared_ptr</code>解析</a></p><p>https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/</p><h1 id="shared_ptr的别名构造函数-alias-constructor-">shared_ptr的别名构造函数 （Alias Constructor ）</h1><p><strong>这个别名构造再标准库里的enable_shared_from_this中使用了。</strong></p><p>通过上面的部分，我们理解了在<code class="language-plaintext highlighter-rouge">shared_ptr</code>中，指向对象的指针和控制块内指向对象的指针是完全独立的。后面的特征通过了<code class="language-plaintext highlighter-rouge">Type erasure</code> 而逃过了编译器的类型检查。内部控制块的模板参数（控制块内指向对象的指针的类型）和外部智能指针的模板参数（单独指向对象的那个指针的类型）毫无干系, 因此控制块指针和存储指针本质上是完全独立的.</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Y</span> <span class="p">&gt;</span>
<span class="n">shared_ptr</span><span class="p">(</span> <span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="n">element_type</span><span class="o">*</span> <span class="n">ptr</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><em>别名使用构造函数</em>：构造 <code class="language-plaintext highlighter-rouge">shared_ptr</code> ，与 <code class="language-plaintext highlighter-rouge">r</code> 的初始值共享所有权信息，但保有无关且不管理的指针 <code class="language-plaintext highlighter-rouge">ptr</code> 。若此 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 是离开作用域的组中的最后者，则它将调用最初 <code class="language-plaintext highlighter-rouge">r</code> 所管理对象的析构函数。<strong>然而，在此 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 上调用 <code class="language-plaintext highlighter-rouge">get()</code> 将始终返回 <code class="language-plaintext highlighter-rouge">ptr</code> 的副本</strong>。程序员负责确保只要此 <code class="language-plaintext highlighter-rouge">shared_ptr</code> 存在，此 <code class="language-plaintext highlighter-rouge">ptr</code> 就保持合法，<strong>例如在典型使用情况中，其中 <code class="language-plaintext highlighter-rouge">ptr</code> 是 <code class="language-plaintext highlighter-rouge">r</code> 所管理对象的成员</strong>，或是 <code class="language-plaintext highlighter-rouge">r.get()</code> 的别名（例如向下转型）。<a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr">来自cppreference</a><li>和拷贝构造函数一样。除了存储指针不同 <a href="https://cplusplus.com/reference/memory/shared_ptr/shared_ptr/">来自cplusplus</a><li>注意，使用的时候算作对指针<code class="language-plaintext highlighter-rouge">r</code>的资源的一次额外使用。也就是强引用计数+1。 <a href="https://cplusplus.com/reference/memory/shared_ptr/shared_ptr/">来自cplusplus</a><li>这句话翻译过来就是，这个指针的控制块使用的是<code class="language-plaintext highlighter-rouge">r</code>的(共享控制块) <em>[与 <code class="language-plaintext highlighter-rouge">r</code> 的初始值共享所有权信息]</em>。但是实际指向的数据是<code class="language-plaintext highlighter-rouge">ptr</code>的 <em>[但保有无关且不管理的指针 <code class="language-plaintext highlighter-rouge">ptr</code>]</em><ul><li>控制块使用的是<code class="language-plaintext highlighter-rouge">r</code>的 ，这句话代表了管理指针是指向<code class="language-plaintext highlighter-rouge">r</code>的。<li>实际指向的数据是<code class="language-plaintext highlighter-rouge">ptr</code>的代表存储指针是指向<code class="language-plaintext highlighter-rouge">ptr</code>的。<li>白话就是，只要<code class="language-plaintext highlighter-rouge">r</code>的计数器为0，就该释放<code class="language-plaintext highlighter-rouge">ptr</code>的资源了，我不管有没有人用。</ul></ul><p>第一部分：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
	<span class="o">~</span><span class="n">myobj</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj析构 "</span><span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">;</span>

<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">{</span> <span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">};</span><span class="c1">//sp1是共享对象（也就是new出来的Person）的唯一拥有者。此时控制指针和储存指针都指向myobj(5)</span>
	<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">{</span> <span class="n">sp1</span><span class="p">,</span><span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">};</span><span class="c1">//现在sp1,sp2都是共享对象的拥有者。但是注意，此时sp2的控制块和sp1共享。也就是此时sp1的引用计数和sp2的引用计数均为2。但是sp2的存储指针被替换为指向myobj(6)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//get返回存储指针，此处输出5</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//get返回存储指针，此处输出6</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="s">", "</span><span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//2，2 此时sp1的引用计数和sp2的引用计数均为2。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>上面的注释已经很详细了，但是还有一点，这里大家发现了有内存泄漏。<ul><li>因为<code class="language-plaintext highlighter-rouge">sp2</code>和<code class="language-plaintext highlighter-rouge">sp1</code>共享控制块，所以他们其实只对<code class="language-plaintext highlighter-rouge">myobj(5)</code>这个资源负责。而sp2的存储指针被替换为<code class="language-plaintext highlighter-rouge">myobj(6)</code>，但是并没有指针管理。所以这块内存是泄漏的。<li>没有指针管理<code class="language-plaintext highlighter-rouge">myobj(6)</code>是因为我们说过，<code class="language-plaintext highlighter-rouge">shared_ptr</code>的资源释放，释放的是管理指针指向的对象而非存储指针。</ul></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121094127.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121094127.png" alt="QQ截图20221121094127" class="lazyload" data-proofer-ignore></a></p><p>第二部分：</p><p>我们继续上面的代码往下写：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">sp1</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">//此时，sp1置空。和资源myobj(5)，控制块都毫无关联。所以sp1存储指针为空，控制块依旧为空。因为已经和之前的控制块没有关系。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="s">", "</span><span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//0, 1</span>
<span class="k">if</span><span class="p">(</span><span class="n">sp1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">){</span> <span class="c1">//输出true。因为确实是空指针了。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"true"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//这时候sp2依旧掌握myobj(6)</span>
</pre></table></code></div></div><ul><li>注释已经详细说明了。</ul><p>第三部分：</p><p>我们继续写：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">sp3</span><span class="p">(</span><span class="n">sp1</span><span class="p">,</span><span class="k">new</span> <span class="nf">myobj</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span> <span class="c1">// 注意之前sp1的控制块为空。此时sp3和sp1共享控制块。也就是都没有控制块。自然没有引用计数。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span>  <span class="n">endl</span><span class="p">;</span> <span class="c1">//0</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">sp2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//0，1</span>
</pre></table></code></div></div><ul><li>注意之前<code class="language-plaintext highlighter-rouge">sp1</code>的控制块为空。此时<code class="language-plaintext highlighter-rouge">sp3</code>和<code class="language-plaintext highlighter-rouge">sp1</code>共享控制块。也就是都没有控制块。自然没有引用计数。<ul><li><code class="language-plaintext highlighter-rouge">reset</code>的实现是临时对象+<code class="language-plaintext highlighter-rouge">swap</code></ul><li>所以此时内存泄漏两个位置。一个是<code class="language-plaintext highlighter-rouge">myobj(6)</code> 一个是<code class="language-plaintext highlighter-rouge">myobj(7)</code></ul><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121102638.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221121102638.png" alt="QQ截图20221121102638" class="lazyload" data-proofer-ignore></a></p><h2 id="一般什么时候用"><span class="mr-2">一般什么时候用？</span><a href="#一般什么时候用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>不同类型对象共享生存期。<li>直接持有某个对象的成员。</ul><p>举一个直接持有某个对象的成员的例子。<strong>对象的成员和对象本身,显然的确应该共享生存期</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">innerobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">int</span> <span class="n">inner_val</span><span class="p">;</span>
        <span class="n">innerobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">inner_val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">myobj</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span><span class="n">obj</span><span class="p">(</span><span class="n">n</span><span class="p">){}</span>
	<span class="o">~</span><span class="n">myobj</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj的析构 "</span><span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">inner_val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">innerobj</span> <span class="n">obj</span><span class="p">;</span>

<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">{</span> <span class="k">new</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">};</span><span class="c1">//ptr是共享对象（也就是new出来的myobj）的唯一拥有者</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">innerobj</span><span class="o">&gt;</span> <span class="n">sub_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">obj</span><span class="p">));</span> <span class="c1">//此时sub_ptr的控制块和ptr共享，但是subptr的存储指针直接指向myobj的innerobj成员变量。</span>
    <span class="c1">//记得要取地址。第二个参数要传入指针。</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//2 引用计数被+1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sub_ptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//2 引用计数被+1</span>

    <span class="n">ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span> <span class="c1">//reset, 此时ptr为空。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//0 无控制块</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sub_ptr</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//1 引用计数被-1</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sub_ptr</span><span class="o">-&gt;</span><span class="n">inner_val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//正常输出5 。</span>


    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>注意这里不会有内存泄漏。因为在<code class="language-plaintext highlighter-rouge">reset</code>后，尽管实际持有的存储指针是子对象，但是由于共享控制块，控制块实际的管理指针依旧是<code class="language-plaintext highlighter-rouge">myobj</code>这个大类类型的。所以析构的时候调用的是<code class="language-plaintext highlighter-rouge">myobj</code>的析构。由于<code class="language-plaintext highlighter-rouge">myobj</code>和<code class="language-plaintext highlighter-rouge">innerobj</code>是包含关系，<code class="language-plaintext highlighter-rouge">innerobj</code>自然也会被正确析构。因为<code class="language-plaintext highlighter-rouge">ptr-&gt;obj</code>不会被单独管理，所以也不存在double free 错误</ul><p><strong>有时候，这个东西被叫做幻影指针（Phantom)</strong> ，依旧<a href="https://devblogs.microsoft.com/oldnewthing/20230818-00/?p=108619">来自 Raymond Chen</a></p><p>https://blog.csdn.net/mingwu96/article/details/123327325</p><p>https://zhuanlan.zhihu.com/p/47744606</p><p>https://stackoverflow.com/questions/27109379/what-is-shared-ptrs-aliasing-constructor-for</p><h1 id="常用部分总结">常用部分总结</h1><div class="table-wrapper"><table><thead><tr><th style="text-align: left">比较<th style="text-align: left">shared_ptr<th>unique_ptr<th>备注<tbody><tr><td style="text-align: left">初始化<td style="text-align: left">①<code class="language-plaintext highlighter-rouge">shared_ptr&lt;T&gt; sp;</code><br />②<code class="language-plaintext highlighter-rouge"> sp.reset(new T());</code><br />②<code class="language-plaintext highlighter-rouge">shared_ptr&lt;T&gt; sp(new T());</code><br />③<code class="language-plaintext highlighter-rouge">shared_ptr&lt;T&gt; sp1 = sp; </code><strong>//拷贝构造</strong><br />④<code class="language-plaintext highlighter-rouge">auto sp = make_shared&lt;int&gt;(10);</code><td>①<code class="language-plaintext highlighter-rouge">unique_ptr&lt;T&gt; up;</code> <br /><code class="language-plaintext highlighter-rouge">up.reset(new T());</code><br />②<code class="language-plaintext highlighter-rouge">unique_ptr&lt;T&gt; up(new T());</code><br />③<code class="language-plaintext highlighter-rouge">unique_ptr&lt;T&gt; up1 = std::move(up);</code><strong>//移动构造</strong><br />④<code class="language-plaintext highlighter-rouge">auto up = make_unique&lt;int&gt;(10);</code><td>两者的构造函数将声明为<strong>explicit，即不允许隐式类型转换，</strong>如<code class="language-plaintext highlighter-rouge">shared_ptr&lt;int&gt; sp = new int(10);</code><tr><td style="text-align: left">条件判断<td style="text-align: left">如，<code class="language-plaintext highlighter-rouge">if(sp){…}</code><td>如，<code class="language-plaintext highlighter-rouge">if(up){…}</code><td>两都均<strong>重载<code class="language-plaintext highlighter-rouge">operator bool()</code></strong><tr><td style="text-align: left">解引用(间接寻址运算符 <code class="language-plaintext highlighter-rouge">*</code>)<td style="text-align: left"><code class="language-plaintext highlighter-rouge">*sp</code><td><code class="language-plaintext highlighter-rouge">*up</code><td>解引用，获得它所指向的对象<tr><td style="text-align: left">类成员访问运算符（<code class="language-plaintext highlighter-rouge">-&gt;</code>）<td style="text-align: left"><code class="language-plaintext highlighter-rouge">sp-&gt;mem</code><td><code class="language-plaintext highlighter-rouge">up-&gt;mem</code><td>重载<code class="language-plaintext highlighter-rouge">-&gt;</code>运算符<tr><td style="text-align: left">get()<td style="text-align: left"><code class="language-plaintext highlighter-rouge">sp.get()</code><td><code class="language-plaintext highlighter-rouge">up.get()</code><td>返回智能指针中保存的裸指针，要小心使用。<tr><td style="text-align: left">p.swap(q)<td style="text-align: left"><code class="language-plaintext highlighter-rouge">sp.swap(q);</code><td><code class="language-plaintext highlighter-rouge">up.swap(q);</code><td>交换p和q指针<tr><td style="text-align: left">独有操作<td style="text-align: left">①<code class="language-plaintext highlighter-rouge">shared_ptr&lt;T&gt; p(q);</code>//拷贝构造<br />②<code class="language-plaintext highlighter-rouge">p = q;</code>//赋值<br />③<code class="language-plaintext highlighter-rouge">p.unique();</code>若<code class="language-plaintext highlighter-rouge">p.use_count()</code>为1，返回<code class="language-plaintext highlighter-rouge">true</code>,否则返回<code class="language-plaintext highlighter-rouge">false</code>。④<code class="language-plaintext highlighter-rouge">p.use_count()</code>//返回强引用计数<td>①<code class="language-plaintext highlighter-rouge">up=nullptr;</code>释放up指向的对象，并将up置空。<br />②<code class="language-plaintext highlighter-rouge">up.release();</code>//up<strong>放弃对指针的控制权，返回裸指针，并将up置空</strong><br />③<code class="language-plaintext highlighter-rouge">up.reset();</code>释放up指向的对象。 <code class="language-plaintext highlighter-rouge">up.reset(q);</code>其中q为裸指针。令up指向q所指对象。<br /><code class="language-plaintext highlighter-rouge"> up.reset(nullptr);</code>置空<td>注意:<br />①<code class="language-plaintext highlighter-rouge">unique_ptr</code><strong>不可拷贝和赋值，但可以被移动</strong>。<br />②<code class="language-plaintext highlighter-rouge">release</code>会切断<code class="language-plaintext highlighter-rouge">unique_ptr</code>和它原来管理的对象间的联系。<strong>通常用来初始化另一个智能指针</strong>。</table></div><h1 id="强烈建议以对待普通指针的方式对待智能指针">强烈建议以对待普通指针的方式对待智能指针。</h1><ul><li>如按值传递，<strong>按值返回</strong>。<li>按值传递<code class="language-plaintext highlighter-rouge">unique_ptr</code>显示了所有权的转移。</ul><h1 id="关于侵入式和非侵入式智能指针">关于侵入式和非侵入式智能指针。</h1><h2 id="什么是非侵入式智能指针"><span class="mr-2">什么是非侵入式智能指针</span><a href="#什么是非侵入式智能指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>STL的<code class="language-plaintext highlighter-rouge">shared_ptr</code>属于非侵入式智能指针。从原理上来说就是<strong>它的实现完全放在智能指针模板里</strong>。也就是控制块是和指针在一个类里。</p><p>模板类有一个用于保存资源类对象的指针变量，和一个用于记录资源对象使用计数（控制块）的指针变量。</p><h2 id="什么是侵入式智能指针"><span class="mr-2">什么是侵入式智能指针</span><a href="#什么是侵入式智能指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ITK, VTK和boost里的智能指针是侵入式的。从原理来说就是<strong>它的实现分散在智能指针模板和使用智能指针模板的类中：模板类只有一个用于保存对象的指针变量，对象的计数放在了资源类中。</strong>举例来说就是把控制块比如引用计数和对象绑定到一起。</p><p><a href="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221118211750.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-28-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.assets/QQ%E6%88%AA%E5%9B%BE20221118211750.png" alt="QQ截图20221118211750" class="lazyload" data-proofer-ignore></a></p><h2 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>非侵入式智能指针，它的引用计数变量为了保证所有对象共享，需要用堆里的内存，所以需要用new，这个都一样，不一样的是使用new的次数。</p><li><p>侵入式智能指针的引用计数变量保存在对象里，因为对象是唯一的，所以引用计数也是唯一的。</p><li><p>非侵入式智能指针的缺点：</p><ul><li>在不使用<code class="language-plaintext highlighter-rouge">make_shared</code>的时候，会为控制块单独分配一次内存。这导致性能问题。而如果使用<code class="language-plaintext highlighter-rouge">make_shared</code>，则在某些时候会导致整块内存都无法释放，比如弱引用计数仍不为0的情况下。<li>引用计数的内存区域和数据区域不一致，缓存失效导致性能问题。<li>编写代码不善，将导致同一个数据，绑定到了两个引用计数，从而导致双重删除问题。比如</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">obj</span> <span class="o">*</span><span class="n">resource</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">obj</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="n">ptr1</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span> <span class="c1">//ptr1有控制块</span>
<span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">obj</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span> <span class="c1">//ptr2还有一个控制块。double free</span>
</pre></table></code></div></div><li><p>相比非侵入式智能指针，侵入式智能指针的好处是：</p><ul><li>一个资源对象无论被多少个侵入式智能指针包含，从始至终只有一个引用计数变量，不需要在每一个使用智能指针对象的地方都new一个计数对象，这样子效率比较高，使用内存也比较少，也比较安全；<ul><li>这句话理解就是如果在使用非侵入的时候我们有一个原始指针指向资源，我们使用这个原始指针初始化共享指针的时候会创建多个控制块。</ul><li>因为引用计数存储在对象本身，所以在函数调用的时候可以直接传递资源对象地址，而不用担心引用计数值丢失（非侵入式智能指针对象的拷贝，必须带着智能指针模板，否则就会出现对象引用计数丢失）。</ul><li><p>缺点是：</p><ul><li>资源类必须有引用计数变量，并且该变量的增减可以被侵入式智能指针模板基类操作，这显得麻烦。也就是资源类必须继承自某个引用计数变量的基类或者是编写的时候将其编写进去。b<ul><li>比如在<code class="language-plaintext highlighter-rouge">boost</code>库中，需要继承<code class="language-plaintext highlighter-rouge">boost::intrusive_ptr_base</code>基类</ul><li>如果该类并不想使用智能指针，它还是会带着引用计数变量。</ul></ul><p>可能的实现方法：</p><p>https://zhuanlan.zhihu.com/p/460983966</p><p>https://zhiqiang.org/coding/boost-intrusive-ptr.html</p><h1 id="可能有用的参考资料">可能有用的参考资料</h1><p>https://developer.aliyun.com/article/582674</p><p>https://www.cnblogs.com/5iedu/p/11622401.html</p><p>https://kingsamchen.github.io/2018/03/16/demystify-shared-ptr-and-weak-ptr-in-msvc-stl/ sharedptr源码分析 包含enable_shared_from_this</p><p>https://blog.csdn.net/lgp88/article/details/7529254 不完整类型</p><h1 id="如果自己设计的话如何让原始指针为形参的函数接受智能指针为实参">如果自己设计的话，如何让原始指针为形参的函数接受智能指针为实参？</h1><p>可以使用转换构造函数。如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">operator</span> <span class="n">T</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">//return static_cast&lt;T*&gt;(this-&gt;object); 这行是VTK源码但不知道为何要这么做。</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">object</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>参考<code class="language-plaintext highlighter-rouge">vtkNew</code>和<code class="language-plaintext highlighter-rouge">vtkSmartpointer</code>。VTK8以前的<code class="language-plaintext highlighter-rouge">vtkNew</code>有意禁用了自动转换。但是8以后新增了转换构造所以可以进行转换。转换构造参见杂记2。</p><ul><li>注意，这样做非常危险。因为你现在可以<code class="language-plaintext highlighter-rouge">delete</code>一个智能指针了。<code class="language-plaintext highlighter-rouge">delete</code>会调用这个类型转换函数。所以这样设计的危险性就在于这里。—–Modern C++ design 7.7 和 more effective 条款28</ul><h1 id="为何智能指针支持-和继承有关的类型转换-more-effective-c--条款28部分">为何智能指针支持 和继承有关的类型转换？ more effective c++ -条款28（部分）</h1><p>回顾我们曾经实现过的<code class="language-plaintext highlighter-rouge">uptr</code>，代码不在这里贴了。</p><ul><li>首先我们知道，原始指针中，指向完整派生类类型的（可有 cv 限定的）空指针可转换成指向它的（有相同 cv 限定的）基类的指针。如果基类不可访问或有歧义，那么转换非良构（不能编译）。转换结果是指向原被指向对象内的基类子对象的指针。空指针值转换成目标类型的空指针值。<strong>也就是子类类型指针可以天然自然地转换为父类类型指针。（这是隐式类型转换中的第五级的指针转换。）</strong></ul><p>假设我们有如下场景</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">b</span><span class="p">{</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="nc">d</span><span class="o">:</span><span class="n">b</span><span class="p">{</span>

<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">formalfunc</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"formal"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">b</span><span class="p">());</span>
    <span class="n">func</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span> <span class="c1">//可以。因为此时类型是b</span>
    <span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="k">new</span> <span class="n">d</span><span class="p">());</span>
    <span class="n">func</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr2</span><span class="p">));</span> <span class="c1">//可以。因为此时类型是b</span>

    <span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">d</span><span class="o">&gt;</span> <span class="n">ptr2</span><span class="p">(</span><span class="k">new</span> <span class="n">d</span><span class="p">());</span>
    <span class="n">func</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr2</span><span class="p">));</span> <span class="c1">//不可以。因为此时类型是d</span>

    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">d</span><span class="o">&gt;</span> <span class="n">uptr</span><span class="p">(</span><span class="k">new</span> <span class="n">d</span><span class="p">());</span> <span class="c1">//针对标准库的智能指针，这样可以，因为有隐式类型转换。</span>
    <span class="n">formalfunc</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">uptr</span><span class="p">));</span> <span class="c1">//可以。有隐式类型转换。</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>我们发现我们实现的简易版和标准库的相比，我们无法做到和继承有关的类型转换。原因非常明显。就算<code class="language-plaintext highlighter-rouge">b</code>和<code class="language-plaintext highlighter-rouge">d</code>有继承关系，但是<code class="language-plaintext highlighter-rouge">unique_ptr&lt;b&gt;</code>和<code class="language-plaintext highlighter-rouge">unique_ptr&lt;d&gt;</code>毫无关联。但是为什么标准库的智能指针可以让我们把一个子类类型的智能指针传入（赋值）给接受基类类型的智能指针的函数中呢？</ul><p>标准库的做法我们从文档中可以窥见一斑：</p><blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">U</span><span class="p">,</span> <span class="k">class</span> <span class="nc">E</span> <span class="p">&gt;</span>
<span class="n">unique_ptr</span><span class="p">(</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;&amp;&amp;</span> <span class="n">u</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">//(6)	</span>
</pre></table></code></div></div><p>通过从 <code class="language-plaintext highlighter-rouge">u</code> 转移所有权给 <code class="language-plaintext highlighter-rouge">*this</code> 构造 <code class="language-plaintext highlighter-rouge">unique_ptr</code> ，其中 <code class="language-plaintext highlighter-rouge">u</code> 以指定的删除器（ <code class="language-plaintext highlighter-rouge">E</code> ）构造。它依赖于 <code class="language-plaintext highlighter-rouge">E</code> 是否是引用类型，如下：</p><p>a) 若 <code class="language-plaintext highlighter-rouge">E</code> 是引用类型，则从 <code class="language-plaintext highlighter-rouge">u</code> 的删除器复制构造此删除器（要求此构造不抛出）</p><p>b) 若 <code class="language-plaintext highlighter-rouge">E</code> 不是引用类型，则从 <code class="language-plaintext highlighter-rouge">u</code> 的删除器移动构造此删除器（要求此构造不抛出）</p><p>此构造函数仅若下列皆为真才参与重载决议：</p><p>a) <code class="language-plaintext highlighter-rouge">unique_ptr&lt;U, E&gt;::pointer</code> 可隐式转换为 <code class="language-plaintext highlighter-rouge">pointer</code></p><p>b) <code class="language-plaintext highlighter-rouge">U</code> 不是数组类型</p><p>c) <code class="language-plaintext highlighter-rouge">Deleter</code> 是引用类型且 <code class="language-plaintext highlighter-rouge">E</code> 与 <code class="language-plaintext highlighter-rouge">D</code> 为同一类型，或 <code class="language-plaintext highlighter-rouge">Deleter</code> 不是引用类型且 <code class="language-plaintext highlighter-rouge">E</code> 可隐式转换为 <code class="language-plaintext highlighter-rouge">D</code></p><p><strong><code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;Derived&gt;</code> 通过重载 (6) 可隐式转换为 <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;Base&gt;</code> （因为被管理指针和 <code class="language-plaintext highlighter-rouge">std::default_delete</code>都可隐式转换）。</strong></p></blockquote><p>根据 more effective c++ 条款28，在简单层面，选择是添加一个简单的用户定义转换函数模板。但是如果照着标准库的方法模拟，则是这样。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Tp</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">default_delete</span>
    <span class="p">{</span>
      <span class="c1">/// Default constructor</span>
      <span class="k">constexpr</span> <span class="n">default_delete</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">//默认删除器的默认构造</span>

      <span class="cm">/** @brief Converting constructor.
       *
       * Allows conversion from a deleter for objects of another type, `_Up`,
       * only if `_Up*` is convertible to `_Tp*`.
       */</span>
      <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Up</span><span class="p">,</span>
	       <span class="k">typename</span> <span class="o">=</span> <span class="n">_Require</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">*</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*</span><span class="p">&gt;</span><span class="o">&gt;&gt;</span>
	<span class="n">_GLIBCXX23_CONSTEXPR</span>
        <span class="n">default_delete</span><span class="p">(</span><span class="k">const</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;&amp;</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//一个构造函数模板用来在查看默认删除器是否可以被类型转换后进行类型转换。这里很重要</span>

      <span class="c1">/// Calls `delete __ptr`</span>
      <span class="n">_GLIBCXX23_CONSTEXPR</span>
      <span class="kt">void</span>
      <span class="nf">operator</span><span class="p">()(</span><span class="n">_Tp</span><span class="o">*</span> <span class="n">__ptr</span><span class="p">)</span> <span class="k">const</span>
      <span class="p">{</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">is_void</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
		      <span class="s">"can't delete pointer to incomplete type"</span><span class="p">);</span>
	<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">_Tp</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">,</span>
		      <span class="s">"can't delete pointer to incomplete type"</span><span class="p">);</span>
	<span class="k">delete</span> <span class="n">__ptr</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">};</span>

<span class="c1">//unique_ptr的构造函数6</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Up</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">_Ep</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="n">_Require</span><span class="o">&lt;</span>
               <span class="n">__safe_conversion_up</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">,</span> <span class="n">_Ep</span><span class="p">&gt;,</span>
	       <span class="n">__conditional_t</span><span class="o">&lt;</span><span class="n">is_reference</span><span class="o">&lt;</span><span class="n">_Dp</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
			       <span class="n">is_same</span><span class="o">&lt;</span><span class="n">_Ep</span><span class="p">,</span> <span class="n">_Dp</span><span class="o">&gt;</span><span class="p">,</span>
			       <span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_Ep</span><span class="p">,</span> <span class="n">_Dp</span><span class="o">&gt;&gt;&gt;&gt;</span>
	<span class="n">_GLIBCXX23_CONSTEXPR</span>
	<span class="nf">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">_Up</span><span class="p">,</span> <span class="n">_Ep</span><span class="o">&gt;&amp;&amp;</span> <span class="n">__u</span><span class="p">)</span> <span class="k">noexcept</span>
	<span class="o">:</span> <span class="n">_M_t</span><span class="p">(</span><span class="n">__u</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Ep</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__u</span><span class="p">.</span><span class="n">get_deleter</span><span class="p">()))</span> <span class="c1">//非常单纯的赋值</span>
	<span class="p">{</span> <span class="p">}</span>
</pre></table></code></div></div><p><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/unique_ptr.h">源代码</a></p><p>上面的代码看起来复杂，其实用自己写的版本可以化简为这样：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">pivot</span><span class="p">(</span><span class="n">T</span> <span class="n">p</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span> <span class="c1">//查看函数签名</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptrs</span><span class="p">;</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">ptrs</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">val</span><span class="p">)){}</span>
    <span class="o">~</span><span class="n">myobj</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ptrs</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
            <span class="k">delete</span> <span class="n">ptrs</span><span class="p">;</span>
            <span class="n">ptrs</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">area2</span><span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">default_deleter</span><span class="p">{</span> <span class="c1">//默认形式的删除器</span>
        <span class="nl">public:</span>
        <span class="n">default_deleter</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="c1">//模拟默认删除器的构造函数模板</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Up</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">enable_if</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span><span class="p">&gt;</span><span class="o">::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="c1">//注意必须是指针类型的可转换性</span>
        <span class="n">default_deleter</span><span class="p">(</span><span class="k">const</span> <span class="n">default_deleter</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;&amp;</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span> <span class="c1">//2</span>
        <span class="p">}</span>
        <span class="n">default_deleter</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">default_deleter</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"operator= called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//4</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">T</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span> <span class="c1">//6</span>
            <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
                <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
                <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> 
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Deleter</span> <span class="o">=</span> <span class="n">default_deleter</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="c1">//模板表示接受T类型一个接受T类型的删除器</span>
    <span class="k">class</span> <span class="nc">unique_ptr</span><span class="p">{</span>
        <span class="nl">public:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="c1">//T类型指针</span>
        <span class="n">Deleter</span> <span class="n">d_</span><span class="p">;</span> <span class="c1">//删除器</span>
		<span class="c1">//.....</span>
        <span class="c1">//模拟构造函数6</span>
        <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
        <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="n">E</span><span class="o">&gt;&amp;&amp;</span> <span class="n">u</span><span class="p">){</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">p_</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">p_</span><span class="p">;</span> <span class="c1">//指针赋值。自然转换</span>
            <span class="c1">//----------------</span>
            <span class="n">pivot</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">d_</span><span class="p">);</span> <span class="c1">//1</span>
            <span class="n">default_deleter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">temp</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">d_</span><span class="p">);</span>
            <span class="n">pivot</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span> <span class="c1">//3</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">d_</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="c1">//----上面的区域可以换成下面一行------------</span>
            <span class="c1">//this-&gt;d = u.d_</span>
            <span class="n">u</span><span class="p">.</span><span class="n">p_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
		<span class="c1">//......</span>
<span class="p">}</span>

</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>void pivot(T) [with T = area2::default_deleter&lt;d&gt;] //1
area2::default_deleter&lt;T&gt;::default_deleter(const area2::default_deleter&lt;_Up&gt;&amp;) [with _Up = d; &lt;template-parameter-2-2&gt; = void; T = b] //2
void pivot(T) [with T = area2::default_deleter&lt;b&gt;] //3
operator= called //4
called
void area2::default_deleter&lt;T&gt;::operator()(T*) const [with T = b] //6
</pre></table></code></div></div><p>核心原理就是把指针直接赋值过来。</p><p>当我们有</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">d</span><span class="o">&gt;</span> <span class="n">ptr3</span><span class="p">(</span><span class="k">new</span> <span class="nf">d</span><span class="p">());</span>
<span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr3</span><span class="p">));</span>
</pre></table></code></div></div><p>的时候，首先我们发现这时候传入的指针的删除器类型是<code class="language-plaintext highlighter-rouge">area2::default_deleter&lt;d&gt;</code>。我们发现子类删除器和父类删除器<code class="language-plaintext highlighter-rouge">area2::default_deleter&lt;d&gt;</code>不一样，这就是为什么默认删除器要添加一个构造函数模板。</p><p>然后我们拆开写了，可以直接写<code class="language-plaintext highlighter-rouge">this-&gt;d_ = u.d_</code>。</p><p>第一步是查找合适的赋值方式。先查找<code class="language-plaintext highlighter-rouge">d_</code>有没有合适的<code class="language-plaintext highlighter-rouge">operator=</code>，明显没有，那么查看<code class="language-plaintext highlighter-rouge">u.d_</code>能不能转换为本类类型的默认拷贝赋值的参数类型，也就是<code class="language-plaintext highlighter-rouge">area2::default_deleter&lt;b&gt;</code>。我们发现<code class="language-plaintext highlighter-rouge">default_deleter</code>拥有一个构造函数模板：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">_Up</span><span class="p">,</span> <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">enable_if</span><span class="o">&lt;</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span><span class="p">&gt;</span><span class="o">::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
    <span class="n">default_deleter</span><span class="p">(</span><span class="k">const</span> <span class="n">default_deleter</span><span class="o">&lt;</span><span class="n">_Up</span><span class="o">&gt;&amp;</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span> <span class="c1">//2</span>
<span class="p">}</span>
</pre></table></code></div></div><p>它可以帮助我们转换。这个其实非常简单。先查看<code class="language-plaintext highlighter-rouge">_Up*</code>(子类指针，也就是本类中的<code class="language-plaintext highlighter-rouge">d</code>）能不能转换为<code class="language-plaintext highlighter-rouge">T*</code>（父类指针，也就是本类中的<code class="language-plaintext highlighter-rouge">b</code>）。然后就是构造了一个对象。</p><ul><li><strong>这里必须要用<code class="language-plaintext highlighter-rouge">is_convertible&lt;_Up*, T*&gt;</code>而不是<code class="language-plaintext highlighter-rouge">is_convertible&lt;_Up, T&gt;</code></strong><ul><li>因为智能指针只有父类指针对子类指针进行<code class="language-plaintext highlighter-rouge">delete</code>的时候才有意义。但是如果直接两个对象之间判断是否可以转换，语义不对。比如两个没有继承关系的但是有转换函数的对象是convertible的，<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">long</code>之间也是convertible的。但是<code class="language-plaintext highlighter-rouge">int</code>指针可以用<code class="language-plaintext highlighter-rouge">long</code>指针析构吗？显然不可以。所以必须使用指针类型进行判断是否convertible。<li>所以这里只有在有继承关系的<strong>子转父</strong>的时候，或者是<strong>转换CV限定（non-const to const）</strong>的时候才是true。语义才正确。</ul></ul><p>第二步就是我们得到了一个父类类型的默认删除器的临时对象。</p><p>第三部就是把这个删除器赋值即可。</p><p><strong>因为默认删除器这个类没有任何数据。所以这样直接转换是符合我们直观意图的。</strong></p><p><strong>现在子类指针已经被转为父类。那么子类的删除器也应该变为父类。这样才正确。</strong></p><p>测试</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">b</span><span class="p">{</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="nc">d</span><span class="o">:</span><span class="n">b</span><span class="p">{</span>

<span class="p">};</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">area2</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">d</span><span class="o">&gt;</span> <span class="n">ptr3</span><span class="p">(</span><span class="k">new</span> <span class="n">d</span><span class="p">());</span> <span class="c1">//现在不会报错了</span>
    <span class="n">func</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">ptr3</span><span class="p">));</span>

<span class="p">}</span>
</pre></table></code></div></div><h1 id="智能指针的大师问答">智能指针的大师问答</h1><p>来自<a href="https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">这里</a></p><h2 id="1-如何决定是否使用和使用哪一种智能指针-默认使用unique_ptr"><span class="mr-2">1. 如何决定是否使用和使用哪一种智能指针？– 默认使用unique_ptr</span><a href="#1-如何决定是否使用和使用哪一种智能指针-默认使用unique_ptr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>优先使用标准智能指针，默认情况下使用<code class="language-plaintext highlighter-rouge">unique_ptr</code>，如果需要共享，则使用<code class="language-plaintext highlighter-rouge">shared_ptr</code></strong>。它们是所有 C++ 库都可以理解的通用类型。仅在需要与其他库进行互操作时，或者在需要使用标准指针上的删除器和分配器无法实现的自定义行为时，才使用其他智能指针类型。</p><h2 id="2-shared_ptr应该如何构造make_shared还是直接构造"><span class="mr-2">2. shared_ptr应该如何构造？make_shared还是直接构造？</span><a href="#2-shared_ptr应该如何构造make_shared还是直接构造" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>除了我们上面提到的那些关于<code class="language-plaintext highlighter-rouge">make_shared</code>的优缺点和区别以外，想在此补充一些。</p><p>第一个，C++20开始其实有了<a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr/allocate_shared"><code class="language-plaintext highlighter-rouge">allocate_shared</code></a>。 顾名思义就是自定义内存分配器，但是我们其实可以视<code class="language-plaintext highlighter-rouge">make_shared</code>是一种狭义的<code class="language-plaintext highlighter-rouge">allocate_shared</code>（因为实际上没有自定义自己的内存分配器）</p><p>第二个，除了上面说到的make方法的使用以外，有一个额外的工程层面问题可能会需要直接构造，也就是<strong>如果你采用指向从其他（通常是遗留的）代码传递给你的对象的原始指针，则可以直接从该原始指针构造一个<code class="language-plaintext highlighter-rouge">shared_ptr</code>。</strong> 其余情况下，应当尽可能的使用<code class="language-plaintext highlighter-rouge">make_shared</code>。因为不仅使代码更清晰，而且从内存角度来讲，一般情况下，局部性，碎片和分配次数比实际的大小对系统的影响更大</p><h1 id="其他文章">其他文章</h1><ol><li><a href="https://andreasfertig.blog/2024/10/smart-pointers-and-the-pointer-to-implementation-idiom/">智能指针和Pinpl</a><li><a href="https://www.tonni.nl/blog/shared-ptr-overuse-cpp">过度使用shared_ptr的危害及如何避免</a></ol><h1 id="设计智能指针--more-effective-c-第七章">设计智能指针 – more effective C++ 第七章</h1><p>因为这本书非常老，所以我们可以从最原始的角度理解智能指针到底需要满足什么需求，有哪些设计方式，为什么最后成为了现在的这个样子。</p><h2 id="72-语义"><span class="mr-2">7.2 语义</span><a href="#72-语义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>7.2讲的是语义。智能指针到底应该如何保有资源。这部分我想就是后面拆分的<code class="language-plaintext highlighter-rouge">unique_ptr</code>和<code class="language-plaintext highlighter-rouge">shared_ptr</code></p><h2 id="73-智能指针的存储"><span class="mr-2">7.3 智能指针的存储</span><a href="#73-智能指针的存储" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>7.3讲的是智能指针的存储。应该保留一个什么类型的原始指针？同时提到了重载<code class="language-plaintext highlighter-rouge">operator-&gt;</code>的技巧。</p><h2 id="74-成员函数"><span class="mr-2">7.4 成员函数</span><a href="#74-成员函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>7.4讲的是成员函数。提到了智能指针不应该拥有如release()这样的成员函数。但是目前，它确实有。书中给到的不应该有的理由是：必须区分<code class="language-plaintext highlighter-rouge">ptr-&gt;release()</code>和<code class="language-plaintext highlighter-rouge">ptr.release()</code>的区别。因为可能智能指针保有的指针类型恰好也含有一个对应名字的函数。</p><h2 id="75-所有权"><span class="mr-2">7.5 所有权</span><a href="#75-所有权" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>7.5讲的是所有权。 相当于7.2的延伸。这部分涉及到了侵入式和非侵入式指针的设计。侵入式如VTK的智能指针，好处是智能指针本身不需要操心引用计数器。因为引用计数是和对象绑定在一起的。缺点是对象必须要继承引用计数类。同时，提到了几个引用计数的设计。这部分在我们上面提到的<code class="language-plaintext highlighter-rouge">make</code>方法中有所体现。同时，额外提到了一种利用双向链表来做为引用计数的方法（感觉没啥用）。最后提到了关于循环引用的问题。</p><h2 id="76-取址操作符"><span class="mr-2">7.6 取址操作符</span><a href="#76-取址操作符" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>7.6讲的是取址操作符。这一部分非常经典？理论上从不应该重载取址操作符，当然了，在某些代理类的时候除外。书中提到了重载了取址操作符的类不太好用于STL容器，因为所有<code class="language-plaintext highlighter-rouge">&amp;T</code>都应该返回一个<code class="language-plaintext highlighter-rouge">T*</code>。当然了我觉得这是因为当时还没有<code class="language-plaintext highlighter-rouge">std::address_of</code>这个东西。<strong>不过也确实，STL的智能指针都没有重载<code class="language-plaintext highlighter-rouge">operator&amp;</code></strong></p><h2 id="77-隐式转换"><span class="mr-2">7.7 隐式转换</span><a href="#77-隐式转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这部分就是上面提到的：<em>如果自己设计的话，如何让原始指针为形参的函数接受智能指针为实参？</em></p><p>答案是看情况。需要权衡利弊。</p><h2 id="78-79-比较操作"><span class="mr-2">7.8 7.9 比较操作</span><a href="#78-79-比较操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>STL目前是拥有智能指针的比较函数的。也就是重载了对应的函数。并且不是成员函数。</p><h2 id="710-错误检测"><span class="mr-2">7.10 错误检测</span><a href="#710-错误检测" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>比如是否可以把空值传入智能指针做为初始值？目前是可以的。但是书上说不太应该。但是也是case by case。</p><p>另一个就是关于是否要进行解引用前检测是否为空？我个人认为应该把这个留给用户。应该让智能指针在智能的同时，尽可能简约。</p><h2 id="711-常量性"><span class="mr-2">7.11 常量性</span><a href="#711-常量性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>确实有一个很有意思的地方。无论指针的常量性是顶层还是底层还是皆有，<code class="language-plaintext highlighter-rouge">delete</code>都可正常使用。从某个角度来说是废话，但是从所有权的语义上理解可能就有了微妙的地方。为啥要在智能指针上面提到这种呢？因为智能指针也应该支持顶层和底层的const的语义区别。确实支持。毕竟原理就是<code class="language-plaintext highlighter-rouge">type trait</code></p><h2 id="712-数组类型"><span class="mr-2">7.12 数组类型</span><a href="#712-数组类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>其实不太应该使用堆上的数组。当然了，标准库也对智能指针提供了<code class="language-plaintext highlighter-rouge">[]</code>数组特化的版本。</p><h2 id="713-多线程"><span class="mr-2">7.13 多线程</span><a href="#713-多线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对于智能指针的多线程访问一直是一个比较令人困扰的问题。</p><p>一般来说，对于智能指针的多线程访问我们需要分成两个方向去讨论。第一个方向是指针保有的对象的多线程访问。另一个是指针的引用计数的多线程访问。</p><p>针对第一个，我们能做的东西不大。语义上我们希望智能指针帮我们做的事情越少越好，越少也就越透明，越自由。所以说在这一方面我们不应替用户操心太多。书中提到了自动锁定的应用，但我觉得不怎么样。用户自己会去针对并发访问进行处理。</p><p>针对第二个，我们可以肯定的是目前的<code class="language-plaintext highlighter-rouge">shared_ptr</code>的引用计数块的并发访问是不安全的。所以需要进行控制。原理还是一样，我们不应该在这个情况上替用户做过多决定。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20-%20Sterben_01&url=%2Fposts%2F%25E6%2599%25BA%25E8%2583%25BD%25E6%258C%2587%25E9%2592%2588%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20-%20Sterben_01&u=%2Fposts%2F%25E6%2599%25BA%25E8%2583%25BD%25E6%258C%2587%25E9%2592%2588%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E6%2599%25BA%25E8%2583%25BD%25E6%258C%2587%25E9%2592%2588%2F&text=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/" class="btn btn-outline-primary" prompt="上一篇"><p>操作系统相关</p></a> <a href="/posts/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="btn btn-outline-primary" prompt="下一篇"><p>算法相关</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
