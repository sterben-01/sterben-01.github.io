<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="HTTP" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="HTTP请求报文格式" /><meta property="og:description" content="HTTP请求报文格式" /><link rel="canonical" href="/posts/HTTP/" /><meta property="og:url" content="/posts/HTTP/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-20T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="HTTP" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-26T07:21:39-05:00","datePublished":"2022-08-20T01:55:00-05:00","description":"HTTP请求报文格式","headline":"HTTP","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/HTTP/"},"url":"/posts/HTTP/"}</script><title>HTTP | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>HTTP</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>HTTP</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1660978500" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/08/20 </em> </span> <span> 更新于 <em class="" data-ts="1664194899" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/09/26 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5333 字"> <em>29 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="http请求报文格式">HTTP请求报文格式</h1><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220809091212.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220809091212.png" alt="QQ截图20220809091212" class="lazyload" data-proofer-ignore></a></p><p>注意请求体（请求数据）部分<code class="language-plaintext highlighter-rouge">GET</code>请求没有。</p><h1 id="http请求方法">HTTP请求方法</h1><ol><li><p>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副 作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被爬虫等随意访 问。所以GET请求不应被定义为带有副作用的操作。</p><li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文 部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该 资源的信息”（元信息或称元数据）。（<strong>只返回请求头</strong>）<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含 在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。<li>PUT：向指定资源位置上传其最新内容。但是鉴于PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站都不采用该方法。<li>DELETE：请求服务器删除 Request-URI 所标识的资源。同样不带验证机制，存在安全性问题。<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*‘来代替资源名称， 向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。<li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服 务器的链接（经由非加密的 HTTP 代理服务器）</ol><h1 id="get和post区别">GET和POST区别</h1><p><strong>GET 的语义是从服务器获取指定的资源</strong>， 而<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理（通常导致状态变化或副作用，比如增添或删除数据等）</strong></p><ul><li>GET<strong>一般</strong>没有请求体，POST有请求体<li>GET参数通过URL传递，而POST参数会放在请求体中，这导致：<ul><li>由于URL有长度限制，所以GET的参数长度有限制，POST没有<li>GET参数暴露在URL中，不安全。不可传递敏感信息。这个不安全在传输中因为是HTTPS所以不是很担心，主要担心的是存在在历史记录内。<li>由于URL只支持ASCII编码，所以GET编码种类受限。<li>由于URL含有参数，历史记录内会保存GET请求参数，但是POST不会<li>所以GET的URL可以被当做书签</ul><li>GET请求在浏览器回退的时候是无害的，但是POST会再次提交请求，所以会出现浏览器问你是否要继续<li>GET请求发送的时候，请求行和请求头和请求体是一起发送的。（理解为没有请求体）。然后服务器一并接受并相应。而POST请求发送的时候，会先发送请求行和请求头，服务器响应100 continue后，再次发送请求体。然后服务器响应。</ul><h1 id="http11">HTTP1.1</h1><h2 id="优点"><span class="mr-2">优点：</span><a href="#优点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="支持长连接"><span class="mr-2">支持长连接</span><a href="#支持长连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>支持长连接，无需每一个请求都对应一次TCP握手和挥手。可以在一个TCP连接中进行多次请求。</ul><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810064353.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810064353.png" alt="QQ截图20220810064353" class="lazyload" data-proofer-ignore></a></p><h3 id="支持管线化解决了请求端队头阻塞但是没有解决响应端的队头阻塞"><span class="mr-2">支持管线化。解决了请求端队头阻塞，但是没有解决响应端的队头阻塞。</span><a href="#支持管线化解决了请求端队头阻塞但是没有解决响应端的队头阻塞" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>支持管线化。意思是客户端发出的请求不必排队发送（也就是前一个请求未响应的时候下一个请求无法发送）。<strong>但是服务器必须按照接受请求的顺序返回管线化的请求响应。</strong><ul><li>举个例子，非管线化就是1发送，1接受，然后2发送，2接受。管线化就是1发送，2发送。但是服务器返回必须也先返回1再返回2。不可乱序返回。<li><strong>所以HTTP1.1的管线化解决了请求的队头阻塞（可以同时发送多个请求），但是没有解决响应的队头阻塞（服务器必须按照顺序返回，如果第一个阻塞了，后面的就阻塞了）</strong></ul></ul><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810064729.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810064729.png" alt="QQ截图20220810064729" class="lazyload" data-proofer-ignore></a></p><h3 id="引入了host域名"><span class="mr-2">引入了host域名</span><a href="#引入了host域名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</ul><h3 id="新增了几个状态码所以支持"><span class="mr-2">新增了几个状态码所以支持：</span><a href="#新增了几个状态码所以支持" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="支持-range断点续传"><span class="mr-2">支持 Range(断点续传)</span><a href="#支持-range断点续传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="支持先发送请求头等服务器确认后返回100再次发送请求体"><span class="mr-2">支持先发送请求头，等服务器确认后返回100再次发送请求体</span><a href="#支持先发送请求头等服务器确认后返回100再次发送请求体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，<li>客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</ul><h2 id="缺点"><span class="mr-2">缺点：</span><a href="#缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="无状态"><span class="mr-2">无状态</span><a href="#无状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>意思就是没有记忆能力，如果一个数据依靠其他请求，则每次都需要验证。理解为从登陆到下单，每一个页面都需要知道用户身份，则每一次都要登陆一下。</ul><h3 id="明文传输"><span class="mr-2">明文传输</span><a href="#明文传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>没用HTTPS</ul><h3 id="请求头和响应头无法压缩只能压缩请求体和响应体"><span class="mr-2">请求头和响应头无法压缩，只能压缩请求体和响应体</span><a href="#请求头和响应头无法压缩只能压缩请求体和响应体" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为首部信息是JSON的。没有压缩。所以冗长浪费性能</p><h3 id="没有请求优先级控制"><span class="mr-2">没有请求优先级控制</span><a href="#没有请求优先级控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="请求只能由客户端主动发起"><span class="mr-2">请求只能由客户端主动发起</span><a href="#请求只能由客户端主动发起" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h1 id="http20">HTTP2.0</h1><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810065919.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810065919.png" alt="QQ截图20220810065919" class="lazyload" data-proofer-ignore></a></p><h2 id="优点-1"><span class="mr-2">优点：</span><a href="#优点-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="支持头部压缩"><span class="mr-2">支持头部压缩</span><a href="#支持头部压缩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。<li>这就是所谓的 <code class="language-plaintext highlighter-rouge">HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</ul><h3 id="二进制格式"><span class="mr-2">二进制格式</span><a href="#二进制格式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</ul><h3 id="数据流"><span class="mr-2">数据流</span><a href="#数据流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<li>在 HTTP/2 中每个请求或响应的所有数据包，称为一个数据流（<code class="language-plaintext highlighter-rouge">Stream</code>）。每个数据流都标记着一个独一无二的编号（Stream ID），<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息<li>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</ul><h3 id="因为使用了数据流所以可以指定数据流的优先级支持了优先级控制"><span class="mr-2">因为使用了数据流，所以可以指定数据流的优先级。支持了优先级控制</span><a href="#因为使用了数据流所以可以指定数据流的优先级支持了优先级控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="多路复用-解决了响应端的队头阻塞"><span class="mr-2">多路复用 解决了响应端的队头阻塞</span><a href="#多路复用-解决了响应端的队头阻塞" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HTTP/2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率， 解决了响应端的队头阻塞</strong>。</p><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070205.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070205.png" alt="QQ截图20220810070205" class="lazyload" data-proofer-ignore></a></p><h3 id="支持服务器推送"><span class="mr-2">支持服务器推送</span><a href="#支持服务器推送" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。</p><p>比如，客户端通过 HTTP/1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，如下图左边部分：<a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070402.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070402.png" alt="QQ截图20220810070402" class="lazyload" data-proofer-ignore></a></p><p>如上图右边部分，在 HTTP/2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p><h2 id="缺点-1"><span class="mr-2">缺点：</span><a href="#缺点-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="虽然解决了http层面的发送队头阻塞和响应队头阻塞但是有tcp层面的队头阻塞"><span class="mr-2">虽然解决了HTTP层面的发送队头阻塞和响应队头阻塞，但是有TCP层面的队头阻塞</span><a href="#虽然解决了http层面的发送队头阻塞和响应队头阻塞但是有tcp层面的队头阻塞" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070455.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220810070455.png" alt="QQ截图20220810070455" class="lazyload" data-proofer-ignore></a></p><h1 id="https">HTTPS</h1><h2 id="http-与-https-有哪些区别"><span class="mr-2">HTTP 与 HTTPS 有哪些区别？</span><a href="#http-与-https-有哪些区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 <strong>TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</strong><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。<strong>而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</strong><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</ol><h2 id="https-解决了-http-的哪些问题"><span class="mr-2">HTTPS 解决了 HTTP 的哪些问题？</span><a href="#https-解决了-http-的哪些问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</ul><h2 id="https-优点"><span class="mr-2">HTTPS 优点：</span><a href="#https-优点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>安全性高（废话），不存在窃听，篡改和冒充风险</ul><h2 id="https缺点"><span class="mr-2">HTTPS缺点：</span><a href="#https缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>延迟较高，因为TCP握手后还需要进行SSL握手。<li>部署成本高，需要进行加密计算，部署证书等。</ul><h1 id="https是怎么解决风险的">HTTPS是怎么解决风险的？</h1><h2 id="https采用了混合加密-和-摘要算法来解决风险"><span class="mr-2">HTTPS采用了混合加密 和 摘要算法来解决风险</span><a href="#https采用了混合加密-和-摘要算法来解决风险" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</ul><h3 id="混合加密"><span class="mr-2">混合加密</span><a href="#混合加密" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</ul><p>采用「混合加密」的方式的原因：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，但是密钥必须保密，无法做到安全的密钥交换。<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</ul><h3 id="摘要算法数字签名"><span class="mr-2">摘要算法+数字签名</span><a href="#摘要算法数字签名" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>摘要就是他妈的哈希。<strong>服务器把数据和哈希值一起发出去，然后客户端拿到数据后再算一遍哈希值，如果和服务器发来的一样，能说明数据没有被篡改</strong>。但是你没办法确认这个数据真的是服务器发的。有可能是别人发的。就是中间人攻击。所以我们会有一个数字证书。</p><ul><li>服务器把自己的公钥注册到CA，CA用自己的私钥给服务器的公钥签名，然后颁发数字证书。数字证书包含着服务器的公钥。CA的公钥是预先保存在浏览器或操作系统内的。所以客户端收到了数字证书后，用CA的公钥给CA私钥加密的数字证书解密<strong>（公钥解密，私钥加密证明不会被冒充）</strong>。这就证明了这个证书确实是CA颁发的。所以也就知道了这个数字证书里面的服务器公钥确实是服务器的。</ul><h2 id="公钥和私钥-非对称加密"><span class="mr-2">公钥和私钥 （非对称加密）</span><a href="#公钥和私钥-非对称加密" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>公钥，这个是可以公开给所有人的；<li>私钥，这个必须由本人管理，不可泄露。</ul><p>这两个密钥可以<strong>双向加解密</strong>的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。</p><p>流程的不同，意味着目的也不相同：</p><ul><li><strong>公钥加密，私钥解密</strong>。这个目的是为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；<li><strong>私钥加密，公钥解密</strong>。这个目的是为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</ul><h1 id="https建立流程">HTTPS建立流程：</h1><h2 id="一句话版本先tcp三次握手然后tls四次握手所以https首次通信是握手7次"><span class="mr-2">一句话版本：先TCP三次握手，然后TLS四次握手。所以HTTPS首次通信是握手7次</span><a href="#一句话版本先tcp三次握手然后tls四次握手所以https首次通信是握手7次" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/unknown.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/unknown.png" alt="unknown" class="lazyload" data-proofer-ignore></a></p><p>SSL/TLS 协议建立的详细流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code class="language-plaintext highlighter-rouge">ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息，<strong>是明文传输的</strong>：</p><p>（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code class="language-plaintext highlighter-rouge">Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code class="language-plaintext highlighter-rouge">SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code class="language-plaintext highlighter-rouge">Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认的密码套件列表，如 RSA 加密算法。</p><p>（4）<strong>服务器的数字证书。</strong></p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code class="language-plaintext highlighter-rouge">pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）<strong>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</strong></p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p><strong>上面第一项的随机数是整个握手阶段的第三个随机数</strong>，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。因为客户端随机数+服务器随机数+pre-master和加密算法都是协商好一样的，所以会话秘钥也是一样的，所以开始对称加密</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code class="language-plaintext highlighter-rouge">pre-master key</code>）之后，通过服务器的私钥解密，拿到<code class="language-plaintext highlighter-rouge">pre-master key</code>。然后计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><h2 id="总结"><span class="mr-2">总结：</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TCP三次握手后，开始TLS四次握手。</p><ol><li>客户端发送：客户端随机数，客户端TLS版本，和支持的加密协议。<li>服务器发送：服务器随机数，确认的TLS版本，确认的加密协议和服务器证书<ul><li>客户端通过证书验证身份后，拿到服务器公钥。然后生成一个pre-master key。此时客户端可以用客户端随机数+服务器随机数+pre-master key生成会话秘钥。</ul><li>客户端发送：被服务器公钥加密过的pre-master key， 加密算法改变通知和客户端握手结束通知<ul><li>服务器端通过私钥解密拿到pre-master key。此时服务器也可以用客户端随机数+服务器随机数+pre-master key生成会话秘钥。</ul><li>服务器发送：加密算法改变通知，服务器握手结束通知</ol><h1 id="杂项问题">杂项问题：</h1><h2 id="https会加密url吗--会"><span class="mr-2">HTTPS会加密URL吗 – 会</span><a href="#https会加密url吗--会" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>因为 URL 的信息都是保存在 HTTP Header 中的，而 HTTPS 是会对 HTTP Header + HTTP Body 整个加密的，所以 URL 自然是会被加密的。</p><p><a href="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220814072853.png" class="popup img-link "><img data-src="/assets/blog_res/2022-08-09-HTTP.assets/QQ%E6%88%AA%E5%9B%BE20220814072853.png" alt="QQ截图20220814072853" class="lazyload" data-proofer-ignore></a></p><h2 id="那么https可以看到域名吗--可以"><span class="mr-2">那么HTTPS可以看到域名吗？ – 可以</span><a href="#那么https可以看到域名吗--可以" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TLS 第一次握手的 “Client Hello” 消息中，有个 server name 字段，它就是请求的域名地址。</p><h2 id="关闭keepalive"><span class="mr-2">关闭keepalive</span><a href="#关闭keepalive" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">keepalive</code>必须双方都开启才会生效，只要一方不开启就不生效。</p><p>但是是双方哪方先收到<code class="language-plaintext highlighter-rouge">Connection: Close</code> 则由收到方关闭。</p><p>比如服务器关闭<code class="language-plaintext highlighter-rouge">keepalive</code>，那么写回的请求就是 Connection: Close。浏览器接收到这个后就会调用<code class="language-plaintext highlighter-rouge">close</code>发送<code class="language-plaintext highlighter-rouge">FIN</code>包关闭连接</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=HTTP%20-%20Sterben_01&url=%2Fposts%2FHTTP%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=HTTP%20-%20Sterben_01&u=%2Fposts%2FHTTP%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FHTTP%2F&text=HTTP%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/NET1/"><div class="card-body"> <em class="small" data-ts="1655992500" data-df="YYYY/MM/DD" > 2022/06/23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络 - 传输层1</h3><div class="text-muted small"><p> 计算机网络 - 传输层1 传输层 传输层的功能 传输层提供进程与进程之间的逻辑通信。使用网络层的服务为应用层提供通信服务 复用和分用 复用：应用层所有的应用进程都可以通过传输层传输到网络层。 - 分用：传输层从网络层收到的数据可以交付给不同的应用进程。 对收到的报文进行差错检测 TCP 三次握手 ACK不...</p></div></div></a></div><div class="card"> <a href="/posts/NET2/"><div class="card-body"> <em class="small" data-ts="1655992500" data-df="YYYY/MM/DD" > 2022/06/23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络 - 数据链路层1</h3><div class="text-muted small"><p> 计算机网络 - 数据链路层1 数据链路层 功能概述 为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认! 链路管理，即连接的建立、维持、释放（用于面向连接的服务）。 组帧 流量控制。 差错控制。（帧错、位错） 封装成帧 封装成帧就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/" class="btn btn-outline-primary" prompt="上一篇"><p>项目相关</p></a> <a href="/posts/%E5%8D%95%E4%BE%8B/" class="btn btn-outline-primary" prompt="下一篇"><p>单例模式</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
