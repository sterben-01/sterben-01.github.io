<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Effective STL 笔记" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Effective STL 笔记" /><meta property="og:description" content="Effective STL 笔记" /><link rel="canonical" href="/posts/EFFSTL/" /><meta property="og:url" content="/posts/EFFSTL/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-22T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Effective STL 笔记" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-28T22:15:49-06:00","datePublished":"2022-07-22T01:55:00-05:00","description":"Effective STL 笔记","headline":"Effective STL 笔记","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/EFFSTL/"},"url":"/posts/EFFSTL/"}</script><title>Effective STL 笔记 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Effective STL 笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Effective STL 笔记</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1658472900" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/07/22 </em> </span> <span> 更新于 <em class="" data-ts="1732853749" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2024/11/29 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="23497 字"> <em>130 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="effective-stl-笔记">Effective STL 笔记</h1><h2 id="第二条不要试图编写独立于容器类型的代码"><span class="mr-2">第二条：不要试图编写独立于容器类型的代码。</span><a href="#第二条不要试图编写独立于容器类型的代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>STL 是以泛化原则为基础的：</p><ul><li>数组被泛化为”以其包含的对象的类型为参数“的容器；<li>函数被泛化为”以其使用的迭代器的类型为参数“的算法；<li>指针被泛化为”以其指向的对象的类型为参数“的迭代器；<li>容器被泛化为”序列式和关联式“容器。</ul><p><strong>个人理解一句话：别给多个容器写一个通用的函数。没有意义而且效率低下。</strong></p><h2 id="第三条确保容器中的对象副本正确而高效"><span class="mr-2">第三条：确保容器中的对象副本正确而高效。</span><a href="#第三条确保容器中的对象副本正确而高效" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>当(通过如 insert 或 push_back 之类的操作)向容器中加入对象时，存入容器的是你所指定的对象的拷贝。<li>当(通过如front或back之类的操作)从容器中取出一个对象时，你所得到的是容器中所保存的对象的拷贝。</ul><p>拷贝进来拷贝出去是STL的工作方式</p><p>在存在继承关系的情况下，拷贝动作会导致剥离(slicing)。也就是说，如果你创建了一个存放基类对象的容器，却向其中插入派生类的对象，那么在派生类对象(通过基类的拷贝构造函数)被拷贝进容器时，它所特有的部分(即派生类中的信息)将会丢失。”剥离”问题意味着向基类对象的容器中插入派生类对象几乎总是错误的。使拷贝动作高效、正确，并防止剥离问题发生的一个简单办法是使容器包含指针而不是对象。</p><p>上一句的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span><span class="p">{</span>
 	<span class="c1">//...   </span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="p">{</span>
  <span class="c1">//...  </span>
<span class="p">};</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">;</span> <span class="c1">//容器类型为父类对象</span>
<span class="n">Derived</span> <span class="n">child</span><span class="p">;</span>
<span class="n">father</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span> <span class="c1">//子类对象通过基类复制构造函数复制进类型为父类对象的容器时，子类独有的部分会丢失。</span>
</pre></table></code></div></div><p>所以我们为了实现多态，必须是容器保存父类指针。不能是对象也不能是引用。因为指针是一样大的。对象不是一样大的。而且也没有引用容器。而且对象也没法多态。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span> <span class="n">father</span><span class="p">;</span>
<span class="n">Derived</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">child</span><span class="p">();</span> <span class="c1">//子类指针指向子类对象</span>
<span class="n">Base</span><span class="o">*</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">child</span><span class="p">();</span> <span class="c1">//父类指针指向子类对象两种都可以。</span>
<span class="n">father</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="第四条调用empty而不是检查size是否为0"><span class="mr-2">第四条：调用empty而不是检查size()是否为0。</span><a href="#第四条调用empty而不是检查size是否为0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>个人理解：因为比如链表这种，size()需要线性时间查找一遍之后告诉你size。但是empty是O(1)。所以用empty不要用size更快速。</p><h2 id="第五条区间成员函数优先于与之对应的单元素成员函数"><span class="mr-2">第五条：区间成员函数优先于与之对应的单元素成员函数。</span><a href="#第五条区间成员函数优先于与之对应的单元素成员函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>个人总结：能用区间函数的就不要使用循环一个一个拷贝。增加效率。尤其是序列容器的头插。一个一个插入到头部会造成大量的拷贝和析构。因为每插入一个，后面的元素都要移动一位。</p><p>那么，都有哪些区间成员函数？</p><ul><li>区间创建函数、insert、erase、assign等。</ul><h2 id="第六条-c非常煞笔的分析机制"><span class="mr-2">第六条 C++非常煞笔的分析机制</span><a href="#第六条-c非常煞笔的分析机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C++非常煞笔的分析机制。函数和函数指针。加括号不加括号</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 注意：围绕参数名的括号(比如对f2中d)与独立的括号的区别：围绕参数名的括号被忽略，而独立的括号则表明参数</span>
<span class="c1">// 列表的存在：它们说明存在一个函数指针参数</span>
<span class="kt">int</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// 声明了一个带double参数并返回int的函数</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// 同上，d两边的括号被忽略,可以给参数名加上圆括号</span>
<span class="kt">int</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="c1">// 同上，参数名被忽略</span>
 
<span class="kt">int</span> <span class="nf">g1</span><span class="p">(</span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)());</span> <span class="c1">// 参数是一个指向不带任何参数的函数的指针，该函数返回double值；g1以指向函数的指针为参数</span>
<span class="kt">int</span> <span class="nf">g2</span><span class="p">(</span><span class="kt">double</span> <span class="n">pf</span><span class="p">());</span> <span class="c1">// 同上，pf为隐式指针</span>
<span class="kt">int</span> <span class="nf">g3</span><span class="p">(</span><span class="kt">double</span><span class="p">());</span> <span class="c1">// 同上，省去参数名</span>
</pre></table></code></div></div><p>所以</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dataFile</span><span class="p">),</span> <span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</pre></table></code></div></div><p>这一行代码的解释是：这声明了一个函数<code class="language-plaintext highlighter-rouge">data</code>，其返回值是<code class="language-plaintext highlighter-rouge">list&lt;int&gt;</code>。这个<code class="language-plaintext highlighter-rouge">data</code>函数有两个参数：</p><p>■　第一个参数的名称是<code class="language-plaintext highlighter-rouge">dataFile</code>。它的类型是<code class="language-plaintext highlighter-rouge">istream_iterator&lt;int&gt;</code>。<code class="language-plaintext highlighter-rouge">dataFile</code>两边的括号是多余的，会被忽略。</p><p>■　第二个参数没有名称。它的类型是指向不带参数的函数的指针，该函数返回一个<code class="language-plaintext highlighter-rouge">istream_iterator&lt;int&gt;</code>。</p><p>经典错误</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Widget</span><span class="p">{</span>
    <span class="c1">//...假设Widget有默认构造函数</span>
<span class="p">}</span>
<span class="n">Widget</span> <span class="nf">w</span><span class="p">();</span> <span class="c1">//这是声明了一个名字叫w的函数，该函数没有参数，返回一个Wedget</span>
</pre></table></code></div></div><h2 id="第七条如果容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉"><span class="mr-2">第七条：如果容器中包含了通过new操作创建的指针，切记在容器对象析构前将指针delete掉。</span><a href="#第七条如果容器中包含了通过new操作创建的指针切记在容器对象析构前将指针delete掉" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前提是你真的希望容器内指针指向的对象被析构。在构建二叉树的时候我们并不希望容器内指针指向的对象被析构，因为我们会返回一个根节点。如果析构了东西就都没了。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre>
<span class="k">class</span> <span class="nc">test</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">myfunc</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
            <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">p</span><span class="p">));</span> <span class="c1">//新建一个指向int的指针并放入容器。</span>
        <span class="p">}</span>  
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">DEL</span><span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span> <span class="c1">//创建删除函数利用foreach释放tt容器内的每一个指针指向的资源</span>
        <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>



<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(){}</span>
    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="kt">void</span> <span class="nf">getbug</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">){</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">tt</span><span class="p">;</span> <span class="c1">//函数内创建指针容器</span>
        <span class="n">for_each</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">myfunc</span><span class="p">(),</span> <span class="n">ref</span><span class="p">(</span><span class="n">tt</span><span class="p">),</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">));</span> <span class="c1">//使用foreach和bind。记得传入容器需要加ref</span>
        <span class="n">for_each</span><span class="p">(</span><span class="n">tt</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tt</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">content</span><span class="p">){</span><span class="n">cout</span> <span class="o">&lt;&lt;*</span><span class="n">content</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">});</span> <span class="c1">//使用lambda表达式打印tt容器的每一个值。[]捕获列表没有参数因为我们没有用到上下文变量</span>
        <span class="n">for_each</span><span class="p">(</span><span class="n">tt</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tt</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">DEL</span><span class="p">());</span> <span class="c1">//如果这里不用foreach搭配释放函数释放，那么tt容器在离开函数的时候会被销毁。里面的指针全部都会被移除，但是指向的资源没有释放。导致内存泄漏。因为tt是局部变量。不属于class。</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rrr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span>
    <span class="n">test</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">getbug</span><span class="p">(</span><span class="n">rrr</span><span class="p">);</span>

<span class="p">}</span>

</pre></table></code></div></div><p><strong>这一条的个人解释：容器确实会调用容器内每个元素的析构。但是调用的是对应类型的析构。举个例子<code class="language-plaintext highlighter-rouge">vector&lt;int&gt; a;</code> 和 <code class="language-plaintext highlighter-rouge">vector&lt;int*&gt; b</code>。<code class="language-plaintext highlighter-rouge">a</code>析构的时候调用<code class="language-plaintext highlighter-rouge">int</code>的析构，<code class="language-plaintext highlighter-rouge">b</code>析构的时候调用<code class="language-plaintext highlighter-rouge">int*</code>的析构。但是指针不是类，它没有析构函数，所以什么都没做，仅仅是删掉了指针而没有释放指针所指向的元素。所以容器中所有指针指向的数据全部泄漏。</strong></p><p>容器析构的时候会为每个元素调用<code class="language-plaintext highlighter-rouge">destroy</code>：</p><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220824172240.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220824172240.png" alt="QQ截图20220824172240" class="lazyload" data-proofer-ignore></a></p><p>他为每个元素调用其析构函数。这里是因为传入的是迭代器。所以长这样。</p><p>所以我们普通的比如<code class="language-plaintext highlighter-rouge">myclass</code>可以有<code class="language-plaintext highlighter-rouge">~myclass()</code>这样的析构函数调用，但是<code class="language-plaintext highlighter-rouge">myclass*</code>这种指针类型是没有析构函数的，没有（其实是这种类型的析构函数是trivial的）<code class="language-plaintext highlighter-rouge">~myclass*()</code>。<strong>所以要谨记，容器析构的时候并不是delete，而是调用其对应类类型的析构函数！。</strong></p><p>一个简单明显的例子</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="n">myvec</span><span class="p">;</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
    <span class="k">delete</span> <span class="n">myvec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//去掉这两行会内存泄漏。</span>
    <span class="k">delete</span> <span class="n">myvec</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>所以，当容器储存的是普通对象的时候，并无大碍。但是如果储存的是指针，则必须要手动调用析构函数。</strong></p><h2 id="第-八-条切勿创建包含-auto_ptr-的容器对象"><span class="mr-2">第 八 条：切勿创建包含 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 的容器对象</span><a href="#第-八-条切勿创建包含-auto_ptr-的容器对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">auto_ptr</code> 的容器(简称COAP) 是被禁止的。当你拷贝一个 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 时，它所指向的对象的所有权被移交到拷入的 <code class="language-plaintext highlighter-rouge">auto_ptr</code> 上，而它自身被置为<code class="language-plaintext highlighter-rouge"> NULL</code>。如果你的目标是包含智能指针的容器，这并不意味着你要倒霉，包含智能指针的容器是没有问题的。<strong>但 <code class="language-plaintext highlighter-rouge">auto_ptr </code>非智能指针</strong>。顺带提一句，<code class="language-plaintext highlighter-rouge">auto_ptr</code>在c++11已被摒弃。应使用<code class="language-plaintext highlighter-rouge">unique_ptr</code>或<code class="language-plaintext highlighter-rouge">shared_ptr</code>做替代。</p><h2 id="第-九-条慎重选择删除元素的方法"><span class="mr-2">第 九 条：慎重选择删除元素的方法</span><a href="#第-九-条慎重选择删除元素的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>要删除容器中有特定值的所有对象：</p><ul><li><p>如果容器是vector、string或deque，则使用erase-remove习惯用法。</p><ul><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">VALUE</span><span class="p">),</span> <span class="n">c</span><span class="p">.</span><span class="n">end</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>上面这句的要点是。remove仅是移除。他会把把每一个不和指定value相等的元素轮番赋值给first之后的空间。假设现在是112211要移除2，那么remove后应该是长成111111。最后两个数据是脏数据。remove返回的迭代器就指向倒数第二个1，也就是最开始的脏数据。然后erase使用这个迭代器为起点移除所有到结尾位置的数据。因为这一段全都是脏数据。记住，erase后，size改变，capacity不改变。如果需要改变capacity还需要配合swap或匿名对象。</ul></ul><li><p>如果容器是list，则使用list::remove。</p><li><p>如果容器是一个标准关联容器，则使用它的erase成员函数。</p></ul><li><p>要删除容器中满足特定判别式（条件）的所有对象：</p><ul><li>如果容器是vector、string或deque，则使用erase-remove_if习惯用法。<li>如果容器是list，则使用list::remove_if。<li>如果容器是一个标准关联容器，则使用remove_copy_if和swap，或者写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对它进行后缀递增。防止迭代器失效。</ul><li><p>要在循环内部做某些（除了删除对象之外的）操作：</p><ul><li>如果容器是一个标准序列容器，则写一个循环来遍历容器中的元素，记住每次调用erase时，要用它的返回值更新迭代器。防止迭代器失效。<li>如果容器是一个标准关联容器，则写一个循环来遍历容器中的元素，记住当把迭代器传给erase时，要对迭代器做后缀递增。防止迭代器失效。</ul></ul><h2 id="第-十-条了解分配子allocator的约定和限制--罄待深入了解"><span class="mr-2">第 十 条：了解分配子(allocator)的约定和限制 – 罄待深入了解</span><a href="#第-十-条了解分配子allocator的约定和限制--罄待深入了解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>你的分配子是一个模板，模板参数T代表你为它分配内存的对象的类型。<li>提供类型定义pointer和reference，但是始终让pointer为T* ，reference为T&amp;。<li>千万别让你的分配子拥有随对象而不同的状态（per-object state）。通常，分配子不应该有非静态的数据成员。<li>记住，传给分配子的allocate成员函数的是那些要求内存的对象的个数，而不是所需的字节数。同时要记住，这些函数返回T* 指针（通过pointer类型定义），即使尚未有T对象被构造出来。<li><p>一定要提供嵌套的rebind模板，因为标准容器依赖该模板。</p><li>这里有一点 使用operator new的时候，给的大小是字节数。使用自定义allocator的时候，给的大小是对象的数量。</ul><h2 id="第-十二-条切勿对stl容器的线程安全性有不切实际的依赖"><span class="mr-2">第 十二 条：切勿对STL容器的线程安全性有不切实际的依赖。</span><a href="#第-十二-条切勿对stl容器的线程安全性有不切实际的依赖" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对一个STL实现你最多只能期望：</p><ul><li><strong>多个线程读是安全的</strong> 。多个线程可以同时读同一个容器的内容，并且保证是正确的。自然地，在读的过程中，不能对容器有任何写入操作。<li><strong>多个线程对不同的容器做写入操作是安全的</strong> 。多个线程可以同时对不同的容器做写入操作。</ul><p>实现完全的容器线程安全性时可能采取的方式：</p><ul><li>对容器成员函数的每次调用，都锁住容器直到调用结束。<li>在容器所返回的每个迭代器的生存期结束前，都锁住容器（比如通过begin或end调用）。<li>对于作用于容器的每个算法，都锁住该容器，直到算法结束。（实际上这样做没有意义。因为，如同在第32条中解释的，算法无法知道它们所操作的容器。尽管如此，在这里我们仍要讨论这一选择。因为即便这是可能的，我们也会发现这种做法仍不能实现线程安全性，这对于我们的讨论是有益的。）</ul><p>个人理解：加锁就完事了。</p><p>下面的例子是一个不加锁也安全的例子。<code class="language-plaintext highlighter-rouge">vec</code>虽然是一个容器，但是这个容器里有10个小容器。我开了10个线程给这10个小容器进行多线程同时写入，是安全的。符合要求。也就是所谓的多个线程对不同的容器做写入操作。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>   
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="kr">thread</span> <span class="n">th</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">th</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">push</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span> <span class="c1">//注意，这里是核心。我vec虽然是一个容器，但是我这个容器里有10个小容器。我开了10个线程给这10个小容器进行多线程同时写入，是安全的。符合要求</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">th</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><h2 id="第十四条使用reserve来避免不必要的重新分配"><span class="mr-2">第十四条：使用reserve来避免不必要的重新分配。</span><a href="#第十四条使用reserve来避免不必要的重新分配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对于 vector 和 string，增长过程是这样来实现的：每当需要更多空间时，就调用与 realloc类似的操作。这一类似于 realloc 的操作分为四部分：</p><ul><li>分配一块大小为当前容量的某个倍数的新内存。在大多数实现中，vector 和 string 的容量每次以 2 的倍数增长，即，每当容器需要扩张时，它们的容量即加倍。<li>把容器的所有元素从旧的内存拷贝到新的内存中。<li>析构掉旧内存中的对象。<li>释放旧内存。</ul><p><strong>每当这些步骤发生时，vector或string中所有的指针、迭代器和引用都将变得无效。</strong></p><p><strong>通常有两种方式来使用reserve以避免不必要的重新分配。 第一种方式是，若能确切知道或大致预计容器中最终会有多少元素，则此时可以使用reserve。第二种方式是，先预留足够大的空间(根据你的需要而定)，然后，当把所有数据都加入以后，再去除多余的容量。</strong></p><h2 id="第十七条使用swap技巧除去多余的容量"><span class="mr-2">第十七条：使用“swap技巧”除去多余的容量</span><a href="#第十七条使用swap技巧除去多余的容量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>讲过很多次了。不再赘述了。看下面杂记。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="p">(</span><span class="n">container</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c1</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>
</pre></table></code></div></div><p>表达式<code class="language-plaintext highlighter-rouge">vector&lt;typename&gt;(container)</code>创建一个临时的矢量，它是<code class="language-plaintext highlighter-rouge">container</code>的副本：这是由<code class="language-plaintext highlighter-rouge">vector</code>的<strong>复制构造函数</strong>来完成的。然而，<code class="language-plaintext highlighter-rouge">vector</code>的复制构造函数只为所复制的元素分配所需要的内存，所以这个临时矢量没有多余的容量。然后我们把临时矢量中的数据和<code class="language-plaintext highlighter-rouge">container</code>中的数据做<code class="language-plaintext highlighter-rouge">swap</code>操作，在这之后，<code class="language-plaintext highlighter-rouge">container</code>具有了被去除之后的容量，即原先临时变量的容量，而临时变量的容量则变成了原先<code class="language-plaintext highlighter-rouge">container</code>臃肿的容量。到这时（在语句结尾），临时<code class="language-plaintext highlighter-rouge">vector</code>被析构，从而释放了先前为<code class="language-plaintext highlighter-rouge">container</code>所占据的内存。</p><p><strong>swap两个vector可简单理解为交换tag。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 		<span class="c1">//0x61fdac</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">pa</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0x61fdac</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//0x61fda8</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">pb</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0x61fda8</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">va</span> <span class="o">=</span> <span class="p">{</span><span class="n">pa</span><span class="p">,</span> <span class="n">pb</span><span class="p">};</span>	
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">vb</span> <span class="o">=</span> <span class="p">{</span><span class="n">pb</span><span class="p">,</span> <span class="n">pc</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0xde1490</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//0x61fdac</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0xde14d0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//0x61fda8</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0xde14d0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">va</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//0x61fda8</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>		<span class="c1">//0xde1490</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">vb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//0x61fdac</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们可以看到。VA和VB交换后，VA容器装的指针自己的地址由原来的<code class="language-plaintext highlighter-rouge">0x61fdac</code>换成了<code class="language-plaintext highlighter-rouge">0xde1490</code>。VB亦然。所以可理解为仅仅是把VA的铭牌摘下来换给了VB，VB换给了VA</p><h2 id="第十八条避免使用vectorbool"><span class="mr-2">第十八条：避免使用<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code></span><a href="#第十八条避免使用vectorbool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>同时参考more effective 条款30。</strong></p><p>作为一个STL容器，<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code>只有两点不对。首先，它不是一个STL容器。其次，它并不存储<code class="language-plaintext highlighter-rouge">bool</code>。除此以外，一切正常。</p><p>一个对象并不因为有人说它是一个STL容器，所以它就是了。一个对象要成为STL容器，就必须满足C++标准的第23.1节列出的所有条件。其中的一个条件是，如果<code class="language-plaintext highlighter-rouge">c</code>是包含对象<code class="language-plaintext highlighter-rouge">T</code>的容器，而且<code class="language-plaintext highlighter-rouge">c</code>支持<code class="language-plaintext highlighter-rouge">operator[]</code>，那么下面的代码必须能够被编译：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span><span class="o">*</span> <span class="n">P</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></table></code></div></div><p>换句话说，如果你用<code class="language-plaintext highlighter-rouge">operator[]</code>取得了<code class="language-plaintext highlighter-rouge">Container&lt;T&gt;</code>中的一个T对象，那么你可以通过取它的地址得到一个指向该对象的指针。（这里假定<code class="language-plaintext highlighter-rouge">T</code>没有用非常规的方式对<code class="language-plaintext highlighter-rouge">operator&amp;</code>做重载。）所以，如果<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code>是一个容器，那么下面这段代码必须可以被编译：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="n">v</span><span class="p">;</span>
<span class="kt">bool</span><span class="o">*</span> <span class="n">pb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></table></code></div></div><p>但是它不能编译。不能编译的原因是，<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code>是一个假的容器，它并不真的储存<code class="language-plaintext highlighter-rouge">bool</code>，相反，为了节省空间，它储存的是<code class="language-plaintext highlighter-rouge">bool</code>的紧凑表示。在一个典型的实现中，储存在<code class="language-plaintext highlighter-rouge">vector</code>中的每个<code class="language-plaintext highlighter-rouge">bool</code>仅占一个二进制位，一个8位的字节可容纳8个<code class="language-plaintext highlighter-rouge">bool</code>。在内部，<code class="language-plaintext highlighter-rouge">vector&lt;bool&gt;</code>使用了与位域（bitfield）一样的思想，来表示它所存储的那些<code class="language-plaintext highlighter-rouge">bool</code>；实际上它只是假装存储了这些<code class="language-plaintext highlighter-rouge">bool</code>。<strong>位域与bool相似，它只能表示两个可能的值，但是在bool和看似bool的位域之间有一个很重要的区别:你可以创建一个指向bool的指针，而指向单个位的指针则是不允许的。所以你以为vector存了bool，但其实他储存的不是bool，自然使用[]下标访问返回的也不会是bool*类型的指针，自然无法给bool*类型的变量赋值</strong></p><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230514181512.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230514181512.png" alt="QQ截图20230514181512" class="lazyload" data-proofer-ignore></a></p><p>我们在more effective 条款30的笔记中写的例子就和这个差不多，类内套了一个类。同时<code class="language-plaintext highlighter-rouge">operator[]</code>返回的是代理类对象。所以现在我们可以很好的理解这个例子了。</p><p>当你需要 vector时，标准库提供了两种选择，可以满足绝大多数情况下的需求。</p><ul><li>第一种是 deque。deque 几乎提供了 vector 所提供的一切(没有reserve和capacity)，但deque 是一个 STL 容器，而且它确实存储 bool。当然 deque 中元素的内存不是连续的，所以你不能把 deque 中的数据传递给一个期望 bool 数组的 C API。<li>第二种可以替代 vector 的选择是 bitset。bitset 不是 STL 容器，但它是标准 C++ 库的一部分。与 STL 容器不同的是，它的大小(即元素的个数)在编译时就确定了，所以它不支持插入和删除元素。</ul><h3 id="细节"><span class="mr-2">细节</span><a href="#细节" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>我们有如下代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// 1 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>          <span class="c1">// 0x7ffd1f5c73c0 0x7ffd1f5c73b0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">_M_p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">_M_p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0x5578bbd8eeb0 0x5578bbd8eeb0</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">func2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1 0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>     <span class="c1">// 0x7ffdc06bffac 0x7ffdc06bffa8</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">func3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>  <span class="c1">// 0</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 1 1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>       <span class="c1">// 0x7ffdc06bffa8 0x7ffdc06bffa0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>         <span class="c1">// 0x563d96d19eb0 0x563d96d19eb0</span>
    <span class="k">auto</span> <span class="n">del</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">del</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">func1</span><span class="p">();</span>
    <span class="n">func2</span><span class="p">();</span>
    <span class="n">func3</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们发现，<code class="language-plaintext highlighter-rouge">func1</code>修改了元素的值。但是理论上不应该被修改，如<code class="language-plaintext highlighter-rouge">func2</code>一样。原因就在于<code class="language-plaintext highlighter-rouge">b</code>和<code class="language-plaintext highlighter-rouge">c</code>的类型并不是<code class="language-plaintext highlighter-rouge">bool</code>，而是<code class="language-plaintext highlighter-rouge">std::vector&lt;bool&gt;::reference</code>。所以说他的行为和<code class="language-plaintext highlighter-rouge">func3</code>相似。我们从其元素地址和元素底层的值地址中就可以看出来。</p><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241018222823.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241018222823.png" alt="微信图片_20241018222823" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241018222812.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20241018222812.png" alt="微信图片_20241018222812" class="lazyload" data-proofer-ignore></a></p><h2 id="第十九条理解相等equality和等价equivalence的区别"><span class="mr-2">第十九条：理解相等（equality）和等价（equivalence）的区别。</span><a href="#第十九条理解相等equality和等价equivalence的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>标准关联容器（如set, map）总是保持排列顺序的，所以每个容器必须有一个比较函数（默认为less）来决定保持怎样的顺序。等价的定义正是通过该比较函数而确定的，因此，标准关联容器的使用者要为所使用的每个容器指定一个比较函数（用来决定如何排序）。如果该关联容器使用相等来决定两个对象是否有相同的值，那么每个关联容器除了用于排序的比较函数外，还需要另一个比较函数来决定两个值是否相等。（默认情况下，该比较函数应该是equal_to，但有趣的是，equal_to从来没有被用作STL的默认比较函数。当STL中需要相等判断时，一般的惯例是直接调用operator==。</p><p>个人理解：假如我们让使用set去忽略大小写地插入字符串。则我们会基于set一个仿函数告知他这一点。随后我们插入<code class="language-plaintext highlighter-rouge">"abc"</code> 和<code class="language-plaintext highlighter-rouge">"ABC"</code></p><p>会发现只有第一个可以插入。是因为在这时候，<code class="language-plaintext highlighter-rouge">"abc"</code> 和<code class="language-plaintext highlighter-rouge">"ABC"</code>是<strong>等价</strong>的。但是<code class="language-plaintext highlighter-rouge">"abc"</code> 和<code class="language-plaintext highlighter-rouge">"ABC"</code>并<strong>不相等</strong>。等价是我们认为告知的。</p><h2 id="第二十条为包含指针的容器关联或序列式容器指定自定义比较器"><span class="mr-2">第二十条：为包含指针的容器（关联或序列式容器）指定自定义比较器。</span><a href="#第二十条为包含指针的容器关联或序列式容器指定自定义比较器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如下代码，我们有一个装有指针的容器。如果按照默认排序 当我们使用如下代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">myvec</span><span class="p">;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></table></code></div></div><p>其实会被隐含地推导为如下代码：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">sort</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">);</span>
</pre></table></code></div></div><p>是明显错误的。此处会对指针排序。所以必须自定义比较器。如下。顺便练习删除器。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">deleter</span><span class="p">(</span><span class="n">string</span><span class="o">*</span> <span class="n">item</span><span class="p">){</span> <span class="c1">//自定义删除器。</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">item</span><span class="o">!=</span><span class="nb">nullptr</span><span class="p">){</span>
        <span class="k">delete</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">mydeleter</span><span class="p">{</span> <span class="c1">//自定义删除器。</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">string</span><span class="o">*</span> <span class="n">item</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">item</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">){</span>
                <span class="k">delete</span> <span class="n">item</span><span class="p">;</span>
                <span class="n">item</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">mysort</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">a</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>   
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">myvec</span><span class="p">;</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">"bcd"</span><span class="p">));</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">"cde"</span><span class="p">));</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="s">"abc"</span><span class="p">));</span>


    <span class="n">sort</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//这种排序方式是错误的。这会按照指针的值来排序。错误的。</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mysort</span><span class="p">());</span> <span class="c1">//必须使用自定义比较器。</span>
    
    <span class="n">for_each</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mydeleter</span><span class="p">());</span> <span class="c1">//记住释放指针容器内的指针。上下两种都可以</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">deleter</span><span class="p">);</span> <span class="c1">//记住释放指针容器内的指针。</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>尤其是关联容器在创建之时就需要提供比较器。而默认创建的指针关联式容器的比较器是对指针排序，这明显不是我们希望的。所以创建指针关联式容器的时候就必须指定好我们的自定义比较器。<li>包含智能指针或迭代器的容器亦如此。</ul><h2 id="第二十一条总是让比较函数在等值情况下返回false"><span class="mr-2">第二十一条：总是让比较函数在等值情况下返回false。</span><a href="#第二十一条总是让比较函数在等值情况下返回false" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myfunc</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">&lt;=</span><span class="n">b</span><span class="p">;</span> <span class="c1">//注意这里</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myfunc</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">s</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这个set会储存两个10和一个11。这破坏了规则。</p><p>因为set会先判断两个参数是否<strong>等价</strong>。这意味着是根据我们的规则来的</p><p>他会这么判断：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="o">!</span><span class="p">(</span><span class="mi">10</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="mi">10</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">);</span>
<span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span><span class="p">;</span>
<span class="nb">false</span><span class="p">;</span>
</pre></table></code></div></div><p>这样他会返回不等价。于是就塞进去了。这不应该。</p><p>所以永远记住，在任何情况下都要让自定义比较函数在两个变量相等的情况下返回<code class="language-plaintext highlighter-rouge">false</code>。术语叫严格弱序化。</p><h2 id="第二十二条切勿直接修改set或multiset中的键"><span class="mr-2">第二十二条：切勿直接修改set或multiset中的键。</span><a href="#第二十二条切勿直接修改set或multiset中的键" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>我们已经知道了无法修改map和multimap的key。是因为保存至红黑树的<code class="language-plaintext highlighter-rouge">pair</code>里面的<code class="language-plaintext highlighter-rouge">key</code>是<code class="language-plaintext highlighter-rouge">const</code>的。(下面提到了)。<li>set不允许更改值是因为迭代器返回的是常量迭代器也就是<code class="language-plaintext highlighter-rouge">const iterator</code></ul><p>假设我们现在有个<code class="language-plaintext highlighter-rouge">student</code>，里面包含了<code class="language-plaintext highlighter-rouge">id</code>和<code class="language-plaintext highlighter-rouge">name</code>。我们有个装有它的<code class="language-plaintext highlighter-rouge">set</code>。并且使用<code class="language-plaintext highlighter-rouge">ID</code>来进行排序。</p><p><strong>假设我们想更改名字，可以吗？可以。因为针对<code class="language-plaintext highlighter-rouge">set</code>的排序是<code class="language-plaintext highlighter-rouge">student</code>的<code class="language-plaintext highlighter-rouge">id</code>。也就是说，实际上，<code class="language-plaintext highlighter-rouge">student</code>的<code class="language-plaintext highlighter-rouge">ID</code>是这个<code class="language-plaintext highlighter-rouge">set</code>中元素的键(key), 而其他数据比如<code class="language-plaintext highlighter-rouge">name</code>只不过和这个键绑在一起而已。所以没有理由不能更改非key的部分。</strong></p><p>但是实际做起来有些麻烦。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">student</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">student</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">name</span><span class="p">(</span><span class="n">y</span><span class="p">){};</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">change_name</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">mycomp</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">student</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">student</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">){</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>   
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">set</span><span class="o">&lt;</span><span class="n">student</span><span class="p">,</span> <span class="n">mycomp</span><span class="o">&gt;</span> <span class="n">my_set</span><span class="p">;</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">student</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">"miku"</span><span class="p">));</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">student</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"luka"</span><span class="p">));</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">student</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">"nozomi"</span><span class="p">));</span>

    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>			
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出miku</span>
    <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">student</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">).</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changedmiku"</span><span class="p">);</span> <span class="c1">//1</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">student</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">).</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changedmiku"</span><span class="p">);</span> <span class="c1">//2</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//经过1输出changedmiku, 经过2不变，输出miku。</span>



    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>这里的1是对的。2是错的。我来解释为什么。</strong><li>首先，我们提到了，<code class="language-plaintext highlighter-rouge">set</code>拿到的迭代器是常量迭代器也就是<code class="language-plaintext highlighter-rouge">const iterator</code>。所以我们需要把它的<code class="language-plaintext highlighter-rouge">const</code>弄掉才行。<ul><li>注意为什么我们使用了<code class="language-plaintext highlighter-rouge">student&amp;</code>做为新的类型？第一是因为<code class="language-plaintext highlighter-rouge">const_cast</code>只接受指针或引用类型的转换。不支持转换对象。<li>其次，我们需要作用到原来的对象上。所以必须使用引用的方式。来让这个临时cast出来的对象是一个原对象的引用，这样才能施加操作到原来的对象上。<li>记得我们在杂记2说的，四种cast不改变原对象，会生成一个新的对象。</ul><li>如果使用2的方式，我们会cast出一个临时的匿名对象出来。然后把<code class="language-plaintext highlighter-rouge">change_name</code>施加到了临时对象上。所以没用。</ul><p><strong>如果我们想自由，安全的对四种关联容器进行元素修改。应使用如下几步：</strong></p><ol><li>找到你想修改的容器的元素。如果你不能肯定最好的做法，第45条介绍了如何执行一次恰当的搜索来找到特定的元素。<li>为将要被修改的元素做一份副本。在map或multimap的情况下，请记住，不要把该副本的第一个部分声明为const。毕竟，你想要改变它。<li>修改该副本，使它具有你期望它在容器中的值。<li>把该元素从容器中删除，通常是通过调用erase来进行的（见第9条）。<li>把新的值插入到容器中。如果按照容器的排列顺序，新元素的位置可能与被删除元素的位置相同或紧邻，则使用“提示”（hint）形式的insert，以便把插入的效率从对数时间提高到常数时间。把你从第1步得来的迭代器作为提示信息。</ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">student</span> <span class="nf">target</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"luka"</span><span class="p">);</span> <span class="c1">//目标对象</span>
<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> <span class="c1">// 1 寻找目标对象 </span>
<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> <span class="c1">//如果找到了</span>
    <span class="n">student</span> <span class="n">temp</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>  <span class="c1">// 2 获取一个目标副本</span>
    <span class="n">temp</span><span class="p">.</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changed_luka"</span><span class="p">);</span> <span class="c1">//3 对副本施加更改操作</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//4 把容器内的对应源元素删除。注意set的erase会返回一个指向删除的元素后面的第一个元素的迭代器。</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span> <span class="c1">//5 在指定位置插入。</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="第二十三条考虑使用排序的vector替换关联容器"><span class="mr-2">第二十三条：考虑使用排序的vector替换关联容器</span><a href="#第二十三条考虑使用排序的vector替换关联容器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这个建议的前提是这个容器会有如下三个阶段：</p><ul><li>创建一个新的数据结构，并插入大量元素，在这个阶段，几乎所有的操作都是插入和删除操作。很少或几乎没有查找操作。<li>查找阶段：查询该数据结构找到特点的信息，在这个阶段，几乎所有的操作都是查找很少或几乎没有删除。<li>重组阶段：改变数据结构的内容。</ul><p>为什么这样的容器最好使用vector？</p><ul><li>关联式容器针对保存的每一个对象都需要额外的指针。比如map和set使用红黑树，unordered使用哈希表。都需要额外指针。这也就导致需要更多的内存。<li>关联式容器不保证是否在物理内存中相邻，所以在进行如二分查找时，会遇到更多的缺页错误。</ul><p>但是这里必须保证vector有序，但是在插入或删除元素的时候，或重新分配内存的时候都会进行移动或拷贝。这开销极大，但是关联容器却没有这个缺点。<strong>所以对数据结构的使用方式是：查找操作几乎从不跟插入和删除操作混在一起”时，再考虑使用排序的vector而不是关联容器才是合理的。</strong></p><h2 id="第四十五条正确区分countfindbinary_searchlower_boundupper_bound和equal_range"><span class="mr-2">第四十五条：正确区分count、find、binary_search、lower_bound、upper_bound和equal_range。</span><a href="#第四十五条正确区分countfindbinary_searchlower_boundupper_bound和equal_range" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>在使用<code class="language-plaintext highlighter-rouge">序列容器</code>和<code class="language-plaintext highlighter-rouge">multimap</code>, <code class="language-plaintext highlighter-rouge">multiset</code>的时候，<code class="language-plaintext highlighter-rouge">find</code>效率比<code class="language-plaintext highlighter-rouge">count</code>快。因为<code class="language-plaintext highlighter-rouge">count</code>总是会遍历完整个区间 或 检查容器中的每一个对象。而<code class="language-plaintext highlighter-rouge">find</code>找到后就可以返回。<ul><li>但是在<code class="language-plaintext highlighter-rouge">set</code>和<code class="language-plaintext highlighter-rouge">map</code>里面不是问题，因为<code class="language-plaintext highlighter-rouge">set</code>不允许重复值，<code class="language-plaintext highlighter-rouge">map</code>不允许重复键。所以<code class="language-plaintext highlighter-rouge">count</code>总是会返回0或1</ul></ul><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220922003210.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220922003210.png" alt="QQ截图20220922003210" class="lazyload" data-proofer-ignore></a></p><h1 id="杂记">杂记</h1><ul><li>remove的原理是把每一个不和指定value相等的元素轮番赋值给first之后的空间。 假如我们有{0,1,0,2,0,3,0,4}，要移除所有的0， remove后会变成 {1,2,3,4,0,3,0,4} 。你使用auto打印或者是迭代器遍历的话，也会输出{1,2,3,4,0,3,0,4}。所以他什么都不删除。从下标[4]开始后的是脏数据。 所以<strong>remove不改变size，也不改变capacity</strong> 所以要利用返回的迭代器配合erase使用。</ul><p><a href="/assets/blog_res/2022-07-20-OS31.assets/QQ%E6%88%AA%E5%9B%BE20220723013129.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-OS31.assets/QQ%E6%88%AA%E5%9B%BE20220723013129.png" alt="QQ截图20220723013129" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>可以把capacity理解为STL为整个容器分配的数据存储空间的大小，size理解为尾迭代器和头迭代器的区间距离。</strong>所以erase和remove因为都不改变capacity的大小（new出来的内存没办法动态扩缩容，只能搬移），所以数据不会真正删除，而是覆盖式赋值后，如果size改变，就改变end迭代器位置，如果不改变则不动<ul><li>这就是为什么remove不改变size，因为覆盖式赋值后end迭代器指向位置不变<li>这也是为什么erase改变size，因为覆盖式赋值后end迭代器指向的位置变化了。</ul><li>unique也一样，是轮番赋值，不改变size和capacity。<li>erase会<strong>调用析构</strong>移除数据（意味着没有析构就啥也不干）。同时将容器size缩短（更改end迭代器位置），但是依旧不改变capacity。 <strong>改变capacity可以在清除完需要的数据后使用swap或者是直接用匿名对象赋值</strong>。注意，erase依旧是和remove一样，覆盖式赋值[<strong>注意这里只针对序列式容器</strong>]（把vector中要删除位置后面的所有数据移动到要删除的位置）。但是erase会把后面的脏数据删掉 <strong>[注意：用int做实验的时候因为int没有析构函数，所以数据还在那。]（但是自定义类型会调用析构函数。注意！调用析构函数不代表数据会被删除或内存被释放！！释放内存依靠的是delete。）</strong>。又因为capacity不改变，所以依旧可以强制访问。<ul><li>注意，erase调用的析构函数是自定义对象的析构。自定义对象一般在类成员有指针的时候才会有显式析构。这时候，erase调用析构仅仅是把元素的指针变量指向的数据释放掉，但是元素的指针啊，普通变量啊都还在。这时候如果强制访问了指针，会出现危险访问。这也是为什么析构函数里面，释放掉指针指向的变量后一定要将指针显式置空。<li>这里依旧注意指针容器。指针类型没有我们心中的析构函数。仅仅是指针自己没了而已。资源还在。所以此处有潜在可能导致内存泄漏。</ul><li>这也是为什么没有任何一个函数可以改变容器的capacity。容器的capacity是容器的分配器给容器元素分配的内存，也就是说过的<code class="language-plaintext highlighter-rouge">new</code>了一块区域。这块的大小不能变。所以唯一的办法就是把整个容器析构然后新建。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">t1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
<span class="n">t1</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//erase了，数据清除改变size但是不改变capacity</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="c1">//临时对象释放法</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">).</span><span class="n">swap</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="c1">//swap释放法。</span>
</pre></table></code></div></div><ul><li><p>clear直接调用的erase</p><li><p>reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能访问容器内的元素，因此当加入新的元素时，需要用push_back()/insert()函数。reserve不修改size大小，只修改capacity大小。而且<strong>只增不减</strong>。reserve强迫容器把它的容量变为至少是n，前提是n不小于当前的大小。这通常会导致重新分配，因为容量需要增加。（如果n比当前的容量小，则vector忽略该调用，什么也不做；而string则可能把自己的容量减为size()和n中的最大值，但是string的大小肯定保持不变。）。<strong>记住，在reserve后不可以直接使用下标的方式为其赋值，例如<code class="language-plaintext highlighter-rouge">vector[1] = 4</code>这样的形式，因为reserve不构建元素。没有赋值之前，直接去访问元素会导致访问到未初始化的元素。</strong></p><li><p>resize是改变容器的大小，并且创建元素对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。</p><ul><li>resize<strong>不改变</strong>capacity大小。<li>resize的容器，如果n比当前的大小（size)要小，元素并没有被删除。依旧可以被访问到。在调用resize之后，size将返回n。<del>如果n比当前的大小（size）要小，则容器尾部的元素将会被析构。</del> （这段应该是不同编译器实现不一样）。<li>如果n比当前的<strong>大小(size)</strong>要大，则通过默认构造函数创建的新元素（就是用 你给的用来填充的容器的值 创建的元素）将被添加到容器的末尾。<li>如果n比当前的<strong>容量（capacity)</strong>要大，那么在添加元素之前，将先重新分配内存。</ul></ul><p>上一条举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 		<span class="c1">//0</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//10</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">22</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>			<span class="c1">//11</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//20</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//0xd618c0</span>
    <span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>				<span class="c1">//此时resize的大小，大于size，小于capacity，不会发生内存重新分配</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>			<span class="c1">//15</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//20</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//0xd618c0</span>
    <span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>					<span class="c1">//此时resize的大小，大于capacity，发生内存重新分配</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>			<span class="c1">//25</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//30</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>			<span class="c1">//0xd61940</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新增例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//8</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//8</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>					<span class="c1">//resize缩小了</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//size变为2</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//capacity不变，仍是8</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">myvec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>			<span class="c1">//因为capacity不变，所以依旧可以访问数据，但是因为size改变了，end位置改变了，所以无法通过遍历的方式访问。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    
    
    <span class="n">myvec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>		<span class="c1">//size变为100。因为resize会创建元素</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>	<span class="c1">//capacity变为100。因为扩张了发生了内存重新分配。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>capacity是vector和string独有的。它是预分配的内存容量。使用reserve时分配的就是这个。预分配也是分配了。所以也占用空间。<li>STL是拷贝进来，拷贝出去的执行方式。即便是形参是引用，也会拷贝实际数据成员至容器。形参是引用只是防止入参时候的拷贝，但是放入容器依旧是拷贝。如果形参不是引用，则会拷贝两次。第一次是入参时，第二次是放入容器时。<div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">addval</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
  <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">//obj会被拷贝至容器。</span>
<span class="p">}</span> 
</pre></table></code></div></div><li><strong>容器本身在栈上，容器的数据在堆上。也就是<code class="language-plaintext highlighter-rouge">vector&lt;int&gt; a(100, 5);</code>。<code class="language-plaintext highlighter-rouge">vector a</code>本身在栈上，但是这100个5在堆上。STL帮我们执行内存分配和释放。<code class="language-plaintext highlighter-rouge">a</code>的本身大小只有三根指针。</strong><li><strong><code class="language-plaintext highlighter-rouge">array</code>是个例外。</strong><ul><li>原始数组也就是 <code class="language-plaintext highlighter-rouge">T a[]</code>这种静态数组是栈上的<li>原始数组<code class="language-plaintext highlighter-rouge">new </code>出来的在堆上（啥玩意new的都在堆）<li><strong>STL的array也是在栈上的。并且和原始数组一样是编译时创建。</strong></ul></ul><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220803230048.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220803230048.png" alt="QQ截图20220803230048" class="lazyload" data-proofer-ignore></a></p><ul><li>使用<code class="language-plaintext highlighter-rouge">vector</code>的构造函数初始化<code class="language-plaintext highlighter-rouge">vector</code>的时候，是会<strong>创建元素</strong>的。<code class="language-plaintext highlighter-rouge">push_back</code>会直接在尾部添加元素，所以这是<code class="language-plaintext highlighter-rouge">reserve</code>存在的意义。</ul><p>举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">444</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">myvec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面这段代码会输出<code class="language-plaintext highlighter-rouge">0 0 444</code>。因为使用了<code class="language-plaintext highlighter-rouge">vector</code>的有参构造默认初始化了元素，也就是<strong>创建了元素</strong>，这样在尾部添加的话自然会添加在后面而不是覆盖。这也是为什么<code class="language-plaintext highlighter-rouge">reserve</code>不可以用下标访问（因为只分配储存空间，而不创建元素），而有参构造可以。</p><h1 id="vector扩容后调用移动构造的问题">vector扩容后调用移动构造的问题</h1><ul><li><strong>vector扩容后，如果储存的元素有移动构造且移动构造函数声明为<code class="language-plaintext highlighter-rouge">noexcept</code>，那么就会触发移动构造</strong>。<ul><li>注意这一条仅适用于扩容的操作。在不是扩容的场景下，非<code class="language-plaintext highlighter-rouge">noexcept</code>也可以触发移动。</ul></ul><h1 id="vector创建时使用构造函数或reserve">vector创建时使用构造函数或reserve</h1><ul><li>使用有参构造函数的两种方式都会创建元素。所以<code class="language-plaintext highlighter-rouge">push_back</code>会在创建的元素后添加。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">v1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">v2</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">v1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">v2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">v1</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出0 0 0 0 0 100</span>
<span class="p">}</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">v2</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出0 0 0 0 0 100</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>使用无参构造函数不会创建元素。所以必须使用<code class="language-plaintext highlighter-rouge">push_back</code>类函数来进行插入。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">v3</span><span class="p">;</span>
<span class="n">v3</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">v3</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//只输出100</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>我们提到过，<code class="language-plaintext highlighter-rouge">reserve</code>只预留空间，不创建元素。所以必须使用<code class="language-plaintext highlighter-rouge">push_back</code>类函数来进行插入。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">v4</span><span class="p">;</span>
<span class="n">v4</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">v4</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">v4</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//只输出100</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>我们提到过，<code class="language-plaintext highlighter-rouge">resize</code>是改变容器的大小，并且创建元素对象，因此，调用这个函数之后，就可以引用容器内的对象了。所以<code class="language-plaintext highlighter-rouge">push_back</code>会在创建的元素后添加。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">v5</span><span class="p">;</span>
<span class="n">v5</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">v5</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">v5</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出0 0 0 0 0 100</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="emplace_back-和-push_back-区别">emplace_back 和 push_back 区别</h1><ul><li><code class="language-plaintext highlighter-rouge">emplace_back()</code>在容器尾部添加一个元素时，可以直接传入构造函数需要的参数来直接在容器内原地构造。因为<code class="language-plaintext highlighter-rouge">emplace_back</code>使用了完美转发。也就时使用<code class="language-plaintext highlighter-rouge">emplace_back()</code>可以不显式调用对象的构造函数来避免一次额外的构造。<strong>就是把所需参数完美转发至元素类型的构造函数。注意，是储存元素类型的构造函数</strong><li><li>具体触发移动构造或拷贝构造的规则<ol><li><code class="language-plaintext highlighter-rouge">emplace_back</code>直接传入默认构造需要的参数时，不论是否有移动构造函数，都是原地构造，只会调用一次<strong>对应的构造函数</strong>。<ol><li><code class="language-plaintext highlighter-rouge">emplace_back</code>不可以使用参数列表。</ol><li><code class="language-plaintext highlighter-rouge">emplace_back</code>以左值对象的形式传入时，不论是否有移动构造函数，都是只调用一次<strong>拷贝构造</strong>。<li><code class="language-plaintext highlighter-rouge">emplace_back</code>以显式调用对象构造函数形式传入时（临时对象，右值）：<ul><li>如果有移动构造，则先调用<strong>对应的构造函数</strong>构造临时对象，然后因为是临时对象触发<strong>移动构造</strong><li>如果没有移动构造，则先调用<strong>对应的构造函数</strong>构造临时对象然后调用<strong>拷贝构造</strong></ul><li><code class="language-plaintext highlighter-rouge">emplace_back</code>以右值对象（例如<code class="language-plaintext highlighter-rouge">move</code>（左值对象），或者就是右值）的形式传入时 :<ol><li>如果有移动构造则只触发<strong>移动构造</strong>。<li>如果没有移动构造，则调用<strong>拷贝构造</strong></ol></ol></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">vala</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">valb</span><span class="p">(</span><span class="n">y</span><span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">vala</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">vala</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">valb</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">valb</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">){</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">vala</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">vala</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">valb</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">valb</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"mv constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">vala</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">valb</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  
    <span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>          <span class="c1">//1直接传入默认构造需要的参数时，不论是否有移动构造函数，都是原地构造，只会调用一次默认构造函数</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span>		<span class="c1">//1.1不可以，不能使用参数列表。</span>
    
    <span class="n">myobj</span> <span class="nf">mm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>           <span class="c1">//2 左值对象的形式传入时，不论是否有移动构造函数，因为对象已经存在，所以只调用一次拷贝构造。</span>
    
	<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> 	<span class="c1">//3 显式使用构造函数时，先调用对应的构造函数构造临时对象，然后因为是临时对象触发移动构造</span>
    							  <span class="c1">//如果此时没有移动构造，则先调用对应的构造函数构造临时对象然后调用拷贝构造</span>
	<span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>			<span class="c1">//4 右值对象传入时（如使用move)，如果有移动构造则只触发移动构造。</span>
										<span class="c1">//如果此时没有移动构造，则调用拷贝构造</span>

	<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>      <span class="c1">//先调用默认构造，然后因为是临时对象触发移动构造</span>
	<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>             <span class="c1">//不可以</span>

<span class="p">}</span>
</pre></table></code></div></div><ul><li>使用<code class="language-plaintext highlighter-rouge">push_back</code>,必须先调用对象的默认构造然后根据是临时对象与否（右值或左值）来决定调用拷贝构造还是移动构造。<ul><li>具体触发移动构造或拷贝构造的规则:<ol><li><code class="language-plaintext highlighter-rouge">push_back</code>以参数列表的形式传入时<ul><li>有移动构造函数，先调用<strong>对应的构造函数</strong>构造临时对象，再使用<strong>移动构造</strong>。<li>没有移动构造函数，先调用<strong>对应的构造函数</strong>构造临时对象，然后使用<strong>拷贝构造</strong>。<li><code class="language-plaintext highlighter-rouge">push_back</code>不可以直接传入构造函数所需参数。必须使用参数列表。</ul><li><code class="language-plaintext highlighter-rouge">push_back</code>以左值对象的形式传入时，不论是否有移动构造函数，都是调用一次<strong>拷贝构造</strong>函数<li><code class="language-plaintext highlighter-rouge">push_back</code>以显式调用对象构造函数形式传入时（临时对象，右值）：<ul><li>如果有移动构造，则先调用<strong>对应的构造函数</strong>构造临时对象，然后因为是临时对象触发<strong>移动构造</strong><li>如果没有移动构造，则先调用<strong>对应的构造函数</strong>构造临时对象然后调用<strong>拷贝构造</strong></ul><li><code class="language-plaintext highlighter-rouge">push_back</code>以右值对象（例如<code class="language-plaintext highlighter-rouge">move</code>（左值对象），或者就是右值）的形式传入时 :<ul><li>如果有移动构造则只触发<strong>移动构造</strong>。<li>如果没有移动构造，则调用<strong>拷贝构造</strong></ul></ol></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">});</span>			<span class="c1">//1使用参数列表的时候，先调用对应的构造函数构造临时对象，如果有移动构造则直接使用移动构造。</span>
							<span class="c1">//如果没有，先调用对应的构造函数构造临时对象，然后使用拷贝构造。</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>             <span class="c1">//1.1不可以</span>

<span class="n">myobj</span> <span class="nf">mm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>  		<span class="c1">//2以左值对象的形式传入时，不论是否有移动构造函数，都是调用一次拷贝构造函数</span>

<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span>      <span class="c1">//3显式使用构造函数时，先调用对应的构造函数构造临时对象，然后因为是临时对象触发移动构造</span>
    							  <span class="c1">//如果此时没有移动构造，则先调用对应的构造函数构造临时对象然后调用拷贝构造</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">mm</span><span class="p">));</span>		<span class="c1">//4右值对象传入时（如使用move)，如果有移动构造则只触发移动构造。</span>
								<span class="c1">//如果此时没有移动构造，则调用拷贝构造</span>

</pre></table></code></div></div><ul><li><p>使用<code class="language-plaintext highlighter-rouge">emplace_back</code>传入<code class="language-plaintext highlighter-rouge">pair</code>的时候不要忘记，<code class="language-plaintext highlighter-rouge">emplace_back</code>是原地构造。就是把所需参数完美转发至<strong>元素类型</strong>的构造函数。</p><p>所以</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">history</span><span class="p">;</span>
<span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"1b23"</span><span class="p">;</span>
<span class="n">history</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">({</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">});</span> <span class="c1">//错误。这时候错误地传入了pair构造完毕的临时对象。</span>
<span class="n">history</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//正确，传入构造pair对象所需要的参数。</span>
</pre></table></code></div></div></ul><h3 id="针对花括号初始化器的问题"><span class="mr-2">针对花括号初始化器的问题</span><a href="#针对花括号初始化器的问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>不推导语境在模板笔记<li><code class="language-plaintext highlighter-rouge">std::initializer_list</code>的笔记在杂记3</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">myvec</span><span class="p">;</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// OK</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">//不行.</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为什么这个地方用<code class="language-plaintext highlighter-rouge">emplace_back</code>不可以? 因为你以为<code class="language-plaintext highlighter-rouge">{1,3}</code>是<code class="language-plaintext highlighter-rouge">initializer_list</code>, 但是其实它啥都不是. 因为看见这种花括号列表, 想让它变成<code class="language-plaintext highlighter-rouge">initializer_list</code>是有条件的. 要么是我们在做函数调用且该函数入参恰好需要个<code class="language-plaintext highlighter-rouge">initializer_list</code>, 要么是用<code class="language-plaintext highlighter-rouge">auto</code>推导一下.</p><p>同时, <code class="language-plaintext highlighter-rouge">push_back</code>是函数, 而<code class="language-plaintext highlighter-rouge">emplace_back</code>是函数模板. 所以说它需要依照类型推导来合成. 也就是<code class="language-plaintext highlighter-rouge">emplace_back</code>接受一个以<code class="language-plaintext highlighter-rouge">initializer_list</code>为入参的前提是<code class="language-plaintext highlighter-rouge">{1,3}</code>是一个<code class="language-plaintext highlighter-rouge">initializer_list</code>. 但是<code class="language-plaintext highlighter-rouge">{1,3}</code>变成<code class="language-plaintext highlighter-rouge">initializer_list</code>的前提是<code class="language-plaintext highlighter-rouge">emplace_back</code>有接受一个<code class="language-plaintext highlighter-rouge">initializer_list</code>的版本. 然后就死锁了.</p><p><strong>顺带一提, 形参非<code class="language-plaintext highlighter-rouge">initializer_list</code>的时候且实参是花括号初始化器列表的时候, 这个是不推导语境.</strong></p><p>所以应该怎么办? 有三种办法.</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// 手动构造initializer_list</span>
<span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="o">&lt;</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span> <span class="c1">// 显式指明模板参数, 放弃自动推导</span>
<span class="k">auto</span> <span class="n">input</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span> <span class="c1">// 使用auto推导, 此时auto类型推导为initializer_list&lt;int&gt;</span>
<span class="n">myvec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">input</span><span class="p">);</span> <span class="c1">// 利用游戏规则</span>
</pre></table></code></div></div><h3 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>所以上面我们发现了，<code class="language-plaintext highlighter-rouge">emplace_back</code> 和<code class="language-plaintext highlighter-rouge">push_back</code>主要的使用场景区别就在于是否可以被原地构造。也就是可以被原地构造的时候（直接传入对象构造函数所需要的参数的时候）使用<code class="language-plaintext highlighter-rouge">emplace_back</code>。其余场合没有区别。另外就是需要注意用花括号初始化器的问题.</p><p><strong>一句话：push_back总是先创建对象，然后拷贝/移动到容器。emplace则可以选择直接在容器内构造对象。所以只有当我们想原地构造（直接放入容器 （直接传入构造函数参数，调用构造函数来直接构建对象））的时候选用emplace才是最佳方法。如果是想要<em>移入</em>一个已存在的对象，则没有区别。因为二者遇到右值对象的时候都会调用移动构造。</strong></p><h1 id="map的emplace原地构造和forward_as_tuple">map的emplace原地构造和forward_as_tuple</h1><p>先看一段代码</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj constructor with arg"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj constructor with arg2"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">myobj</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj destructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj copy assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="p">(</span><span class="k">const</span> <span class="n">myobj</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj move assignment"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"myobj move constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myobj</span><span class="o">&gt;</span> <span class="n">mymap</span><span class="p">;</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myobj</span><span class="o">&gt;</span> <span class="n">mymap1</span><span class="p">;</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myobj</span><span class="o">&gt;</span> <span class="n">mymap11</span><span class="p">;</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myobj</span><span class="o">&gt;</span> <span class="n">mymap21</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">mymap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">mymap</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 不可能，别想了</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">mymap11</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">myobj</span><span class="p">());</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">mymap1</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">());</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"-----"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
mymap2:
myobj constructor
myobj move constructor
myobj copy constructor
myobj destructor
myobj destructor
----- mymap
myobj constructor with arg
----- mymap11
myobj constructor
myobj move constructor
myobj destructor
----- mymap1
myobj constructor
-----
*/</span>
</pre></table></code></div></div><p>我们发现。<code class="language-plaintext highlighter-rouge">mymap2</code>构造一次，移动一次，拷贝一次。<code class="language-plaintext highlighter-rouge">mymap</code>用了有参构造一次。<code class="language-plaintext highlighter-rouge">mymap11</code> 构造一次 移动一次。而<code class="language-plaintext highlighter-rouge">mymap1</code>只构造一次</p><p><code class="language-plaintext highlighter-rouge">mymap2</code>我们使用了初始化列表。构造是构造原始对象，移动是移动构造到<code class="language-plaintext highlighter-rouge">initializer_list</code>, 拷贝是拷贝构造到容器内。</p><p><code class="language-plaintext highlighter-rouge">mymap</code>我们使用了有参构造。有参构造的时候<code class="language-plaintext highlighter-rouge">emplace</code>就地构造可以把参数转发给对应的构造函数，自然只构造一次。</p><p><code class="language-plaintext highlighter-rouge">mymap11</code>我们也使用了<code class="language-plaintext highlighter-rouge">emplace</code>就地构造。构造是构造原始对象，移动是<code class="language-plaintext highlighter-rouge">emplace</code>移动构造到容器内。我们要理解就地构造，就地构造也是使用了参数就地构造。此时参数是右值的原始对象。所以调用了移动构造。为什么一定要一次拷贝或移动？原因是我们如果想用默认构造，那么就不能有参数。如果不传参数那么<code class="language-plaintext highlighter-rouge">emplace</code>怎么办？没办法。所以如果想用无参构造则必须先构造临时对象然后移动进去。</p><p>如果是多个参数呢？咋办？同时无参的时候需要拷贝或移动，是不是看起来很烦？下面就是如何解决这个问题。</p><h2 id="stdpiecewise_construct"><span class="mr-2">std::piecewise_construct</span><a href="#stdpiecewise_construct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">std::piecewise_construct_t</code> 是一个空类标签类型，用于区分接受两个元组实参的不同函数。也就是说，这个<code class="language-plaintext highlighter-rouge">tag</code>表明后面的两个 <code class="language-plaintext highlighter-rouge">tuple</code> 应当被分别传递给 <code class="language-plaintext highlighter-rouge">std::pair</code> 的两个成员的构造函数（<code class="language-plaintext highlighter-rouge">first</code> 和 <code class="language-plaintext highlighter-rouge">second</code>），而不是将整个<code class="language-plaintext highlighter-rouge">tuple</code> 作为一个单独的参数传递。</p><p>这个东西会匹配到一个<code class="language-plaintext highlighter-rouge">pair</code>针对<code class="language-plaintext highlighter-rouge">tuple</code>的特化：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// tuple.cpp</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_T2</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">_Args1</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">_Args2</span><span class="p">&gt;</span>
<span class="n">_GLIBCXX20_CONSTEXPR</span> <span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;::</span><span class="n">pair</span><span class="p">(</span><span class="n">piecewise_construct_t</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args1</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">__first</span><span class="p">,</span>
                                                 <span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args2</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">__second</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">pair</span><span class="p">(</span><span class="n">__first</span><span class="p">,</span> <span class="n">__second</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Build_index_tuple</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">_Args1</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">__type</span><span class="p">(),</span>
           <span class="k">typename</span> <span class="n">_Build_index_tuple</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">_Args2</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">__type</span><span class="p">())</span> <span class="p">{}</span> <span class="c1">// 委托构造给下面的</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_T2</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">_Args1</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">_Indexes1</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">_Args2</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">...</span> <span class="n">_Indexes2</span><span class="p">&gt;</span>
<span class="n">_GLIBCXX20_CONSTEXPR</span> <span class="kr">inline</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="o">&gt;::</span><span class="n">pair</span><span class="p">(</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args1</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">__tuple1</span><span class="p">,</span>
                                                 <span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args2</span><span class="p">...</span><span class="o">&gt;&amp;</span> <span class="n">__tuple2</span><span class="p">,</span>
                                                 <span class="n">_Index_tuple</span><span class="o">&lt;</span><span class="n">_Indexes1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
                                                 <span class="n">_Index_tuple</span><span class="o">&lt;</span><span class="n">_Indexes2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">first</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">_Indexes1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__tuple1</span><span class="p">))...),</span>
      <span class="n">second</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">_Indexes2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">__tuple2</span><span class="p">))...)</span> <span class="p">{}</span>
<span class="c1">// stl_pair.h</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">_Args1</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">_Args2</span><span class="p">&gt;</span>
<span class="n">_GLIBCXX20_CONSTEXPR</span> <span class="nf">pair</span><span class="p">(</span><span class="n">piecewise_construct_t</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args1</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span><span class="n">_Args2</span><span class="p">...</span><span class="o">&gt;</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="stdforward_as_tuple"><span class="mr-2">std::forward_as_tuple</span><a href="#stdforward_as_tuple" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这个东西很简单，就是把一对参数包装为一个<code class="language-plaintext highlighter-rouge">tuple</code>。<strong>该元组在以右值为实参时拥有右值引用数据成员，否则拥有左值引用数据成员。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Types</span> <span class="p">&gt;</span>
<span class="n">tuple</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="o">&gt;</span> <span class="n">forward_as_tuple</span><span class="p">(</span> <span class="n">Types</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>注意</strong>，不可以和<code class="language-plaintext highlighter-rouge">make_tuple</code>混用，下面的是绝对错误的</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">tup</span> <span class="o">=</span> <span class="n">forward_as_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"abc"</span><span class="p">));</span>
<span class="n">string</span> <span class="n">a</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tup</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">tup</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="n">string</span><span class="o">&amp;&amp;&gt;&gt;</span><span class="p">);</span> <span class="c1">// true</span>
</pre></table></code></div></div><p>这个<code class="language-plaintext highlighter-rouge">tuple</code>内的所有对象全是临时对象的引用。</p><h2 id="总结-1"><span class="mr-2">总结</span><a href="#总结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>所以整体来说，就是我们遇到无参或多参构造的时候，也就是需要把构造函数参数传递给<code class="language-plaintext highlighter-rouge">emplace</code>但是受限于语法支持时，我们选择用<code class="language-plaintext highlighter-rouge">forward_as_tuple</code>包装一下。第一个参数是<code class="language-plaintext highlighter-rouge">tag</code>，第二个参数是<code class="language-plaintext highlighter-rouge">key</code>的构造函数参数包装成的<code class="language-plaintext highlighter-rouge">tuple</code>，第三个参数是<code class="language-plaintext highlighter-rouge">value</code>的构造函数参数包装成的<code class="language-plaintext highlighter-rouge">tuple</code>。然后在构造<code class="language-plaintext highlighter-rouge">pair</code>的时候把第一个<code class="language-plaintext highlighter-rouge">tuple</code>的参数解包转发给<code class="language-plaintext highlighter-rouge">key</code>的构造函数，第二个<code class="language-plaintext highlighter-rouge">tuple</code>的参数解包转发给<code class="language-plaintext highlighter-rouge">value</code>的构造函数。这样一来就可以解决多参或无参的问题，来原地构造。 <strong>所有<code class="language-plaintext highlighter-rouge">pair</code>的情况，包括其他容器内存<code class="language-plaintext highlighter-rouge">pair</code>的情况都可以用这个方法进行原地构造</strong></p><h3 id="构造元组的一般性建议"><span class="mr-2">构造元组的一般性建议</span><a href="#构造元组的一般性建议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><p>要创建返回值元组，尽可能使用构造函数。如果某些参数需要是引用类型，请显式使用 <code class="language-plaintext highlighter-rouge">cref/ref</code></p><li><p>仅使用<code class="language-plaintext highlighter-rouge">std::tie</code>将一组变量临时表示为元组：</p></ol><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">inserted</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">});</span>  <span class="c1">// tuple unpacking 更多解释查看cppreference</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">);</span> <span class="c1">// component-wise comparison</span>
</pre></table></code></div></div><ol><li><strong>仅在传递参数时</strong>使用<code class="language-plaintext highlighter-rouge">std::forward_as_tuple</code>。不要将其返回值保存在任何地方。</ol><p>来自<a href="https://pvs-studio.com/en/blog/posts/cpp/1156/">本文的<em>Errors in object lifetime: tuples that shoot at your feet</em>章节</a></p><h1 id="小贴士">小贴士：</h1><h2 id="使用emplace_back的语法"><span class="mr-2">使用emplace_back的语法：</span><a href="#使用emplace_back的语法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="n">temp</span><span class="p">;</span>
<span class="n">temp</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{...,...});</span>
</pre></table></code></div></div><h2 id="在vector中判断特定元素是否存在的方法"><span class="mr-2">在vector中判断特定元素是否存在的方法：</span><a href="#在vector中判断特定元素是否存在的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">find</code><ul><li><code class="language-plaintext highlighter-rouge">find</code>会在查找到指定值后立即返回，所以它一般比<code class="language-plaintext highlighter-rouge">count</code>更快（因为<code class="language-plaintext highlighter-rouge">count</code>总是要遍历整个容器）。</ul><li><code class="language-plaintext highlighter-rouge">find_if</code><ul><li>支持判别式（复杂查找）,返回第一个元素的迭代器</ul><li><code class="language-plaintext highlighter-rouge">count</code><ul><li>查找元素个数</ul><li><code class="language-plaintext highlighter-rouge">any_of</code><ul><li>和<code class="language-plaintext highlighter-rouge">find_if</code>类似，但是返回<code class="language-plaintext highlighter-rouge">bool</code></ul><li><code class="language-plaintext highlighter-rouge">binary_search</code><ul><li>可以先排序再查找。</ul></ul><p>总结</p><ul><li>对于已经排序的vector，使用<code class="language-plaintext highlighter-rouge">binary_search</code><li>仅判断是否存在某元素，使用<code class="language-plaintext highlighter-rouge">find</code><li>需要某元素总个数时，使用<code class="language-plaintext highlighter-rouge">count</code><li>支持复杂条件的查找时，使用<code class="language-plaintext highlighter-rouge">any_of</code>(仅知道是否存在)/<code class="language-plaintext highlighter-rouge">find_if</code>(返回了第一个元素的迭代器)</ul><h2 id="使用哈希表的容器增删改查都是o1使用红黑树的容器增删改查都是onlogn"><span class="mr-2">使用哈希表的容器，增删改查都是O(1)。使用红黑树的容器，增删改查都是O(nlogn)</span><a href="#使用哈希表的容器增删改查都是o1使用红黑树的容器增删改查都是onlogn" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">set</code>, <code class="language-plaintext highlighter-rouge">multimap</code>, <code class="language-plaintext highlighter-rouge">multiset</code> 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为:<ul><li>插入: <code class="language-plaintext highlighter-rouge">O(logN)</code><li>查看:<code class="language-plaintext highlighter-rouge">O(logN) </code><li>删除:<code class="language-plaintext highlighter-rouge">O(logN)</code></ul><li><code class="language-plaintext highlighter-rouge">unordered_map</code>,<code class="language-plaintext highlighter-rouge">unordered_set</code>,<code class="language-plaintext highlighter-rouge">unordered_multimap</code>, <code class="language-plaintext highlighter-rouge">unordered_multiset</code> 上述四种容器采用哈希表实现，不同操作的时间复杂度为：<ul><li>插入:<code class="language-plaintext highlighter-rouge">O(1)</code>，最坏情况<code class="language-plaintext highlighter-rouge">O(N)</code>。<li>查看:<code class="language-plaintext highlighter-rouge">O(1)</code>，最坏情况<code class="language-plaintext highlighter-rouge">O(N)</code>。<li>删除:<code class="language-plaintext highlighter-rouge">O(1)</code>，最坏情况<code class="language-plaintext highlighter-rouge">O(N)</code>。</ul></ul><h2 id="map和unordered-map区别"><span class="mr-2">map和unordered map区别</span><a href="#map和unordered-map区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220824210104.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20220824210104.png" alt="QQ截图20220824210104" class="lazyload" data-proofer-ignore></a></p><p>右下角那句话：要求结果有序（按<code class="language-plaintext highlighter-rouge">key</code>排序）</p><h2 id="关键点"><span class="mr-2">关键点：</span><a href="#关键点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="指针容器的复制是浅拷贝不能正确复制指针指向的内容"><span class="mr-2"><strong>指针容器的复制是浅拷贝。不能正确复制指针指向的内容。</strong></span><a href="#指针容器的复制是浅拷贝不能正确复制指针指向的内容" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">v1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">v1</span><span class="p">;</span>

</pre></table></code></div></div><p><strong>此时不会调用拷贝构造。因为和析构一样，容器调用的拷贝构造或拷贝赋值是帮助你调用。意思就是他会帮助你调用容器内储存的类型的对应的拷贝构造或拷贝赋值。所以说深拷贝浅拷贝完全依赖于你的拷贝构造和拷贝赋值的实现方式。</strong></p><p><strong>这也是为什么指针容器无法深拷贝。因为指针容器储存的是指针，任何类型的指针的类型都是指针。指针类型的拷贝构造和拷贝赋值都是浅拷贝，所以他无法调用到int类型的拷贝构造，只会调用指针类型的拷贝构造。</strong></p><p>因为此时假设</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x100</span><span class="p">;</span>
<span class="o">*</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x999</span><span class="p">;</span>
<span class="c1">//我们复制</span>
<span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
<span class="o">*</span><span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x999</span><span class="p">;</span>
</pre></table></code></div></div><p>vector可以复制每一个元素。就好比<code class="language-plaintext highlighter-rouge">int x = y</code>一样。但是这个元素如果是指针的话，他不会进行深拷贝。</p><p><strong>指针给指针赋值仅仅是将一个指针指向的地址，复制给了另一个指针，导致两个指针指向一个地址。但是并没有生成新的对象。因为对象和对象指针不一样。</strong></p><p>指向对象的指针本质是指针。遵循指针的一般规则。</p><h3 id="指针容器的double-free"><span class="mr-2">指针容器的double-free</span><a href="#指针容器的double-free" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面我们提到了，<strong>指针容器的互相拷贝是浅拷贝。我们也知道了指针容器必须手动释放容器内每一个指针指向的对象</strong>。（第七条）那么有一个问题，我们知道容器是值语义。容器会在传入元素的时候拷贝一份放入容器内。从里面取出的时候又会拷贝一份出来。这导致了一个非常严重的问题，尤其是针对指针容器而言。</p><p>举个例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="n">vec1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">b</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">vec1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></table></code></div></div><p>我们这个指针<code class="language-plaintext highlighter-rouge">b</code>在放入容器的一瞬间，会被拷贝一份。所以此时有两个指针指向了<code class="language-plaintext highlighter-rouge">new</code>的部分。一个在容器外，一个在容器内。所以假设我们释放了<code class="language-plaintext highlighter-rouge">b</code>指向的资源，则此时容器内的这个指针指向的资源也会被释放。如果我们此时害怕没有正确释放，再次释放了容器内指针指向的对象，会有double free错误。因为此时资源已经被释放。</p><p><strong>所以指针容器一定要慎重！既要防止没有释放，也要防止重复释放，因为容器是值语义！</strong></p><ul><li>再次重申，指针容器内的元素（指针）被移除或容器被析构的时候<strong>不会调用指向元素的析构函数</strong>。也就是实际对象不会被销毁。因为容器<strong>只是调用指针自己的析构函数而不是指针指向对象的析构函数。</strong>然而指针类型的析构函数什么也不做。</ul><h1 id="迭代器失效">迭代器失效</h1><p><a href="https://zh.cppreference.com/w/cpp/container#.E8.BF.AD.E4.BB.A3.E5.99.A8.E5.A4.B1.E6.95.88">官方文档参考</a></p><p>我总是把迭代器失效理解成错误的含义。我们简单讲一下真正的含义是什么。</p><p><strong>迭代器失效，不仅仅意味着报错，也意味着你会拿到不是你想要的数据。</strong></p><ul><li>报错一般指的是由于插入元素，导致容器扩容而致使容器迁移导致指向原空间的迭代器失效。<li>拿不到想要的数据一般指的是由于删除元素，导致元素移位致使迭代器不再指向期望的元素。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出10</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//输出10</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//输出10</span>
<span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3333</span><span class="p">);</span> <span class="c1">//插入后扩容，数据转移至新区域，原来区域被释放</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出无效数据，迭代器失效。</span>
</pre></table></code></div></div><p>首先，我们要知道。<code class="language-plaintext highlighter-rouge">begin()</code> 和<code class="language-plaintext highlighter-rouge">end()</code>每次都会动态的返回对应的迭代器，所以这俩不会失效。</p><p>啥时候会失效呢？<strong>当有一个额外的手动赋值的迭代器出现的时候</strong></p><p>这句话是啥意思呢</p><p>比如：</p><p><code class="language-plaintext highlighter-rouge">for(iter = a.begin();;)</code> 这里你声明了一个新的<code class="language-plaintext highlighter-rouge">iter</code>来接收这个调用<code class="language-plaintext highlighter-rouge">begin()</code>返回的迭代器。这就是另一个迭代器</p><p>或者如上图的：<code class="language-plaintext highlighter-rouge">auto it = a.end()</code>。这里也是新的。</p><p><strong>所以为什么在for循环里对迭代器操作的时候会失效。因为你操作的迭代器不是动态获取的，而是你已经获取到之后对迭代器进行加减操作的。</strong></p><p>另外一个简单例子</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//这时候a是{0,1,2,3,4,5,6,7,8,9}</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出9</span>
<span class="n">a</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3333</span><span class="p">);</span>
<span class="c1">//这时候a是{0,1,2,3333,3,4,5,6,7,8,9}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出8。</span>
</pre></table></code></div></div><p>因为迭代器已经被赋值。对迭代器的加减操作我们可以理解为原始数组对指针的加减操作。所以原来的时候，最后一位指向的内存地址存的是9，我们可以理解为<code class="language-plaintext highlighter-rouge">end-1</code>是<code class="language-plaintext highlighter-rouge">begin+9</code>。我们执行<code class="language-plaintext highlighter-rouge">insert</code>之后，由于迭代器没有重新赋值，所以<code class="language-plaintext highlighter-rouge">begin+9</code>指向的内存地址不变。但是<code class="language-plaintext highlighter-rouge">insert</code>会让插入位置后的元素后移，8会被移到原来9的内存地址上。这样就是迭代器失效。</p><p><strong>下面我们看看下标访问的情况</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">myvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">myvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//注意在erase后面</span>
    <span class="p">}</span>
    <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//这里是能看到最后一个6的。</span>
<span class="c1">//输出0 1 2 4 5 6</span>

<span class="p">}</span>
</pre></table></code></div></div><p>这里看上去好像皆大欢喜，但是我们要摸清楚一下原理</p><p>这里是先把3删掉。erase是覆盖式赋值，把后面元素从删除的元素开始赋值。所以这时候变成了<code class="language-plaintext highlighter-rouge">0 1 2 4 5 6 6</code>（虽然最后一个6不可见，但依旧可强制访问）。</p><p>所以这时候index依旧为3，但是此时index = 3的值变成了4，又因为<code class="language-plaintext highlighter-rouge">erase</code>会改变<code class="language-plaintext highlighter-rouge">size</code>（也就是改变end迭代器的位置）所以会正常输入<code class="language-plaintext highlighter-rouge">0 1 2 4 5 6</code></p><p><strong>但是一旦我们把打印放在erase前面，那就出问题了</strong>。会输出<code class="language-plaintext highlighter-rouge">0 1 2 3 5 6</code></p><p>为什么呢？显而易见，打印3的原因是3此时还没有删除，但是4怎么没了呢？</p><p>因为我们删掉3之后，是 <code class="language-plaintext highlighter-rouge">0 1 2 4 5 6</code>。但是这时候下标已经从3移动到了4。所以打印下标为4的元素自然是5。</p><h2 id="再次强调序列式容器的erase是覆盖式删除"><span class="mr-2">再次强调序列式容器的erase是覆盖式删除</span><a href="#再次强调序列式容器的erase是覆盖式删除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">erase</code>是覆盖式删除，也就是把要删除数据位置后面的数据依次拷贝至要删除的数据位置和后面的位置上，并且调用脏数据的析构，但是调用析构函数不代表数据会被真正意义上的删除或内存释放。比如指针容器。指针容器只会调用指针类型自己的析构而不会调用指针指向对象的析构。内存释放依靠的是<code class="language-plaintext highlighter-rouge">delete</code>。</p><p><code class="language-plaintext highlighter-rouge">erase</code>调整的是<code class="language-plaintext highlighter-rouge">size</code>，就是调整<code class="language-plaintext highlighter-rouge">end</code>迭代器位置。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myclass</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="o">~</span><span class="n">myclass</span><span class="p">(){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">8964</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">myvec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出4 5 6</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">()).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 	<span class="c1">//输出8964</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">)).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//输出8964</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="p">)).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//输出8964</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">3</span><span class="p">)).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>	<span class="c1">//输出8964</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">()</span><span class="o">+</span><span class="mi">4</span><span class="p">)).</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//已经越界。所以是非法数据。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p>我们分析一下过程</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>0 1 2 3 4 5 6 覆盖式删除
1 2 3 4 5 6 6 删除后，调用最末尾元素的析构。注意我们的析构，只是进行一个值的覆盖。因为是栈对象，又没有delete所以依旧能访问到元素
1 2 3 4 5 6 8964 调用析构后。

</pre></table></code></div></div><p>以上这一部分是调用了一次erase的情况。如果我们扩展下就是</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1 2 3 4 5 6 8964
2 3 4 5 6 8964 8964
3 4 5 6 8964 8964 8964
4 5 6 8964 8964 8964 8964
		↑end 在这
</pre></table></code></div></div><p>这个期望很符合我们上面代码的注释部分。</p><h2 id="看一下vector在erase的情况下的迭代器失效到底是什么意思"><span class="mr-2">看一下vector在erase的情况下的迭代器失效到底是什么意思</span><a href="#看一下vector在erase的情况下的迭代器失效到底是什么意思" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>先看代码，这是for循环删除的代码。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myclass</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){};</span>
    <span class="o">~</span><span class="n">myclass</span><span class="p">(){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="mi">8964</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">myclass</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span> <span class="p">};</span>
    <span class="c1">//for(auto iter = myvec.begin(); iter != myvec.end(); iter++){ //注意这一行</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">iter</span><span class="o">++</span><span class="p">){</span>
        <span class="n">myvec</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">:</span><span class="n">myvec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出 1 3 5</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

</pre></table></code></div></div><p><strong>注意！随机访问迭代器支持&gt;和&lt;比较！！</strong></p><p>过程：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>0 1 2 3 4 5 6 开始
↑iter
1 2 3 4 5 6 8964 删除后
↑iter

1 2 3 4 5 6 8964 第二次for循环，iter++
  ↑iter
1 3 4 5 6 8964 8964 删除后
  ↑iter

1 3 4 5 6 8964 8964  第三次for循环，iter++
	↑iter
1 3 5 6 8964 8964 8964 删除后

1 3 5 6 8964 8964  第三次for循环，iter++
	  ↑iter
1 3 5 8964 8964 8964 8964 删除后
		↑end 
</pre></table></code></div></div><p>我们已经通过上面的删除样例了解了，删除后数据会被覆盖过来，然后再进行<code class="language-plaintext highlighter-rouge">iter++</code>就会跨越一个数据。就会出现迭代器失效。</p><p>假如我们用的不是大小比较，用的是<code class="language-plaintext highlighter-rouge">end</code>比较，那么会出现大问题。for循环一直到天荒地老合法内存的尽头。</p><p>因为我们在最后一次删除的时候，由于是先删除的，所以<code class="language-plaintext highlighter-rouge">end</code>会往前缩一格，会缩到第四位也就是当前iter的位置。然后<code class="language-plaintext highlighter-rouge">iter++</code>移动到第五位。这时候进入<code class="language-plaintext highlighter-rouge">for</code>循环判断<code class="language-plaintext highlighter-rouge">++</code>后的<code class="language-plaintext highlighter-rouge">iter</code>，这时候发现<code class="language-plaintext highlighter-rouge"> iter</code>在第五位，<code class="language-plaintext highlighter-rouge">end</code>在第四位，当然不相等。于是就会一直走下去。</p><h2 id="各种容器迭代器失效场景"><span class="mr-2">各种容器迭代器失效场景</span><a href="#各种容器迭代器失效场景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="vector"><span class="mr-2">vector</span><a href="#vector" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>重新分配内存时（超出capacity大小时），<strong>所有</strong>都失效。<li>在当前指向元素之前进行<strong>插入</strong>操作，当前迭代器<strong>以后的</strong>迭代器都会失效。<li>在<strong>删除</strong>元素时，指向被删除元素<strong>以后的</strong>迭代器都失效</ul><h3 id="deque"><span class="mr-2">deque</span><a href="#deque" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>插入</strong>元素使deque的<strong>所有</strong>迭代器失效。（因为可能中控器个数不够，需要开辟更大空间容纳中控器）<li>在deque的<strong>中间删除</strong>元素将使<strong>所有</strong>迭代器失效。（涉及到缩减缓冲区数量）<li>在deque的<strong>头或尾删除</strong>元素时，<strong>只有指向该元素的</strong>迭代器失效。</ul><h3 id="queue-stack-priority_queue-这三个容器适配器没有迭代器"><span class="mr-2">queue, stack, priority_queue 这三个容器适配器没有迭代器</span><a href="#queue-stack-priority_queue-这三个容器适配器没有迭代器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h3 id="list-map-setunordered_map-unordered_set"><span class="mr-2">list, map, set，unordered_map, unordered_set</span><a href="#list-map-setunordered_map-unordered_set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>增加</strong>任何元素都<strong>不会</strong>使迭代器失效。<li><strong>删除</strong>元素时，除了指向<strong>当前被删除元素的迭代器失效</strong>外，其它迭代器都不会失效。<li><strong>格外注意在关联式容器中当进行<code class="language-plaintext highlighter-rouge">my_set.erase(iter)</code>后，<code class="language-plaintext highlighter-rouge">iter</code>已经失效。任何针对<code class="language-plaintext highlighter-rouge">iter</code>的操作如自增或自减操作都是失效的。所以要么使用<code class="language-plaintext highlighter-rouge">erase</code>函数返回的新迭代器，要么使用<code class="language-plaintext highlighter-rouge">my_set.erase(iter++)</code></strong>具体解析在下面。<li>针对哈希容器如unordered系列：<ul><li>若插入<strong>引起rehash，则所有迭代器失效</strong>。若不rehash，依然有效。</ul></ul><h2 id="迭代器失效的自增操作"><span class="mr-2">迭代器失效的自增操作</span><a href="#迭代器失效的自增操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">student</span> <span class="nf">target</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"luka"</span><span class="p">);</span> 
<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> 
<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> 
    <span class="n">student</span> <span class="n">temp</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">);</span> 
    <span class="n">temp</span><span class="p">.</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changed_luka"</span><span class="p">);</span> 
    <span class="n">my_set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="o">++</span><span class="p">);</span> <span class="c1">//注意这里</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span> 
<span class="p">}</span>
</pre></table></code></div></div><p><strong>格外注意在关联式容器中当进行<code class="language-plaintext highlighter-rouge">my_set.erase(iter)</code>后，<code class="language-plaintext highlighter-rouge">iter</code>已经失效。任何针对<code class="language-plaintext highlighter-rouge">iter</code>的操作如自增或自减操作都是失效的。</strong>所以我们要么使用<code class="language-plaintext highlighter-rouge">erase</code>函数传回的新迭代器，要么使用<code class="language-plaintext highlighter-rouge">my_set.erase(iter++)</code></p><p>注意这里发生了几个步骤。首先，<code class="language-plaintext highlighter-rouge">t++</code>会被先运算。然后我们知道<code class="language-plaintext highlighter-rouge">t++</code>是先赋值后自增。所以此时传入<code class="language-plaintext highlighter-rouge">erase</code>的迭代器指向的是我们要删除的那一个。也就是<code class="language-plaintext highlighter-rouge">t</code>。但是<code class="language-plaintext highlighter-rouge">erase</code>会在<code class="language-plaintext highlighter-rouge">t</code>完成自增后再进行删除操作。也就是:</p><ul><li>先把<code class="language-plaintext highlighter-rouge">t</code>传入<code class="language-plaintext highlighter-rouge">erase</code><li>执行<code class="language-plaintext highlighter-rouge">t++</code><li>因为上面两步合起来才是<code class="language-plaintext highlighter-rouge">t++</code>的运算（参考杂记2）。所以在这之后才开始进行删除操作，处理传入的迭代器。也就是<code class="language-plaintext highlighter-rouge">erase</code>原来的<code class="language-plaintext highlighter-rouge">t</code></ul><p>操作等同于</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">student</span> <span class="nf">target</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"luka"</span><span class="p">);</span> 
<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> 
<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> 
    <span class="n">student</span> <span class="n">temp</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">);</span> 
    <span class="n">temp</span><span class="p">.</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changed_luka"</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="c1">//拿到一个新的迭代器</span>
    <span class="n">t2</span><span class="o">++</span><span class="p">;</span> <span class="c1">//新的迭代器自增，注意不可t++或者++t。这都是对t操作，我们要对t2操作</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//删掉t指向的内容</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t2</span><span class="p">;</span> <span class="c1">//把t2赋值回t。</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>https://stackoverflow.com/questions/41959511/erase-set-iterator-value-and-increment-iterator</p><ul><li>或者使用<code class="language-plaintext highlighter-rouge">erase</code>返回的新迭代器</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">student</span> <span class="nf">target</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"luka"</span><span class="p">);</span> 
<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">target</span><span class="p">);</span> 
<span class="k">if</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span> 
    <span class="n">student</span> <span class="n">temp</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">);</span> 
    <span class="n">temp</span><span class="p">.</span><span class="n">change_name</span><span class="p">(</span><span class="s">"changed_luka"</span><span class="p">);</span> 
    <span class="n">t</span> <span class="o">=</span> <span class="n">my_set</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="c1">//注意这里</span>
    <span class="n">my_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span> 
<span class="p">}</span>
</pre></table></code></div></div><h1 id="mapunordered_map不允许更改key">map/unordered_map不允许更改key</h1><ul><li>原因是我们依靠的是key来进行排序。<ul><li>而且我们会把key和data合成成为一个value。形式是<code class="language-plaintext highlighter-rouge">pair&lt;const key_type, data_type&gt;</code>。然后把这个传入红黑树/哈希表。指定他从中抽取出来pair的第一个值也就是key来排序。</ul><li>所以换句话说就是红黑树/哈希表存的是map的key和value合成的pair。然后通过key排序。这也是为什么map的迭代器返回的是pair。因为我们就是按照pair存进去的。也是为什么用<code class="language-plaintext highlighter-rouge">insert</code>存入的时候需要<code class="language-plaintext highlighter-rouge">make_pair</code>。<li>map不允许更改key是因为保存至红黑树的<code class="language-plaintext highlighter-rouge">pair</code>里面的<code class="language-plaintext highlighter-rouge">key</code>是<code class="language-plaintext highlighter-rouge">const</code>的。<ul><li>也就是如果有<code class="language-plaintext highlighter-rouge">map&lt;k,v&gt;</code> 或 <code class="language-plaintext highlighter-rouge">multimap&lt;k,v&gt;</code> 类型的对象，其中的元素类型会是<code class="language-plaintext highlighter-rouge">pair&lt;const k, v&gt;</code></ul></ul><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230111183843.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230111183843.png" alt="QQ截图20230111183843" class="lazyload" data-proofer-ignore></a></p><h2 id="map的特殊的重载的operator"><span class="mr-2">map的特殊的重载的operator[]</span><a href="#map的特殊的重载的operator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>如果这个括号里面的元素不存在，他会帮你创建一个以括号内元素为key，等号后面为value的键值对。</p><p>所以会有陷阱 比如：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">my_map</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">7</span><span class="p">){</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面这行表面是判断<code class="language-plaintext highlighter-rouge">key</code> 4的值是否为7， 但是这行执行的时候，如果<code class="language-plaintext highlighter-rouge">key</code>4不存在，他会创建一个<code class="language-plaintext highlighter-rouge">4,0</code>的键值对。</p><p>因为它访问了<code class="language-plaintext highlighter-rouge">my_map[4]</code>，此时发现该元素不存在，就使用该类型的<strong>默认构造函数</strong>构造出一个value插入进去。这里我们用的是<code class="language-plaintext highlighter-rouge">int</code>，<code class="language-plaintext highlighter-rouge">int</code>的默认是0，所以会有一个<code class="language-plaintext highlighter-rouge">4,0</code></p><blockquote><p><strong>若键不存在：</strong></p><p><strong>则默认构造的对象的key_type（也就是key）必须满足可复制/移动构造。</strong></p><p><strong>mapped_type（也就是value）必须满足可默认构造</strong></p><p>来自<a href="https://zh.cppreference.com/w/cpp/container/map/operator_at">这里</a></p></blockquote><ul><li>对于自定义的对象，例子：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">//注意这里</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">comp1</span><span class="p">{</span> <span class="c1">//自定义排序</span>
    <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span> <span class="c1">//注意map的自定义排序是key而不是整个pair。所以自定义排序的函数签名是key</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">myobj</span><span class="p">,</span> <span class="n">comp1</span><span class="o">&gt;</span> <span class="n">we</span><span class="p">;</span>  
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">we</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">val</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="p">){</span> <span class="c1">//key为2的元素的val是否等于a的val</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"true1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">t</span><span class="o">:</span><span class="n">we</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出2 12</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">we</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>由于判断<code class="language-plaintext highlighter-rouge">key</code>为<code class="language-plaintext highlighter-rouge">2</code>的元素的<code class="language-plaintext highlighter-rouge">val</code>是否等于<code class="language-plaintext highlighter-rouge">a</code>的<code class="language-plaintext highlighter-rouge">val</code>的时候会先访问<code class="language-plaintext highlighter-rouge">key</code>为<code class="language-plaintext highlighter-rouge">2</code>的元素，这时候发现元素不存在。所以会使用默认（无参）构造函数或默认值构造对应的键值对。所以会出现一个 <code class="language-plaintext highlighter-rouge">2,12</code>的元素。</p><p>所以为了避免陷阱，我们应该：</p><ul><li>向map容器插入元素时直接使用insert函数<li>遍历map容器时使用iterator迭代器<li>修改或者删除元素时使用find函数找到元素后再进行操作</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unordered_map</span> <span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">;</span>
    <span class="n">unordered_map</span> <span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">map2</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">,</span><span class="s">"a"</span><span class="p">,</span><span class="s">"abc"</span><span class="p">,</span><span class="s">"abcd"</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="n">string</span> <span class="n">a</span> <span class="o">:</span> <span class="n">str</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">map</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">map</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//map[a]是你key对应的value。 a才是你的key。所以这里的意思是 你map[a]的这个val+1。也就是key为a的地方把他的value在原来的基础上加1</span>
        <span class="c1">//如果map[a]有这个key 比如map里面有a 那么这个val+1。简单来说就是key为a对应的value = key为a对应的value + 1</span>
        <span class="c1">//如果map[a] 没有这个key。那就加这个key 比如里面没有abc 那就把abc加进去</span>
        <span class="c1">//map[num];对于这个下标操作，如果存在num关键字，则返回对应的值；如果不存在num关键字，则创建一个键值对，键为num，值为值类型的默认初始化值。</span>
       <span class="err">那么这句话的意思是。如果有</span><span class="n">a</span><span class="err">这个</span><span class="n">key</span><span class="err">，那么把这个</span><span class="n">key</span><span class="err">对应的</span><span class="n">value</span><span class="o">+</span><span class="mi">1</span>
       <span class="err">如果没有，那就先新建</span><span class="n">a</span><span class="err">这个</span><span class="n">key</span><span class="err">，</span><span class="n">value</span><span class="err">设为</span><span class="mi">0</span><span class="o">+</span><span class="mf">1.</span>
       <span class="err">所以</span><span class="n">map</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">"ffff"</span> <span class="err">这一句，如果有</span><span class="mi">4</span><span class="err">这个</span><span class="n">key</span><span class="err">，那就把这个</span><span class="n">key</span><span class="err">对应的</span><span class="n">value</span><span class="err">改为</span><span class="s">"ffff"</span>
       <span class="err">如果没有，就新建</span><span class="mi">4</span><span class="err">，</span> <span class="s">"ffff"</span><span class="err">这个键值对放入</span><span class="n">map</span>
        <span class="c1">//等号右侧的map[a]先执行。先在map里面找有没有元素为a的。如果没有就创建一个key=a value=0的元素。然后返回value= 0。之后value+1赋值给key为a的元素的value上面</span>
        <span class="c1">//先重载=返回自己。然后重载[]返回second也就是value。因为东西是按照pair存的。</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">x</span><span class="o">!=</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">x</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ss</span> <span class="o">=</span> <span class="o">*</span><span class="n">map</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="c1">//map里面的每一个元素可以看为一个pair。注意这里迭代器需要解引用。</span>
    <span class="err">因为</span><span class="n">map</span><span class="err">的底层是把</span><span class="n">key</span><span class="err">和</span><span class="n">value</span><span class="err">合成起来成为真正的</span><span class="n">value</span><span class="err">。是用一个</span><span class="n">pair</span><span class="err">包起来的。</span>
    <span class="err">用</span><span class="n">pair</span><span class="err">包起来之后，把</span><span class="n">key</span><span class="err">和这个包起来的</span><span class="n">pair</span><span class="err">放到红黑树里面。</span>
    <span class="err">其实这个</span><span class="n">value</span><span class="err">应该叫</span><span class="n">data</span><span class="err">。没所谓了。</span>
    <span class="err">所以</span><span class="n">map</span><span class="err">的每一个元素存起来应该长这个样子</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">string</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="err">。</span>
    <span class="err">所以迭代器的</span><span class="n">first</span><span class="err">其实是下面</span><span class="n">value</span><span class="err">存的</span><span class="n">pair</span><span class="err">的</span><span class="n">first</span>
    <span class="err">迭代器的</span><span class="n">second</span><span class="err">是下面的</span><span class="n">value</span><span class="err">存的</span><span class="n">pair</span><span class="err">的</span><span class="n">second</span>


    <span class="err">所以说才会有</span><span class="n">select1st</span><span class="err">从</span><span class="n">value</span><span class="err">里面取</span><span class="n">key</span><span class="err">。所以你自己要</span><span class="n">insert</span><span class="err">元素的时候需要传一个</span><span class="n">pair</span><span class="err">进去。他会把</span><span class="n">key</span><span class="err">从</span><span class="n">pair</span><span class="err">里面提出来变成</span><span class="n">key</span>

<span class="p">}</span>
</pre></table></code></div></div><h3 id="为什么要这么设计"><span class="mr-2">为什么要这么设计</span><a href="#为什么要这么设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>这么设计的原因，我的个人思考是，我们使用<code class="language-plaintext highlighter-rouge">x[5]</code>的时候，其实就是<code class="language-plaintext highlighter-rouge">x.operator[](5)</code>，但是我们既有可能要给这个地方赋值，如<code class="language-plaintext highlighter-rouge">x[5] = 1</code>，又有可能是获取一个这个地方的值，如<code class="language-plaintext highlighter-rouge">int a = x[5]</code>。但是这个函数本身无法做出这样的判断。同时STL容器是值语义 。所以它必须当做所有<code class="language-plaintext highlighter-rouge">operator[]</code>的调用都是写入。所以在用下标运算符访问不存在的元素的时候，会默认构造出这个元素，然后返回这个元素的引用。 – 同时参考more effective c++ 条款29 P.190</ul><p>所以我们查看文档</p><blockquote><div class="table-wrapper"><table><thead><tr><th><code class="language-plaintext highlighter-rouge">T&amp; operator[]( const Key&amp; key );</code><th>(1)<th> <tbody><tr><td><code class="language-plaintext highlighter-rouge">T&amp; operator[]( Key&amp;&amp; key );</code><td>(2)<td>(C++11 起)</table></div></blockquote><p>我们发现没有一个<code class="language-plaintext highlighter-rouge">const</code>成员函数</p><p>所以下面这样是不可以的：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">op1</span><span class="p">;</span>
<span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="c1">//不可以。</span>
<span class="n">op</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//可以</span>
</pre></table></code></div></div><p>因为<code class="language-plaintext highlighter-rouge">operator[]</code>总会有潜在的对象修改语义。所以针对<code class="language-plaintext highlighter-rouge">const map</code>而言，访问元素的唯一方法便是使用<code class="language-plaintext highlighter-rouge">at()</code></p><h1 id="set不允许更改值">set不允许更改值</h1><ul><li><p>因为set的<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">data</code>是同一个东西，也就是<code class="language-plaintext highlighter-rouge">value</code>。</p><ul><li>我们是依靠这个值进行红黑树排序</ul><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230111183159.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/QQ%E6%88%AA%E5%9B%BE20230111183159.png" alt="QQ截图20230111183159" class="lazyload" data-proofer-ignore></a></p><li>但是set不允许更改值是因为迭代器返回的是常量迭代器也就是<code class="language-plaintext highlighter-rouge">const iterator</code><li>map不允许更改key是因为保存至红黑树的pair里面的key是const的。</ul><h1 id="set不会重复插入且不允许重复元素的原因">set不会重复插入且不允许重复元素的原因</h1><p>set使用的红黑树的<code class="language-plaintext highlighter-rouge">insert_unique</code></p><p>multi_set使用的红黑树的<code class="language-plaintext highlighter-rouge">insert_equal</code></p><h1 id="map不会重复插入且不允许重复key的原因">map不会重复插入且不允许重复key的原因</h1><p><code class="language-plaintext highlighter-rouge">map</code>使用的红黑树的<code class="language-plaintext highlighter-rouge">insert_unique</code></p><p><code class="language-plaintext highlighter-rouge">multi_map</code>使用的红黑树的<code class="language-plaintext highlighter-rouge">insert_equal</code></p><h1 id="set容器-和-map容器在插入时会自动排序所以在使用自定义数据类型的时候就必须要直接指定排序规则仿函数来进行自定义排序">set容器 和 map容器在插入时会自动排序。所以在使用自定义数据类型的时候就必须要直接指定排序规则仿函数来进行自定义排序。</h1><h2 id="set-不多赘述"><span class="mr-2">set 不多赘述</span><a href="#set-不多赘述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>自定义排序比较常见</p><h2 id="map的自定义排序排序的是key而不是pair所以自定义排序的函数签名是key"><span class="mr-2">map的自定义排序排序的是<code class="language-plaintext highlighter-rouge">key</code>而不是<code class="language-plaintext highlighter-rouge">pair</code>。所以自定义排序的函数签名是key</span><a href="#map的自定义排序排序的是key而不是pair所以自定义排序的函数签名是key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">//注意这里</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">comp1</span><span class="p">{</span> <span class="c1">//自定义排序</span>
    <span class="nl">public:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span> <span class="c1">//注意map的自定义排序是key而不是整个pair。所以自定义排序的函数签名是key</span>
        <span class="k">return</span> <span class="n">lhs</span> <span class="o">&gt;</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myobj</span><span class="p">,</span> <span class="n">comp1</span><span class="o">&gt;</span> <span class="n">we</span><span class="p">;</span>  
    <span class="n">myobj</span> <span class="n">a</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">myobj</span> <span class="n">b</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">we</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">val</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="p">){</span> <span class="c1">//key为2的元素的val是否等于a的val</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"true1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">t</span><span class="o">:</span><span class="n">we</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//输出2 12</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">we</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="unordered_mapunordered_set-哈希表没有自定义排序只有自定义哈希和自定义等比想使用自定义的键类型必须实现hash函数和等比函数"><span class="mr-2">unordered_map/unordered_set 哈希表没有自定义排序。只有自定义哈希和自定义等比。想使用自定义的键类型，必须实现hash函数和等比函数。</span><a href="#unordered_mapunordered_set-哈希表没有自定义排序只有自定义哈希和自定义等比想使用自定义的键类型必须实现hash函数和等比函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>自定义哈希的意义不多说。<li>自定义等比的意义是在两个对象哈希值相同的时候，需要告诉容器一个办法让其判断这两个对象是真的一模一样，还是只是哈希出来的值是一样但本身是不同的，</ul><h1 id="c的map是基于红黑树实现的它不需要对key进行哈希所以可以用vector做为key但是unordered-map是基于哈希表实现的它需要对key进行哈希但是c-默认不对vector提供哈希所以要么自己写一个哈希函数对vector进行哈希或不要在unordered-map中使用vector做为key">c++的map是基于红黑树实现的，它不需要对key进行哈希，所以可以用vector做为key。但是unordered map是基于哈希表实现的，它需要对key进行哈希，但是c++ 默认不对vector提供哈希，所以要么自己写一个哈希函数对vector进行哈希，或不要在unordered map中使用vector做为key。</h1><h1 id="注意随机访问迭代器支持和比较">注意！随机访问迭代器支持&gt;和&lt;比较！！</h1><p><a href="/assets/blog_res/2022-07-20-EFFSTL.assets/5740965-0d91567d9f259cce.png" class="popup img-link "><img data-src="/assets/blog_res/2022-07-20-EFFSTL.assets/5740965-0d91567d9f259cce.png" alt="5740965-0d91567d9f259cce" class="lazyload" data-proofer-ignore></a></p><h1 id="对容器使用下标访问运算符访问或者是对其迭代器解引用返回的是元素的引用frontback成员函数也是">对容器使用下标访问运算符访问或者是对其迭代器解引用返回的是元素的引用。front，back成员函数也是。</h1><p>正因为是引用，我们才可以有如下操作，比如：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">my_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="o">*</span><span class="n">my_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><h1 id="正因为上面那条针对容器的常量引用或如果容器本身是常量提取出来的元素也是常量性质的">正因为上面那条，针对容器的常量引用或如果容器本身是常量，提取出来的元素也是常量性质的。</h1><ul><li>因为常量引用不能绑定到非常量引用。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//错误</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">vala</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//正确</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">functest</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">){</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//错误</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">vala</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//正确</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="为什么没有引用容器除非使用stdreference_wrapper">为什么没有引用容器，除非使用std::reference_wrapper</h1><p>1：容器内的元素必须是可赋值的。引用是不可赋值的（引用只能在声明的同时初始化）</p><p>2：没有指向引用的指针。容器有迭代器，迭代器是指针。元素如果是引用，迭代器无法工作，</p><p>除非使用<code class="language-plaintext highlighter-rouge">std::reference_wrapper</code></p><h1 id="for_each">for_each</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="c1">//这里函数对象对应的函数的形参应该是迭代器指向的容器对象的对应类型。</span>
<span class="c1">//比如vector&lt;int&gt;的话这里就要int, vector&lt;pair&lt;int,int&gt;&gt;的话就要pair&lt;int, int&gt;</span>
<span class="kt">void</span> <span class="nf">printvector01</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//注意这里pair&lt;int a, int b&gt;是错的！！！</span>
<span class="c1">//pair&lt;&gt;括号里头的是数据类型，外面的才是名字！你不能vector&lt;int a&gt;吧</span>
<span class="kt">void</span> <span class="nf">printvector02</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">){</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" , "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">printvector03</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*
template &lt;class _InIt, class _Fn&gt;
_CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        _Func(*_UFirst); //这里已经对迭代器对象解引用了，所以直接传入的是迭代器对应的值。
        // 注意这里调用函数的方式是直接把参数塞进去。所以传递函数对象就行 不用() 加了括号叫调用
    }

    return _Func; //看好了！！有返回值！！
}
*/</span>




</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">test</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">printvector01</span><span class="p">);</span> <span class="c1">//注意这里传递的是函数对象，不是函数。因为printvector01是个函数不是类，所以printvector01()加了括号的叫调用！！</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">test</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">printvector03</span><span class="p">());</span> <span class="c1">//注意这里传递的是函数对象，不是类型名。因为printvector03是个类(仿函数)不是函数。所以printvector01()加了括号的是类的匿名对象，这里因为是仿函数所以叫函数对象，而不是调用！！</span>
    <span class="c1">//注意区分类和普通函数的对象。普通函数不加括号叫对象，加了括号叫调用。仿函数（类）要加括号。加了括号叫类的匿名对象，不加括号叫类型名。</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">test2</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">test2</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">test2</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">printvector02</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong><code class="language-plaintext highlighter-rouge">for_each</code>是可以有返回值的。也就是可以施加一个有状态的函数对象。</strong><ul><li>比如下面的代码目的是获取所有性别为1的人的id，并放入容器。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Person</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sex</span><span class="p">;</span>
        <span class="n">Person</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sex</span><span class="p">(</span><span class="n">y</span><span class="p">){};</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="nc">myfind</span><span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">persons</span><span class="p">;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">){</span> <span class="c1">//这里不需要bool了。void即可。</span>
        <span class="k">if</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">sex</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
            <span class="n">persons</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="n">sex</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">my_vec</span><span class="p">{</span><span class="n">Person</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">Person</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">Person</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">Person</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">Person</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)};</span>
    <span class="n">myfind</span> <span class="n">t</span> <span class="o">=</span> <span class="n">for_each</span><span class="p">(</span><span class="n">my_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">my_vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">myfind</span><span class="p">());</span>
    
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="n">i</span><span class="o">:</span><span class="n">t</span><span class="p">.</span><span class="n">persons</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="迭代器种类">迭代器种类</h1><p>迭代器分为五种：</p><ul><li>输入迭代器（Input Iterator）：通过对输入迭代器解除引用，它将引用对象，而对象可能位于集合中。最严格的输入迭代只能以只读方式访问对象。例如：istream。<li>输出迭代器（Output Iterator）：该类迭代器和Input Iterator极其相似，也只能单步向前迭代元素，不同的是该类迭代器对元素只有写的权力。例如：ostream, inserter。<li>前向迭代器（Forward Iterator）：该类迭代器可以在一个正确的区间中进行读写操作，它拥有Input Iterator的所有特性，和Output Iterator的部分特性，以及单步向前迭代元素的能力。<ul><li>假设 p 是一个前向迭代器，则 p 支持 ：<ul><li><code class="language-plaintext highlighter-rouge">++p</code><li><code class="language-plaintext highlighter-rouge">p++</code><li><code class="language-plaintext highlighter-rouge">*p</code><li>复制<li>赋值<li>可以用<code class="language-plaintext highlighter-rouge"> ==</code> 和 <code class="language-plaintext highlighter-rouge">!= </code>运算符进行比较。<li>此外，两个正向迭代器可以互相赋值。</ul></ul><li>双向迭代器（Bidirectional Iterator）：该类迭代器是在Forward Iterator的基础上提供了单步向后迭代元素的能力。例如：list, set, multiset, map, multimap。<ul><li>假设 p 是一个双向迭代器，则 p 支持 ：<ul><li>正向迭代器的全部功能 和<li><code class="language-plaintext highlighter-rouge">--p</code><li><code class="language-plaintext highlighter-rouge">p--</code> （即一次向后移动一个位置）。</ul></ul><li>随机迭代器（Random Access Iterator）：该类迭代器能完成上面所有迭代器的工作，它自己独有的特性就是可以像指针那样进行算术计算，而不是仅仅只有单步向前或向后迭代。例如：vector, deque, string, array。<ul><li>假设 p 是一个随机迭代器，则 p 支持 ：<ul><li>双向迭代器的全部功能 和<li><code class="language-plaintext highlighter-rouge">p+=i</code>：使得 p 往后移动 <code class="language-plaintext highlighter-rouge">i </code>个元素。<li><code class="language-plaintext highlighter-rouge">p-=i</code>：使得 p 往前移动<code class="language-plaintext highlighter-rouge"> i </code>个元素。<li><code class="language-plaintext highlighter-rouge">p+i</code>：返回 p 后面第<code class="language-plaintext highlighter-rouge"> i </code>个元素的迭代器。<li><code class="language-plaintext highlighter-rouge">p-i</code>：返回 p 前面第<code class="language-plaintext highlighter-rouge"> i </code>个元素的迭代器。<li><code class="language-plaintext highlighter-rouge">p[i]</code>：返回 p 后面第 <code class="language-plaintext highlighter-rouge">i</code> 个元素的引用。<li>此外，两个随机访问迭代器<code class="language-plaintext highlighter-rouge"> p1</code>、<code class="language-plaintext highlighter-rouge">p2 </code>还可以用 <code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;=</code>、<code class="language-plaintext highlighter-rouge">&gt;= </code>运算符进行比较。<li>另外，表达式 <code class="language-plaintext highlighter-rouge">p2-p1</code> 也是有定义的，其返回值表示<code class="language-plaintext highlighter-rouge"> p2</code> 所指向元素和 <code class="language-plaintext highlighter-rouge">p1</code> 所指向元素的序号之差（也可以说是<code class="language-plaintext highlighter-rouge"> p2 </code>和<code class="language-plaintext highlighter-rouge"> p1 </code>之间的元素个数减一）。</ul></ul></ul><div class="table-wrapper"><table><thead><tr><th style="text-align: left">容器类型<th>迭代器类型<tbody><tr><td style="text-align: left">array<td>随机访问迭代器<tr><td style="text-align: left">vector<td>随机访问迭代器<tr><td style="text-align: left">deque<td>随机访问迭代器<tr><td style="text-align: left">list<td>双向迭代器<tr><td style="text-align: left">set / multiset<td>双向迭代器<tr><td style="text-align: left">map / multimap<td>双向迭代器<tr><td style="text-align: left">forward_list<td>前向迭代器<tr><td style="text-align: left">unordered_map / unordered_multimap<td>前向迭代器<tr><td style="text-align: left">unordered_set / unordered_multiset<td>前向迭代器<tr><td style="text-align: left">stack<td>不支持迭代器<tr><td style="text-align: left">queue<td>不支持迭代器</table></div><div class="table-wrapper"><table><thead><tr><th>迭代器定义方式<th>具体格式<tbody><tr><td>正向迭代器<td>容器类名::iterator 迭代器名;<tr><td>常量正向迭代器<td>容器类名::const_iterator 迭代器名;<tr><td>反向迭代器<td>容器类名::reverse_iterator 迭代器名;<tr><td>常量反向迭代器<td>容器类名::const_reverse_iterator 迭代器名;</table></div><ul><li>所以我们说，除了vector，deque，string和array以外，其他的容器都不支持如<code class="language-plaintext highlighter-rouge">begin()+n</code>的操作。</ul><h1 id="为什么迭代器的类型不是简单的t而一般都带了很长的包装器">为什么迭代器的类型不是简单的T*，而一般都带了很长的包装器</h1><p>https://quuxplusone.github.io/blog/2022/03/03/why-isnt-vector-iterator-just-t-star/</p><h1 id="不同容器不同操作的平均时间复杂度">不同容器不同操作的<em>平均</em>时间复杂度</h1><div class="table-wrapper"><table><thead><tr><th>容器<th>[]下标访问<th>push_back<th>pop_back<th>insert<th>erase<th>find<th>sort<tbody><tr><td>std::array<td>O(1)<td>/<td>/<td>/<td>/<td>O(n)<td>O(n logn)<tr><td>std::vector<td>O(1)<td>O(1)<td>O(1)<td>O(n)<td>O(n)<td>O(n)<td>O(n logn)<tr><td>std::deque<td>O(1)<td>O(1)<td>O(1)<td>O(n)<td>O(n)<td>O(n)<td>O(n logn)<tr><td>std::list<td>/<td>O(1)<td>O(1)<td>O(1)<td>O(1)<td>O(n)<td>O(n logn)*<tr><td>std::forward_list<td>/<td>/<td>/<td>O(1)<td>O(1)<td>O(n)<td>/<tr><td>std::set/std::multiset<td>/<td>/<td>/<td>O(logn)<td>O(logn)<td>O(logn)<td>/<tr><td>std::map/std::multimap<td>/<td>/<td>/<td>O(logn)<td>O(logn)<td>O(logn)<td>/<tr><td>std::unorderd_set/std::unorderd_multiset<td>/<td>/<td>/<td>O(1)<td>O(1)<td>O(1)<td>/<tr><td>std::unorderd_map/std::unorderd_multimap<td>/<td>/<td>/<td>O(1)<td>O(1)<td>O(1)<td>/</table></div><p>*list的sort是成员函数。因为list不提供随机访问迭代器。</p><ul><li>需要随机访问或只在尾部进行插入或删除使用<code class="language-plaintext highlighter-rouge">vector</code>。<li>需要随机访问和头尾插入使用<code class="language-plaintext highlighter-rouge">deque</code><li>如果不需要随机访问但频繁插入和删除使用<code class="language-plaintext highlighter-rouge">list</code><li>如果内存格外受限则使用<code class="language-plaintext highlighter-rouge">forward_list</code><li>如果需要搜索且保持排序则使用<code class="language-plaintext highlighter-rouge">map/set</code><li>如果需要搜索但不需要排序使用<code class="language-plaintext highlighter-rouge">unordered_map/unordered_set</code></ul><h1 id="原始数组的初始化">原始数组的初始化</h1><ul><li>静态数组 <code class="language-plaintext highlighter-rouge">int array[100];</code><ul><li>定义了数组array，但并未对数组初始化；</ul><li>静态数组<code class="language-plaintext highlighter-rouge"> int array[100] = {0};</code><ul><li>定义了数组array，并将数组元素全部初始化为0；</ul><li>静态数组 <code class="language-plaintext highlighter-rouge">int array[100] = {1}; </code><ul><li>定义了数组array，并将数组第一个元素初始化为1，后面99个元素初始化为0；</ul><li>静态数组<code class="language-plaintext highlighter-rouge"> int array[100] = {4,5}; </code><ul><li>定义数组array，并初始化前两个元素为4,5，后面剩余元素初始化为0；</ul></ul><p><code class="language-plaintext highlighter-rouge">int a[5] = { 1 }; </code> 曾经我认为这是把数组全部初始化为１，事实却是，只有数组的第一个元素被初始化为１，其他全为０；</p><ul><li><p><strong>数组初始化列表中的元素个数小于指定的数组长度时，不足的元素补以默认值。</strong></p><ul><li>对应基本类型<code class="language-plaintext highlighter-rouge">int</code>来说，就是补0<li>非基本类型的数组就是调用默认构造函数。如<code class="language-plaintext highlighter-rouge">string</code><li><code class="language-plaintext highlighter-rouge">string a[5] = { "foo" };</code> 等同于 <code class="language-plaintext highlighter-rouge">string a[5] = { "foo", "", "", "", "" };</code><li><strong>如果不明确指出初始化列表，那么基本类型是不会被初始化的（除全局变量和静态变量外），所有的内存都是“脏的”；</strong><li><strong>而类类型则会为每个元素调用默认构造函数或使用默认值进行初始化。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">testnum</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">testnum</span><span class="p">(){</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">testnum1</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">testnum1</span><span class="p">(){</span>
            <span class="n">val</span> <span class="o">=</span> <span class="mi">23333</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">testnum</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//全是200</span>
    <span class="n">testnum1</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//全是23333</span>
    <span class="kt">int</span> <span class="n">arr2</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//没有初始化，脏数据，乱糟糟</span>
    <span class="kt">int</span> <span class="n">arr3</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//初始化为默认值 10个0</span>
<span class="p">}</span>  
</pre></table></code></div></div><li><p>注意，在C++11中，中间的赋值号可以省略，即</p><ul><li>` int a[5]{1};`是合法的，但依旧是只初始化第一个元素为1，剩下的都是默认0</ul><li><p>并且，如果初始化列表为空，如<code class="language-plaintext highlighter-rouge"> int a[5]{}</code>，那将初始化所有元素为默认值，即等同于<code class="language-plaintext highlighter-rouge"> int a[5]{0}; </code></p></ul><h1 id="再次重申容器是值语义拷贝进来拷贝出去">再次重申容器是值语义。拷贝进来拷贝出去。</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">my_vec</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">//拷贝进</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">my_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//还是100</span>
<span class="p">}</span>
</pre></table></code></div></div><p>为什么呢？我们看看push_back的源代码就好了</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">finish</span> <span class="o">!=</span> <span class="n">end_of_storage</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">construct</span><span class="p">(</span><span class="n">finish</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="o">++</span><span class="n">finish</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="nf">insert_aux</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们先不管其他的，我们只看<code class="language-plaintext highlighter-rouge">construct</code>这个部分</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">construct</span><span class="p">(</span><span class="n">T1</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">new</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">T1</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong><code class="language-plaintext highlighter-rouge">new (p) T1(value);</code>是一个<code class="language-plaintext highlighter-rouge">placement new</code>的用法，<code class="language-plaintext highlighter-rouge">new</code>的这个用法是在一个已分配好内存的地方调用构造函数来初始化一下。</strong></p><ul><li>我们这里看到了，我们拿了一个<code class="language-plaintext highlighter-rouge">value</code>的值来在一块特定的地方<strong>调用拷贝构造来构造</strong>了一个元素。这就是为什么我们说是拷贝进。</ul><p>https://blog.csdn.net/jmh1996/article/details/77968364</p><ul><li>针对是否拷贝出来，这个地方要综合分析</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">my_vec</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">my_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">//拷贝进</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">my_vec</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">b</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">my_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//肯定还是100</span>
    
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">my_vec</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">12345</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">my_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//变成12345</span>
<span class="p">}</span>
</pre></table></code></div></div><p>因为<code class="language-plaintext highlighter-rouge">front</code>返回第一个元素的引用。<strong>我们如果用一个引用来初始化一个值，那么会调用其拷贝构造。因为需要独立开来。</strong></p><h1 id="容器不能储存常量对象">容器不能储存常量对象</h1><p>没有<code class="language-plaintext highlighter-rouge">vector&lt;const int&gt;</code>。因为常量对象不是<em>可拷贝赋值</em>的。而且使用<code class="language-plaintext highlighter-rouge">cosnt vector&lt;int&gt;</code>可以达到同一效果。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//不可修改常量对象。所以是不可拷贝赋值的。</span>
</pre></table></code></div></div><h1 id="deque的使用提示">deque的使用提示</h1><ul><li>在空容器上对 <code class="language-plaintext highlighter-rouge">deque.front()/back()</code> 的调用是未定义的。<ul><li>因为它返回的是容器首元素的<strong>引用</strong>。</ul></ul><h1 id="map不同接口的使用推荐">map不同接口的使用推荐</h1><p>依旧来自Raymond Chen的<a href="https://devblogs.microsoft.com/oldnewthing/20241118-00/?p=110535">这篇文章</a></p><div class="table-wrapper"><table><thead><tr><th>Operation<th>Method<tbody><tr><td>Read, throw if missing / 读取，如果缺失则抛出异常<td><code class="language-plaintext highlighter-rouge">m.at(key)</code><tr><td>Read, allow missing / 读取，允许缺失<td><code class="language-plaintext highlighter-rouge">m.find(key)</code><tr><td>Read, create if missing / 读取，如果缺失则创建<td><code class="language-plaintext highlighter-rouge">m[key]</code><tr><td>Write, nop if exists, discard value / 写入，如果存在则nop，丢弃值<td><code class="language-plaintext highlighter-rouge">m.insert({ key, value })</code> /<code class="language-plaintext highlighter-rouge">m.emplace(key, value)</code><tr><td>Write, nop if exists / 写入，如果存在则nop<td><code class="language-plaintext highlighter-rouge">m.emplace(std::piecewise_construct, ...)</code> <code class="language-plaintext highlighter-rouge">m.try_emplace(key, params)</code><tr><td>Write, overwrite if exists / 写入，如果存在则覆盖。<td><code class="language-plaintext highlighter-rouge">m.insert_or_assign(key, value)</code></table></div><p>这么多接口，想实现如果没有就插入，如果有不要浪费构造这种逻辑，怎么做？</p><p>依旧是Raymond的<a href="https://devblogs.microsoft.com/oldnewthing/20241118-00/?p=110535">这篇文章</a>，来自<a href="https://github.com/wanghenshui/cppweeklynews/blob/dev/posts/173.md">这里</a>。 代码就是一坨。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/stl/" class="post-tag no-text-decoration" >STL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Effective%20STL%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01&url=%2Fposts%2FEFFSTL%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Effective%20STL%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01&u=%2Fposts%2FEFFSTL%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FEFFSTL%2F&text=Effective%20STL%20%E7%AC%94%E8%AE%B0%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/STL1/"><div class="card-body"> <em class="small" data-ts="1654980600" data-df="YYYY/MM/DD" > 2022/06/11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ STL - 1 - List</h3><div class="text-muted small"><p> C++ STL - 1 - List List G2.9 List自己本身只有一个指针指向了一个节点。它的数据__list_node和数据结构list是分开设计的。 数据本身不做过多叙述。一个指针指向前一个节点，一个指针指向下一个节点，一块数据区域。 List的迭代器 注意i++和++i的重载区别 在C++中，由于++i和i++都只有一个参数，那么...</p></div></div></a></div><div class="card"> <a href="/posts/imgtemp/"><div class="card-body"> <em class="small" data-ts="1654980600" data-df="YYYY/MM/DD" > 2022/06/11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>imgtemp</h3><div class="text-muted small"><p> imgtemp</p></div></div></a></div><div class="card"> <a href="/posts/STL2/"><div class="card-body"> <em class="small" data-ts="1654980600" data-df="YYYY/MM/DD" > 2022/06/11 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ STL - 2 - 迭代器设计思路。萃取。</h3><div class="text-muted small"><p> C++ STL - 2 - 迭代器设计思路。萃取。 什么是萃取？ 三个字：中间层 我们这里先以侯捷老师的iterator_traits做为例子。 我们知道，iterator迭代器本身有五个属性。我们也知道迭代器是一个class。所以也就是迭代器类有五个typedef。分别是： namespace std { template &amp;lt;typename T&amp;gt; ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="btn btn-outline-primary" prompt="上一篇"><p>算法相关</p></a> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="btn btn-outline-primary" prompt="下一篇"><p>数据库</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
