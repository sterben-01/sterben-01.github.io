<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++杂记 - 3" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="C++杂记 - 3" /><meta property="og:description" content="C++杂记 - 3" /><link rel="canonical" href="/posts/%E6%9D%82%E8%AE%B03/" /><meta property="og:url" content="/posts/%E6%9D%82%E8%AE%B03/" /><meta property="og:site_name" content="Sterben_01" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-06T01:55:00-05:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++杂记 - 3" /><meta name="twitter:site" content="@Kousaka_Ruri_" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-21T07:53:33-05:00","datePublished":"2022-09-06T01:55:00-05:00","description":"C++杂记 - 3","headline":"C++杂记 - 3","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E6%9D%82%E8%AE%B03/"},"url":"/posts/%E6%9D%82%E8%AE%B03/"}</script><title>C++杂记 - 3 | Sterben_01</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sterben_01"><meta name="application-name" content="Sterben_01"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Sterben_01</a></div><div class="site-subtitle font-italic">这里是01的博客～</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/sterben-01" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/Kousaka_Ruri_" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['Sterben_01','mkacg.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++杂记 - 3</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>C++杂记 - 3</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1662447300" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/09/06 </em> </span> <span> 更新于 <em class="" data-ts="1761051213" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2025/10/21 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="48505 字"> <em>269 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="c杂记---3">C++杂记 - 3</h1><h1 id="stdbind-stdfunction-和-stdmem_fn">std::bind, std::function 和 std::mem_fn</h1><h2 id="stdbind-包括但不限于mem_fn的功能更为通用的解决方案"><span class="mr-2">std::bind 包括但不限于mem_fn的功能，更为通用的解决方案</span><a href="#stdbind-包括但不限于mem_fn的功能更为通用的解决方案" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>什么是bind？我们可以把它看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</strong></p><p>std::bind将可调用对象与其参数一起进行绑定<strong>，绑定后的结果可以使用std::function保存</strong>。std::bind主要有以下两个作用：</p><ul><li>将可调用对象和其参数绑定成一个仿函数；<li>只绑定部分参数，减少可调用对象传入的参数。</ul><p>语法：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">newCallable</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">callable</span><span class="p">,</span> <span class="n">arg_list</span><span class="p">);</span>
</pre></table></code></div></div><p>该形式表达的意思是：当调用<code class="language-plaintext highlighter-rouge">newCallable</code>时，会调用<code class="language-plaintext highlighter-rouge">callable</code>，并传给它<code class="language-plaintext highlighter-rouge">arg_list</code>中的参数。</p><p>需要注意的是：<code class="language-plaintext highlighter-rouge">arg_list</code>中的参数可能包含形如<code class="language-plaintext highlighter-rouge">_n</code>的名字。其中<code class="language-plaintext highlighter-rouge">n</code>是一个整数，这些参数是占位符，表示<code class="language-plaintext highlighter-rouge">newCallable</code>的参数，它们占据了传递给<code class="language-plaintext highlighter-rouge">newCallable</code>的参数的位置。数值<code class="language-plaintext highlighter-rouge">n</code>表示生成的可调用对象中参数的位置：<code class="language-plaintext highlighter-rouge">_1</code>为<code class="language-plaintext highlighter-rouge">newCallable</code>的第一个<strong>待填充</strong>参数，<code class="language-plaintext highlighter-rouge">_2</code>为第二个<strong>待填充</strong>参数，以此类推。 注意这些占位符在<code class="language-plaintext highlighter-rouge">std::placeholders</code>名称空间内。</p><ul><li><p><strong>std::bind的返回值是可调用实体，可以直接赋给std::function</strong>。</p><li><p><strong>bind绑定类非静态成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，这是因为对象的成员函数需要有this指针</strong>。并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&amp;手动转换（符合成员函数指针的赋值语法）。静态成员函数无需此操作。因为没有this指针。</p><ul><li><p>注意传入对象地址也可以传入对象的引用或对象本身。</p><li><p><strong>在类内使用该类的成员函数的时候，和类外使用一样。都需要取地址并且传入对象指针。只不过可以使用<code class="language-plaintext highlighter-rouge">this</code>替代。</strong></p><ul><li><p>这个的常见案例是类内含有<code class="language-plaintext highlighter-rouge">thread</code>的时候，比如这种情况：</p><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">test</span><span class="p">{</span>
    <span class="n">test</span><span class="p">()</span><span class="o">:</span><span class="n">th1</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="o">::</span><span class="n">threadfunc</span><span class="p">,</span> <span class="k">this</span><span class="p">)){};</span> <span class="c1">//因为是类内使用该类成员函数，所以需要绑定，但是可以使用this替代。</span>
    <span class="o">~</span><span class="n">test</span><span class="p">(){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">th1</span><span class="p">.</span><span class="n">joinable</span><span class="p">()){</span>
            <span class="n">th1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
        <span class="p">}</span>
              
    <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">void</span> <span class="nf">threadfunc</span><span class="p">(){</span> <span class="c1">//成员函数。</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"hello world"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="kr">thread</span> <span class="n">th1</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span> <span class="n">mytest</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">my_class</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">my_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>

    <span class="kt">void</span> <span class="nf">getval</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">another</span><span class="p">){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">another</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">staticfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static"</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">my_class</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">getval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span> 	<span class="c1">//调用无参函数，this参数预绑定。成员函数指针遵循语法。</span>
    <span class="k">auto</span> <span class="n">task3</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">add</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>	<span class="c1">//调用有参函数，this参数预绑定。</span>
    <span class="k">auto</span> <span class="n">task4</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">add</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span> <span class="c1">//调用有参函数，this参数使用占位形式。</span>
    <span class="k">auto</span> <span class="n">task5</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">staticfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">//静态成员函数没有this指针。无需传入。</span>
    <span class="n">task2</span><span class="p">();</span>
    <span class="n">task3</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> 
    <span class="n">task4</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">//this使用占位形式，需要调用时传入。</span>
    <span class="n">task5</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>默认情况下，bind的那些不是占位符的参数会被拷贝或移动（以值传递）到bind返回的可调用对象中。如果需要使用引用传递，必须使用<code class="language-plaintext highlighter-rouge">ref</code></strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">mypred</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">){</span> <span class="err">尽管这里函数头使用了引用，但是</span><span class="n">bind</span><span class="err">在预绑定的时候</span><span class="p">(</span><span class="err">也就是非</span><span class="n">placeholder</span><span class="err">参数）默认会拷贝一份原参数进行传入，也就是默认是值传递。所以这里的容器</span><span class="n">c</span><span class="err">其实是一个局部变量。</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"yes"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
        
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">final</span><span class="p">;</span>
    <span class="k">final</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">test</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind</span><span class="p">(</span><span class="n">mypred</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="k">final</span><span class="p">)));</span> <span class="err">所以这里我们如果要使用引用来传递</span><span class="k">final</span><span class="err">，则必须要使用</span><span class="n">ref</span><span class="err">函数来获取其引用。</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="k">final</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="k">final</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="使用stdbind搭配priority_queue-和-vector的自定义排序"><span class="mr-2">使用std::bind搭配priority_queue 和 vector的自定义排序。</span><a href="#使用stdbind搭配priority_queue-和-vector的自定义排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>请参考STL-1笔记</p><h2 id="慎用stdbind-如果可能的话使用lambda"><span class="mr-2">慎用std::bind, 如果可能的话使用lambda</span><a href="#慎用stdbind-如果可能的话使用lambda" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://lefticus.gitbooks.io/cpp-best-practices/content/08-Considering_Performance.html</p><p>https://stackoverflow.com/questions/49246242/efficiency-of-stdbind-vs-lambda</p><p>https://youtu.be/ZlHi8txU4aQ</p><p>https://mp.weixin.qq.com/s/VOqPjW48DG3gp60EqkYrTQ</p><h2 id="mem_fn-成员函数适配器-把成员函数转为函数对象使用对象指针或对象引用进行绑定"><span class="mr-2">mem_fn 成员函数适配器 把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定</span><a href="#mem_fn-成员函数适配器-把成员函数转为函数对象使用对象指针或对象引用进行绑定" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>个人实验得出的结论：<code class="language-plaintext highlighter-rouge">mem_fn</code>是<code class="language-plaintext highlighter-rouge">bind</code>的子集</strong>。</p><p>注意<code class="language-plaintext highlighter-rouge">mem_fn</code>不能调用类静态成员函数。因为没有this指针。</p><p><code class="language-plaintext highlighter-rouge">mem_fn</code>就是强制给你把类对象塞进去。</p><p><strong><code class="language-plaintext highlighter-rouge">mem_fn</code>无法接受额外参数。也就是无法使用<code class="language-plaintext highlighter-rouge">placeholder</code></strong></p><p><code class="language-plaintext highlighter-rouge">mem_fn</code>的核心功能是把类成员函数转换成不需要类成员就可以调用的形式。就是把<code class="language-plaintext highlighter-rouge">this</code>指针绑定到类成员函数的隐藏<code class="language-plaintext highlighter-rouge">this</code>参数上。但是调用的时候依旧需要传入一个对象地址。。就很废物。</p><p>比较：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">my_class</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">my_class</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>

    <span class="kt">void</span> <span class="nf">getval</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">another</span><span class="p">){</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">another</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">staticfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"static"</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">my_class</span> <span class="n">obj1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">task1</span> <span class="o">=</span> <span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">getval</span><span class="p">);</span> 
    <span class="n">task1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span> <span class="c1">//把对象地址传入</span>

    <span class="k">auto</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">add</span><span class="p">);</span>
    <span class="n">task2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

    <span class="c1">//auto task3 = mem_fn(&amp;my_class::staticfunc); 错误！静态成员函数不行。</span>

    <span class="k">auto</span> <span class="n">task1_1</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">getval</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">//bind就得多写个参数</span>
    <span class="n">task1_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
    
    <span class="k">auto</span> <span class="n">task1_2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">getval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
    <span class="n">task1_2</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="stdplaceholders"><span class="mr-2">std::placeholders</span><a href="#stdplaceholders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们提到了，我们使用<code class="language-plaintext highlighter-rouge">bind</code>的时候，<code class="language-plaintext highlighter-rouge">placeholder</code>是待填充参数。什么叫待填充？这是一种具象解释。其实<code class="language-plaintext highlighter-rouge">bind</code>相当于生成了一个新的可调用对象，拥有两个参数。但是结合原本的可调用对象来看，我们有三个参数。所以站在原本的可调用对象角度来看，这原来的可调用对象中多出来的一个参数相当于已填充参数。剩下的两个参数相当于待填充。</p><p>语法和例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">testfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="k">auto</span> <span class="n">callable1</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">testfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">callable1</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span>
    <span class="c1">//输出8 80 5</span>
    <span class="k">auto</span> <span class="n">callable2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">testfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">callable2</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span>
    <span class="c1">//输出80 8 5</span>

    <span class="k">auto</span> <span class="n">callable3</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">testfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">);</span>
    <span class="n">callable3</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span>
    <span class="c1">//输出8 5 80</span>
    <span class="k">auto</span> <span class="n">callable4</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">testfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_3</span><span class="p">);</span> <span class="c1">//错误。新的调用对象只有两个参数。这里3超了。并placeholders且必须按序。不可跨越。不能没有2的时候直接使用3，尽管可能待填充参数一共有3个。</span>
    <span class="n">callable4</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span>
    
    <span class="k">auto</span> <span class="n">callable5</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="n">testfunc</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">//极端情况。占位符可以重复。</span>
    <span class="n">callable5</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="c1">//输出8 5 8</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>注意</strong></p><ul><li><code class="language-plaintext highlighter-rouge">placeholder</code>编号必须按序。此处按序指的是不能没有<code class="language-plaintext highlighter-rouge">2</code>的时候直接使用<code class="language-plaintext highlighter-rouge">3</code><li>并且编号不能大于待填充参数的数量。</ul><p>参考资料：https://elloop.github.io/c++/2015-12-15/learning-using-stl-12-std-bind</p><h2 id="stdfunction"><span class="mr-2">std::function</span><a href="#stdfunction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>大家都用过函数指针。具体就不赘述了。稍微回忆一下函数指针的语法：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">another_a_ptr_ptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">a_ptr</span><span class="p">);</span>
<span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">another_a_ptr_ptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span> <span class="err">这个函数指针的类型是</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span>
</pre></table></code></div></div><p>成员函数指针的用法和声明在杂记2。</p><p><strong>std::function是一个多态可调用对象包装器，是一个类模板，可以容纳除所有可调用对象（类成员函数和指针需要bind一下），它可以用统一的方式处理函数、函数对象、函数指针，lambda并允许保存和延迟它们的执行。基本上任何有函数调用运算符重载<code class="language-plaintext highlighter-rouge">operator()</code>的对象都可以被function包装。</strong></p><p><strong>注意，std::function支持多态。</strong></p><p>一个例子让你知道<code class="language-plaintext highlighter-rouge">function</code>怎么用：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">myfunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">myfunc1</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">myfunc2</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func</span> <span class="o">=</span> <span class="n">myfunc</span><span class="p">;</span>
    <span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func1</span> <span class="o">=</span> <span class="n">myfunc1</span><span class="p">;</span>
    <span class="n">func1</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func2</span> <span class="o">=</span> <span class="n">myfunc2</span><span class="p">;</span>
    <span class="n">func1</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p><strong>说白了就是类型是你的函数返回值类型+参数类型。</strong></p><p><strong>因为<code class="language-plaintext highlighter-rouge">std::function</code>可以保存lambda。所以当函数签名的参数是<code class="language-plaintext highlighter-rouge">std::function</code>对象的时候，可以直接传入一个类型匹配的lambda对象。有隐式类型转换</strong></p><p>我们前面提到过 <code class="language-plaintext highlighter-rouge">bind</code>的返回值是可调用实体，可以直接赋给<code class="language-plaintext highlighter-rouge">std::function</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task1_2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">getval</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">);</span>
<span class="n">task1_2</span><span class="p">();</span>

<span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">add</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>
<span class="n">task2</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>有一个问题是，这里必须要显式把对象地址直接塞进去，不能把对象地址用占位符。因为参数对不上了。（个人实验）</strong></p><p><strong>故而，std::function的作用可以归结于：</strong></p><ul><li>std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；<li>std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。</ul><h3 id="慎用stdfunction-性能极差"><span class="mr-2">慎用std::function 性能极差</span><a href="#慎用stdfunction-性能极差" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>虚函数的开销是常规函数的5倍，<code class="language-plaintext highlighter-rouge">std::function</code>是6倍以上。</p><p>原因是<code class="language-plaintext highlighter-rouge">std::function</code>的底层还是使用虚函数，进行多态调用。因为使用了类型擦除。同时，<code class="language-plaintext highlighter-rouge">std::function</code>是通用的，并且它不知道包装的可调用对象多大（比如lambda就是动态大小的，我们在lambda一节中提到了lambda的大小取决于捕获参数的数量和方式）。但是可调用对象必须要被<code class="language-plaintext highlighter-rouge">std::function</code>所保存，这样才能在<code class="language-plaintext highlighter-rouge">std::function</code>对象被移动或复制的时候正确的移动或复制。它的内部有一个缓冲区。如果可调用对象足够小，则不需要新开内存。所以当可调用对象大于某个阈值的时候，它需要使用动态内存分配来存储。同时，有几种方法可能避免。比如使用<code class="language-plaintext highlighter-rouge">std::ref</code>包装参数，或者在使用lambda函数初始化<code class="language-plaintext highlighter-rouge">std::function</code>对象时，对应的lambda可以使用引用捕获参数避免lambda的大小膨胀。</p><p>https://wizmann.tk/cpp-type-erasure-and-std-function.html</p><p>https://stackoverflow.com/questions/5057382/what-is-the-performance-overhead-of-stdfunction</p><p>https://stackoverflow.com/questions/18453145/how-is-stdfunction-implemented</p><p>https://blog.demofox.org/2015/02/25/avoiding-the-performance-hazzards-of-stdfunction/</p><h3 id="关于stdfunction和多态"><span class="mr-2">关于std::function和多态</span><a href="#关于stdfunction和多态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>std::function既然叫做多态函数包装器，那么就可以正确处理多态。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">father</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">father</span><span class="p">()</span><span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"father"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">child</span><span class="o">:</span><span class="k">public</span> <span class="n">father</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">child</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"child"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>

    <span class="n">father</span><span class="o">*</span> <span class="n">fptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">child</span><span class="p">;</span>
    <span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">funcobj</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">father</span><span class="o">::</span><span class="n">func</span><span class="p">,</span> <span class="n">fptr</span><span class="p">);</span>
    <span class="n">funcobj</span><span class="p">();</span> <span class="c1">//输出child</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="关于源码解析"><span class="mr-2">关于源码解析</span><a href="#关于源码解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>脸都看绿了。</p><p>https://blog.csdn.net/zdy0_2004/article/details/50652934</p><p>https://blog.csdn.net/weixin_43798887/article/details/116571325</p><p>https://zhuanlan.zhihu.com/p/560964284</p><p>https://zhuanlan.zhihu.com/p/66301236</p><h2 id="在函数中传递stdfunction对象搭配bind并考虑使用placeholders"><span class="mr-2">在函数中传递<code class="language-plaintext highlighter-rouge">std::function</code>对象，搭配<code class="language-plaintext highlighter-rouge">bind</code>并考虑使用<code class="language-plaintext highlighter-rouge">placeholders</code>。</span><a href="#在函数中传递stdfunction对象搭配bind并考虑使用placeholders" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了方便起见。此处仅使用全局函数为例。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">funcinput</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">in_func</span><span class="p">){</span><span class="c1">//注意函数入参签名</span>
    <span class="n">in_func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">another_funcinput</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">in_func</span><span class="p">){</span> <span class="c1">//注意函数入参签名</span>
    <span class="n">in_func</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">"abc"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">funcinput</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_3</span><span class="p">));</span> <span class="c1">//输出12abc</span>
    <span class="n">another_funcinput</span><span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">));</span><span class="c1">//输出ab123</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p>我们打算将<code class="language-plaintext highlighter-rouge">std::function</code>对象传入函数。</p><p>注意在搭配<code class="language-plaintext highlighter-rouge">bind</code>使用的时候。注意<code class="language-plaintext highlighter-rouge">function</code>的类型。[下方例子全部忽略第一个实际参数（为函数地址）]。<u>**`function`的类型为函数返回类型+除预先绑定的参数以外的全部参数类型（所有`placeholders`代表的类型）。**</u></p><ul><li>在<code class="language-plaintext highlighter-rouge">bind(&amp;test, placeholders::_1, placeholders::_2, placeholders::_3)</code>的时候，由于三个参数全部为<code class="language-plaintext highlighter-rouge">placeholders</code>，所以此时<code class="language-plaintext highlighter-rouge">function</code>的类型为目标函数的返回值类型+全部参数类型。为<code class="language-plaintext highlighter-rouge">function&lt;void(int, int, const string&amp;)&gt; </code>。<li>在<code class="language-plaintext highlighter-rouge">(bind(&amp;test, 1, placeholders::_1, placeholders::_2)</code>的时候，由于第一个参数为预绑定，只有两个<code class="language-plaintext highlighter-rouge">placeholders</code>，所以此时<code class="language-plaintext highlighter-rouge">function</code>的类型为目标函数的返回值类型+除第一个外，也就是剩余的参数类型。为<code class="language-plaintext highlighter-rouge">function&lt;void(int, const string&amp;)&gt;</code></ul><h2 id="一个稍微复杂的包裹类练习使用了模板和bind"><span class="mr-2">一个稍微复杂的包裹类练习。使用了模板和bind</span><a href="#一个稍微复杂的包裹类练习使用了模板和bind" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们这一段代码的目的是想简单模拟一下unique_ptr调用自定义删除器的过程。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myInt</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">val1</span><span class="p">;</span>
    <span class="n">myInt</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">//要点1</span>
    <span class="n">myInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">val1</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
    <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="c1">//要点2</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">global_func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"global"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">anotherone</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">T1</span> <span class="n">callable</span><span class="p">;</span> <span class="c1">//要点3 </span>
        <span class="n">T2</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">anotherone</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">anotherone</span><span class="p">(</span><span class="n">T2</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span><span class="n">value</span><span class="p">(</span><span class="n">val</span><span class="p">){}</span> <span class="c1">//要点4</span>
        <span class="n">anotherone</span><span class="p">(</span><span class="n">T1</span> <span class="n">func</span><span class="p">,</span> <span class="n">T2</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="n">value</span><span class="p">(</span><span class="n">val</span><span class="p">){}</span> <span class="c1">//要点5</span>
        <span class="kt">void</span> <span class="nf">operator</span><span class="p">()(){</span>
            <span class="n">callable</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">myInt</span> <span class="n">tests</span><span class="p">;</span> <span class="c1">//要点6</span>
    <span class="k">auto</span> <span class="n">objbind</span> <span class="o">=</span> <span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myInt</span><span class="o">::</span><span class="k">operator</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">tests</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span> <span class="c1">//要点7</span>
    <span class="k">typedef</span> <span class="k">decltype</span><span class="p">(</span><span class="n">objbind</span><span class="p">)</span> <span class="n">mytype</span><span class="p">;</span> <span class="c1">//要点8</span>
    <span class="n">anotherone</span><span class="o">&lt;</span><span class="n">mytype</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">myobj2</span><span class="p">(</span><span class="n">objbind</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span> <span class="c1">//要点9 T1是bind类型</span>
    <span class="n">anotherone</span><span class="o">&lt;</span><span class="n">myInt</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">myobj</span><span class="p">(</span><span class="mi">234</span><span class="p">);</span> <span class="c1">//要点10 T1 是 myInt类型</span>
    <span class="n">myobj2</span><span class="p">();</span>
    <span class="n">myobj</span><span class="p">();</span>
    
    <span class="n">anotherone</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">myobj3</span><span class="p">(</span><span class="n">global_func</span><span class="p">,</span> <span class="mi">345</span><span class="p">);</span>
    <span class="n">myobj3</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>要点1 <code class="language-plaintext highlighter-rouge">myInt</code>必须提供默认构造。原因是我们的<code class="language-plaintext highlighter-rouge">anotherone</code>在不接受函数对象做为可调用对象的时候，会利用第一个模板参数的类型构建一个 第一个模板参数类型的对象。也就是<code class="language-plaintext highlighter-rouge">myInt</code>对象。如果没有默认构造则会失败<li>要点2 <code class="language-plaintext highlighter-rouge">operator()</code>没有固定实现。返回值可以依靠不同需求做决定<li>要点3等同于要点1。在不接受函数对象做为可调用对象的时候，这个东西是第一个模板参数的类型的对象。然后我们会调用这个对象的<code class="language-plaintext highlighter-rouge">operator()</code>来进行调用。如果是一个可调用对象，则利用这个可调用对象进行调用。比如<code class="language-plaintext highlighter-rouge">bind</code>和<code class="language-plaintext highlighter-rouge">function</code>或函数指针。<li>要点4是为了匹配不提供调用对象只提供类型的情况<li>要点5是为了匹配提供调用对象的情况<li>要点6和要点7是bind成员函数的时候必须传入一个对象地址做为this指针<li>要点8是因为我们必须要显式指明类型，所以要有一个decltype辅助我们判断类型。<li>要点9和要点10就是实际模拟传入一个可调用对象或不传入可调用对象，只通过类型进行调用。</ul><h2 id="lambda-bind和function的简单准则"><span class="mr-2">lambda， bind和function的简单准则</span><a href="#lambda-bind和function的简单准则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在性能关键点，一定要避免使用<code class="language-plaintext highlighter-rouge">std::function</code>或函数指针调用函数。尽可能避免使用<code class="language-plaintext highlighter-rouge">bind</code>和lambda。如果一定要使用，优先选择lambda，其次是<code class="language-plaintext highlighter-rouge">bind</code>，然后是函数指针，最后才是<code class="language-plaintext highlighter-rouge">std::function</code>。</p><p>https://stackoverflow.com/questions/49246242/efficiency-of-stdbind-vs-lambda</p><h1 id="stdcall_once-和-stdonce_flag">std::call_once 和 std::once_flag</h1><p>原型：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Callable</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span> <span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">call_once</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">once_flag</span><span class="o">&amp;</span> <span class="n">flag</span><span class="p">,</span> <span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">);</span>
</pre></table></code></div></div><p>通过<code class="language-plaintext highlighter-rouge">call_in_once</code>执行的可调用对象可以保证在多线程的状态下仅被（一个线程）执行一次</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="n">once_flag</span> <span class="n">my_flag1</span><span class="p">;</span> <span class="c1">//这个flag是一次性使用的。必须要全局。而且如果有两个东西需要call_once就要两个flag</span>
<span class="n">once_flag</span> <span class="n">my_flag2</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">func1</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"func1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"func2"</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">thread_exe</span><span class="p">(){</span>
    <span class="c1">//once_flag my_flag1; //错误 放在这里就是线程函数的局部变量。这样每个线程就会有自己的flag</span>
    <span class="c1">//once_flag my_flag2;</span>
    <span class="n">call_once</span><span class="p">(</span><span class="n">my_flag1</span><span class="p">,</span> <span class="n">func1</span><span class="p">);</span>
    <span class="n">call_once</span><span class="p">(</span><span class="n">my_flag2</span><span class="p">,</span> <span class="n">func2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kr">thread</span> <span class="n">mythread1</span><span class="p">(</span><span class="n">thread_exe</span><span class="p">);</span>
    <span class="kr">thread</span> <span class="n">mythread2</span><span class="p">(</span><span class="n">thread_exe</span><span class="p">);</span>
    <span class="n">mythread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">mythread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意事项：</p><ul><li><code class="language-plaintext highlighter-rouge">once_flag</code>对象对于所有线程来说应该是全局变量（或等同于全局变量的形式）。因为<code class="language-plaintext highlighter-rouge">once_flag</code>对象只能被使用一次。如果是局部变量，则放在这里就是线程函数的局部变量。这样每个线程就会有自己的<code class="language-plaintext highlighter-rouge">once_flag</code>对象，就无法起作用。<li>因为每一个<code class="language-plaintext highlighter-rouge">once_flag</code>对象是一次性的。所以如果有两个东西需要call_once就要两个<code class="language-plaintext highlighter-rouge">once_flag</code>对象<li>当<code class="language-plaintext highlighter-rouge">flag</code>没有标记为<code class="language-plaintext highlighter-rouge">done</code>，所有线程都会阻塞在<code class="language-plaintext highlighter-rouge">once_flag</code>这里，此时：<ul><li>如果某个<code class="language-plaintext highlighter-rouge">Callable</code>抛出异常，则<code class="language-plaintext highlighter-rouge">call_once</code>会选择下一个等候的线程重新执行<code class="language-plaintext highlighter-rouge">call_once</code>动作。<li>如果成功执行了<code class="language-plaintext highlighter-rouge">Callable</code>，解除所有等候线程的阻塞并给<code class="language-plaintext highlighter-rouge">flag</code>标记为<code class="language-plaintext highlighter-rouge">done</code>。</ul></ul><p>参考：https://blog.csdn.net/qq_31175231/article/details/77916028</p><p>https://blog.csdn.net/XJF199001/article/details/51435845</p><h1 id="异步apistdfuture-stdpromise-stdpackaged_task-stdasync">异步API。std::future, std::promise, std::packaged_task, std::async</h1><p>想要进行多线程编程，这四个看起来高级的API是必不可少的。我们来看一看这一套异步编程套组里的四个组件到底有什么关系，他们是干什么的。</p><p>参考资料：https://segmentfault.com/a/1190000039201271</p><p>https://murphypei.github.io/blog/2019/04/cpp-concurrent-4</p><h2 id="stdfuture--stdshared_future"><span class="mr-2">std::future / std::shared_future</span><a href="#stdfuture--stdshared_future" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">&lt; future &gt;</code>头文件功能允许对特定提供者设置的值进行异步访问，可能在不同的线程中。 这些<strong>提供程序</strong>(要么是<code class="language-plaintext highlighter-rouge">promise</code> 对象，要么是<code class="language-plaintext highlighter-rouge">packaged_task</code>对象，或者是对异步的调用<code class="language-plaintext highlighter-rouge">async</code>)与<code class="language-plaintext highlighter-rouge">future</code>对象共享<strong><em>共享状态</em></strong>：提供者使共享状态就绪的点与<code class="language-plaintext highlighter-rouge">future</code>对象访问共享状态的点同步。</p><p>上面这段话翻译过来就是我们可以理解为future是一个时间胶囊, 一个对象<strong>。这个对象的提供程序（如promise)里面储存了我们希望以后拿到的东西。然后我们用future来和提供程序连接起来，一旦共享状态转变为就绪，就可以拿到提供程序里面的东西。</strong></p><ul><li><strong>所以说，future对象提供了一种让我们访问异步操作的结果的机制。</strong></ul><p>我们看一下future的正式定义和具体细节。</p><ul><li>future 是一个对象，<strong>可以从某个提供对象或函数中检索值</strong>，如果在不同线程中，则可以正确同步此访问。<li>future的模板参数类型是其异步操作结果的类型。<li>它提供了一种访问异步操作结果的机制。从字面意思上看它表示未来，这个意思就非常贴切，因为它不是立即获取结果但是可以在某个时候以同步的方式来获取结果。我们可以通过查询<code class="language-plaintext highlighter-rouge">future</code>的状态来获取异步操作的结果。<strong><code class="language-plaintext highlighter-rouge">future_status</code>有三种状态：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">deferred</code>：</strong>异步操作还未开始。共享状态包含一个延迟函数，因此只有在明确请求时才会计算结果。（主要用于<code class="language-plaintext highlighter-rouge">async</code>函数的<code class="language-plaintext highlighter-rouge">std::launch::deferred</code>参数。) （<strong>共享状态持有的函数正在延迟运行，结果将仅在显式请求时计算</strong>）<li><strong><code class="language-plaintext highlighter-rouge">ready</code>：</strong>异步操作已经完成（<strong>共享状态就绪</strong>）<li><strong><code class="language-plaintext highlighter-rouge">timeout</code></strong>：异步操作超时。在指定的超时持续时间过去之前，共享状态尚未准备好。（<strong>共享状态在经过指定的等待时间内仍未就绪</strong>）</ul><li>“有效” future 对象，只能通过调用以下函数之一来构造：<ul><li><code class="language-plaintext highlighter-rouge">async</code><li><code class="language-plaintext highlighter-rouge">promise::get_future</code><li><code class="language-plaintext highlighter-rouge">packaged_task::get_future</code></ul><li>默认构造的 future 对象是无效的（除非移动（move）分配一个有效的 future）。<li>在有效的 future 上调用 <code class="language-plaintext highlighter-rouge">future::get</code> 会阻塞线程，直到提供程序准备好共享状态（通过设置值或异常）。这样，两个线程可以通过一个线程同步，等待另一个线程设置值。<ul><li><strong><code class="language-plaintext highlighter-rouge">get()</code> 调用会改变其共享状态，不再可用，也就是说 <code class="language-plaintext highlighter-rouge">get()</code> 只能被调用一次，多次调用会触发异常。如果想要在多个线程中多次获取产出值需要使用 <code class="language-plaintext highlighter-rouge">shared_future</code>。</strong></ul><li>共享状态的生存期至少要持续到与之关联的最后一个对象释放它或销毁它为止。因此，如果与 future 相关联，共享状态可以在最初获得它的对象（如果有的话）之后继续存在。</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506204825200.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506204825200.png" alt="20190506204825200" class="lazyload" data-proofer-ignore></a></p><h2 id="什么叫共享状态--整理自emc-条款38"><span class="mr-2">什么叫共享状态？ – 整理自EMC++ 条款38</span><a href="#什么叫共享状态--整理自emc-条款38" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们先来思考一下。我们知道了，我们可以通过promise，packaged_task拿到一个future对象。future对象是一个句柄，用于让我们访问异步操作的结果。在我们的直观想象中，可能调用方和被调用方的关系是这个样子：</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230224205647.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230224205647.png" alt="QQ截图20230224205647" class="lazyload" data-proofer-ignore></a></p><ul><li>这时候有了第一个问题。被调用方的结果储存在哪比较好？在调用方使用<code class="language-plaintext highlighter-rouge">get</code>之前，可能这个异步操作已经执行完毕。同时，我们只能给<code class="language-plaintext highlighter-rouge">promise</code>设定值，而不能从<code class="language-plaintext highlighter-rouge">promise</code>中获取值。<strong>因此结果不会储存在被调用方的<code class="language-plaintext highlighter-rouge">promise</code>对象中。</strong><li><strong>同时，这个结果也不能存在调用方的<code class="language-plaintext highlighter-rouge">future</code>对象中</strong>。因为我们可能通过<code class="language-plaintext highlighter-rouge">future</code>对象创建其他的<code class="language-plaintext highlighter-rouge">shared_future</code>对象。而<code class="language-plaintext highlighter-rouge">shared_future</code>对象可能会有多个。那么这么多对应同一个结果中的<code class="language-plaintext highlighter-rouge">future</code>对象中，哪一个应该包含结果呢？</ul><p><strong>所以<code class="language-plaintext highlighter-rouge">future</code>和结果应该储存在两个位置。这个位置被称之为共享状态。共享状态通常使用堆上的对象来表示，但是其型别、接口和实现标准皆未指定。标准库作者可以自由地用他们喜好的方法去实现共享状态。</strong></p><p>所以说，调用方和被调用方的关系是这个样子：</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230224212325.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230224212325.png" alt="QQ截图20230224212325" class="lazyload" data-proofer-ignore></a></p><h4 id="共享状态是有引用计数的futurepackaged_task和promise对象的析构函数对其负责所以在一些情况下future对象的析构函数会由于共享状态的原因被阻塞请查看async部分同时部分资料来自这里"><span class="mr-2">共享状态是有引用计数的。<code class="language-plaintext highlighter-rouge">future</code>，<code class="language-plaintext highlighter-rouge">~packaged_task</code>和<code class="language-plaintext highlighter-rouge">promise</code>对象的析构函数对其负责。所以在一些情况下，<code class="language-plaintext highlighter-rouge">future</code>对象的析构函数会由于共享状态的原因被阻塞。请查看<code class="language-plaintext highlighter-rouge">async</code>部分。同时部分资料来自<a href="https://stackoverflow.com/questions/43383530/who-is-responsible-for-the-shared-state-of-futures-and-promises">这里</a></span><a href="#共享状态是有引用计数的futurepackaged_task和promise对象的析构函数对其负责所以在一些情况下future对象的析构函数会由于共享状态的原因被阻塞请查看async部分同时部分资料来自这里" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>但是注意，只有<code class="language-plaintext highlighter-rouge">future</code>对象的析构会阻塞，其他的不会。因为剩下两个对象的析构函数是抛弃（abandon）共享状态。而<code class="language-plaintext highlighter-rouge">future</code>对象的析构是释放（release）共享状态。</strong></ul><p>关于到底什么是共享状态，这个答案不太好。https://stackoverflow.com/questions/62241240/how-to-comprehend-stdfuture-shared-state</p><h3 id="futurevalid"><span class="mr-2">future::valid()</span><a href="#futurevalid" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="检查有效的共享状态"><span class="mr-2">检查有效的共享状态</span><a href="#检查有效的共享状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>返回 future 对象当前是否与共享状态关联。<li>对于默认构造的 future 对象，此函数返回 false (除非将有效的 future 分配给移动对象)。<li>future 只能由某些提供函数（如， <code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">promise::get_future</code> 或 <code class="language-plaintext highlighter-rouge">packaged_task::get_future</code>）使用有效的共享状态进行初始化。<li>一旦使用 future::get 检索了共享状态的值，则调用此函数返回 false (除非移动分配了一个新的 future).</ul><h4 id="返回值"><span class="mr-2">返回值</span><a href="#返回值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>如果对象与共享状态关联，则为 ture。<li>否则为假。</ul><p><strong>特别注意。返回值为true不代表此时共享状态已经就绪。只能表明对象与共享状态关联。</strong></p><h3 id="futurewait"><span class="mr-2">future::wait</span><a href="#futurewait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="阻塞并等待共享状态就绪结果可用"><span class="mr-2">阻塞并等待共享状态就绪（结果可用）</span><a href="#阻塞并等待共享状态就绪结果可用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h3 id="futureget"><span class="mr-2">future::get</span><a href="#futureget" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>可以理解为包含了<code class="language-plaintext highlighter-rouge">wait</code>的操作。因为他调用了<code class="language-plaintext highlighter-rouge">wait</code>。</p><h4 id="阻塞并等待共享状态就绪结果可用返回存储在共享状态中的值或引发其异常"><span class="mr-2">阻塞并等待共享状态就绪（结果可用），返回存储在共享状态中的值（或引发其异常）</span><a href="#阻塞并等待共享状态就绪结果可用返回存储在共享状态中的值或引发其异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>当共享状态就绪时，返回存储在共享状态中的值（或引发其异常）。<li><strong>如果共享状态尚未准备好（即提供程序尚未设置其值或异常），则该函数将阻塞调用线程直到准备就绪。在此前，调用了get的函数不会返回。</strong><li>共享状态就绪后，该函数将取消阻塞并返回（或引发异常）以释放其共享状态。<strong>这时 future 对象不再有效</strong>：<strong>对于每个 future 的共享状态，此成员函数最多应被调用一次</strong>。<li>提供者准备好共享状态和返回此函数之间是同步的。</ul><h3 id="shared_future"><span class="mr-2">shared_future</span><a href="#shared_future" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">std::shared_future</code> 与 <code class="language-plaintext highlighter-rouge">std::future</code> 类似，但是 <code class="language-plaintext highlighter-rouge">std::shared_future</code> 可以拷贝、多个 <code class="language-plaintext highlighter-rouge">std::shared_future</code> 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常)。<strong><code class="language-plaintext highlighter-rouge">shared_future</code> 可以通过某个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象隐式转换（参见 <code class="language-plaintext highlighter-rouge">std::shared_future</code> 的构造函数），或者通过 <code class="language-plaintext highlighter-rouge">std::future::share()</code> 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid</strong>。<code class="language-plaintext highlighter-rouge">std::shared_future</code> 的成员函数和 <code class="language-plaintext highlighter-rouge">std::future</code> 大部分相同，这个地方就不一一展开了，需要的请查阅官方文档。</p><p>我们可以看到，想要创建一个有效的future对象必须依靠剩下的三个API。我们就来进一步看看剩下的几块内容。</p><h2 id="stdpromise"><span class="mr-2">std::promise</span><a href="#stdpromise" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>promise是剩下三个当中最为“原始，底层“的API。</p><p><strong><code class="language-plaintext highlighter-rouge">promise</code> 本质是一个类似我们打印输出中占位符的东西，你可以理解它就是一个等待数据装填的坑，它是一个“承诺”，承诺未来会有相应的数据（模板实现）</strong>。因为这是一个“承诺”，所以创建的时候是没有东西的，所以我们需要知道这个异步操作什么时候能有东西，好实现“承诺”，所以 <code class="language-plaintext highlighter-rouge">promise</code> 可以通过调用 <code class="language-plaintext highlighter-rouge">get_future()</code> 返回一个 <code class="language-plaintext highlighter-rouge">future</code> 对象，让你去了解这个承诺是否完成了。因此，<code class="language-plaintext highlighter-rouge">promise</code> 是存放异步操作产出值的坑，而 <code class="language-plaintext highlighter-rouge">future</code> 是从其中获取异步操作结果，二者都是模板类型。</p><p><strong>这里理解为我们的future对象是一个接口，建立起与promise对象的联系。我们使用promise对象来进行异步操作，所以能看到我们并不需要把future对象传入线程。但是我们会通过future对象去获知这个异步操作的结果是否就绪，也就是promise对象是否已经包含了我们期望的结果。然后我们可以通过future来获取结果。通过搭配future和promise，我们可以安全的进行线程间通信，不需要显式同步</strong></p><p>promise和future就是一个异步操作的两个端点。我们把结果储存在promise，然后通过future提取。</p><ul><li><code class="language-plaintext highlighter-rouge">promise</code> 是一个对象，由 <code class="language-plaintext highlighter-rouge">future</code> 对象（可能在另一个线程中）检索，并提供一个同步点。<li>通过调用成员<code class="language-plaintext highlighter-rouge">get_future</code>，可以将该共享状态与 <code class="language-plaintext highlighter-rouge">future </code>对象关联。 调用之后，两个对象共享相同的共享状态：<ul><li><code class="language-plaintext highlighter-rouge">promise</code>对象是异步提供程序，应在某个时候为共享状态设置一个值。<code class="language-plaintext highlighter-rouge">set_value</code><li><code class="language-plaintext highlighter-rouge">future</code> 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。<li>理解为我们通过<code class="language-plaintext highlighter-rouge">promise</code>的<code class="language-plaintext highlighter-rouge">get_future</code>来创建我们的<code class="language-plaintext highlighter-rouge">future</code>对象。之后通过<code class="language-plaintext highlighter-rouge">future</code>对象（来检索）获得一个共享状态（结果）。<li><strong>注意 每个<code class="language-plaintext highlighter-rouge">std::promise</code> 对象只应当使用一次。</strong></ul></ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506203234388.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/20190506203234388.png" alt="20190506203234388" class="lazyload" data-proofer-ignore></a></p><h3 id="promiseset_value"><span class="mr-2">promise::set_value</span><a href="#promiseset_value" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>以原子方式</strong>将值存储到共享状态（就是把promise对象储存的值设置好），<strong>并且改变该状态变为就绪状态</strong>。（设置共享状态）<li>如果与同一共享状态关联的future对象当前正在等待对<code class="language-plaintext highlighter-rouge">future::get</code>的调用，则它将取消阻塞并返回val。<ul><li>因为future的get/wait会阻塞等待共享状态被设置完毕。</ul></ul><p>看看简单代码例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">//使用promise进行异步</span>
<span class="kt">void</span> <span class="nf">accumulate2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="c1">//注意不太需要返回值了。因为异步返回的值被储存在了promise对象中</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">)</span> <span class="c1">//函数头要有promise对象定义。</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">accumulate_promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>  <span class="c1">// 将结果存入，并让共享状态变为就绪以提醒future</span>
    <span class="c1">//如果不set_value,那么调用了future::get/wait的线程将一直被阻塞。</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 演示用 promise&lt;int&gt; 在线程间传递结果。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_promise</span><span class="p">;</span> <span class="c1">//声明promise对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span><span class="p">(</span><span class="n">accumulate_promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span> <span class="c1">//通过promise对象的get_future来初始化(获取）future对象</span>
    
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">work_thread</span><span class="p">(</span><span class="n">accumulate2</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">accumulate_promise</span><span class="p">));</span> <span class="c1">//启动线程。设置好执行函数和传入参数。注意必须要把promise对象一并传入（移入）</span>
    <span class="c1">//!这里也可以用ref。但是我们accumulate2的函数头要了个值。promise又禁用了拷贝构造所以这里目前只可以move。如果accumulate2函数头改为&amp;就可以用ref</span>
    <span class="c1">// !可以用ref但是不推荐。因为如果你不转移所有权，万一你多个线程并发访问了promise，可能会有问题，</span>
    <span class="o">!</span><span class="err">而且这也不符合设计，一般来说只应该让一个线程持有</span><span class="n">promise</span>
    <span class="c1">//accumulate_future.wait();  //等待结果 这个可以去掉，直接用get就可以</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result="</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">//get阻塞住等待共享对象变为ready。然后获取结果。</span>
    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">//阻塞等待线程执行完成</span>
 
    <span class="n">getchar</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="stdpackaged_task"><span class="mr-2">std::packaged_task</span><a href="#stdpackaged_task" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>packaged_task比promise高级一点。直观来看就是参数少一点，操作少一点。稍后我们会有一个简单的对比。</p><p><code class="language-plaintext highlighter-rouge">packaged_task</code> 是对一个任务的抽象，我们可以给其传递一个函数来完成其构造。相较于 <code class="language-plaintext highlighter-rouge">promise</code>，它应该算是更高层次的一个抽象，同样地，我们可以将任务投递给任何线程去完成，然后通过 <code class="language-plaintext highlighter-rouge">packaged_task::get_future()</code> 方法获取的 <code class="language-plaintext highlighter-rouge">future</code> 对象来获取任务完成后的产出值。总结来说，<strong><code class="language-plaintext highlighter-rouge">packaged_task</code> 是连数据操作（比如set_value)都封装进去了的 <code class="language-plaintext highlighter-rouge">promise</code></strong>。<code class="language-plaintext highlighter-rouge">packaged_task</code> 也是一个类模板，模板参数为函数签名，也就是传递函数的类型。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">packaged_task</span><span class="p">;</span>     <span class="c1">// undefined</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Ret</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">packaged_task</span><span class="o">&lt;</span><span class="n">Ret</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><strong>std::packaged_task包装可调用对象，并允许异步检索其结果。</strong>（可调用对象是重点）<li>类似于 std::function, 但是会自动将其结果传输到 future 对象。<li>对象内部包含两个元素：<ul><li>存储的任务是一些可调用对象（例如，函数指针，成员或函数对象的指针），其调用签名应采用 Args… 中类型的参数，并返回 Ret 类型的值。<li>共享状态，该状态能够存储调用存储的任务（类型为 Ret）的结果，并且可以通过 future 来异步访问。</ul><li>通过调用成员 get_future 将共享状态与 future 对象关联。调用之后，两个对象共享相同的共享状态：<ul><li>packaged_task 对象是异步提供程序，通过调用存储的任务，可以在某个时刻将共享状态设置为就绪。<li>future 对象是一个异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪。</ul></ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/2019050621124831.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/2019050621124831.png" alt="2019050621124831" class="lazyload" data-proofer-ignore></a></p><p>看看代码实例，做一下比较：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="c1">//? 使用packaged_task进行异步</span>
<span class="kt">int</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">)</span> <span class="c1">//注意函数头，我们没有像promise那样需要传入promise对象。</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>  <span class="c1">//所以也不需要promise的set_value</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 演示用 packaged_task 在线程间传递结果。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">accumulate_task</span><span class="p">(</span><span class="n">accumulate</span><span class="p">);</span>
    <span class="c1">//创建packaged_task对象。注意这里有区别，下面详说。</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">accumulate_task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span> <span class="c1">//通过packaged_task对象的get_future来创建future对象</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">work_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">accumulate_task</span><span class="p">),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//启动线程。注意这里有区别了。</span>
    <span class="cm">/*
    @ 使用move的主要原因还有一个就是按值传递函数参数会调用拷贝构造。packaged_task禁用了拷贝构造，要么传引用要么换成右值引用转移所有权。
    */</span>
    <span class="c1">//accumulate_future.wait();  //等待结果 可以和下面的get合并</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result="</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">work_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">//阻塞等待线程执行完成</span>
 
    <span class="n">getchar</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p><strong>我们来说一说几点具体区别</strong></p><ul><li>我们提到了，<code class="language-plaintext highlighter-rouge">packaged_task</code>包装的是可调用对象。但是<code class="language-plaintext highlighter-rouge">promise</code>仅仅是一个包装着异步执行结果的对象。所以：<ul><li><code class="language-plaintext highlighter-rouge">packaged_task</code>对象的模板类型是函数签名，因为他包装了可调用对象。<li>所以线程执行的时候只需要移入<code class="language-plaintext highlighter-rouge">packaged_task</code>对象即可，无需传入函数本身。因为已经被包装了。<li>所以包装的函数无需额外参数，函数内无需额外动作。<li>因为<code class="language-plaintext highlighter-rouge">promise</code>会储存异步任务的结果，所以函数的返回值可以去掉。</ul><li><p>其实理解了上面那一点，就理解了<code class="language-plaintext highlighter-rouge">packaged_task</code>和<code class="language-plaintext highlighter-rouge">promise</code>的区别。可以简单理解为<code class="language-plaintext highlighter-rouge">promise</code>是一个包装了执行结果的对象。而<code class="language-plaintext highlighter-rouge">packaged_task</code>是一个包装了整个任务的对象，它不仅包装任务执行结果，而且包装任务本身。</p><li>注意它的模板头参数</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ret</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">_ArgTypes</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">packaged_task</span><span class="o">&lt;</span><span class="n">_Ret</span><span class="p">(</span><span class="n">_ArgTypes</span><span class="p">...)</span><span class="o">&gt;</span> 
</pre></table></code></div></div><p>这样做的目的是让它的类型看起来更像函数。</p><h2 id="stdasync"><span class="mr-2">std::async</span><a href="#stdasync" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>async是最高级的一个API，代码简单，比较高层。它其实是封装了<code class="language-plaintext highlighter-rouge">thread </code>和 <code class="language-plaintext highlighter-rouge">packged_task</code>的功能，使异步执行一个任务更为方便</p><p><strong>async是函数模板，不是类模板。</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">unspecified</span> <span class="nf">policy</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>    
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">result_of</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
    <span class="n">async</span> <span class="p">(</span><span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>

<span class="n">specific</span> <span class="nf">policy</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span>    
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Fn</span><span class="p">,</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">result_of</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
    <span class="n">async</span> <span class="p">(</span><span class="n">launch</span> <span class="n">policy</span><span class="p">,</span> <span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">fn</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>异步调用函数在某个时刻调用 <code class="language-plaintext highlighter-rouge">fn</code> (以 <code class="language-plaintext highlighter-rouge">args</code> 作为参数)，返回时无需等待 <code class="language-plaintext highlighter-rouge">fn</code> 执行完成。(都说了是异步)<li><strong>可以通过返回的 future 对象（通过调用其成员 <code class="language-plaintext highlighter-rouge">future::get</code>）来访问 <code class="language-plaintext highlighter-rouge">fn</code> 返回的值。</strong><li>第二个版本 （2） 允许调用者选择特定的启动策略，而第一个版本 （1） 使用自动选择，就好像调用 (2) 并将 <code class="language-plaintext highlighter-rouge">launch::aysnc | launch::deferred</code> 作为策略。<li>该函数在共享状态下临时存储使用的线程处理程序。一旦完成 fn 的执行，共享状态将包含 fn 返回的值并准备就绪。</ul><div class="table-wrapper"><table><thead><tr><th>launch::async<th>启动一个新的线程以调用 fn （就像使用 fn 和 args 作为参数构造线程对象，并访问返回的 future 的共享状态将其联接）<code class="language-plaintext highlighter-rouge">std::thread(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</code><tbody><tr><td>launch::deferred<td>意味着函数可能只会在std::async返回的future对象<strong>调用get或wait时执行</strong>。（函数在future对象调用了get或wait的时候才会开始执行）。<strong>不会产出新的线程。该任务会在调用线程中执行。</strong>当调用get或wait时，函数会同步执行，即调用者会阻塞直到函数运行结束。<strong>如果get或wait没有被调用，函数就绝对不会执行</strong>。<tr><td>launch::async | launch::deferred<td>该功能自动（在某个时候）选择策略。这取决于系统和库的实现，他们通常会针对系统中当前的并发可用性进行优化</table></div><p>看一下细节</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">//? 使用async进行异步</span>

<span class="kt">int</span> <span class="nf">accumulate3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"async begin"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"async end"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"main begin"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">accumulate3</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//ver1</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span> <span class="n">accumulate3</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//ver2</span>
    <span class="n">Sleep</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span> <span class="c1">//睡眠五秒</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"result="</span> <span class="o">&lt;&lt;</span> <span class="n">accumulate_future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"main end"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>ver1 输出：
main begin
async begin
async end
result=21
main end

ver2 输出：
main begin
result=async begin
async end
21
main end
</pre></table></code></div></div><p>调用方式和thread很像，没什么区别。没有花里胡哨的东西。但是注意下细节。</p><ol><li>在async模式中，一旦开始了调用，则会立刻创建子线程开始任务执行。所以我们看到尽管主线程睡眠了一下，但是并不影响异步线程的执行。所以async begin， async end和result=21是可以打印的。因为get的时候任务已经完成（或者是阻塞至任务完成）。<li>在deferred模式中，只有get/wait调用的时候任务才开始执行。所以result=先打印出来，然后直到调用get函数的时候，才开始执行任务，任务执行完毕后结果才能拿到，所以会先打印result=, 然后在调用线程（此处是主线程）中执行函数，拿到结果后打印21。</ol><ul><li><strong>传参的时候如果需要使用只支持移动的参数比如unique_ptr，则必须使用move显式移动。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">testfunc</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">future</span><span class="o">&lt;</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">my_future</span> <span class="o">=</span> <span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">testfunc</span><span class="p">,</span> <span class="n">move</span><span class="p">(</span><span class="n">myptr</span><span class="p">));</span> <span class="c1">//显示使用move转移所有权。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">my_future</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>如果async函数的返回值没有一个东西接住他（显式获取返回值），因为async会创建临时的future对象, 所以这个临时对象的析构函数会阻塞住调用线程直至异步线程执行完毕。因为我们不能让异步线程返回值的时候，这个临时对象已经被销毁了。</strong></ul><p>例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">testfunc</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//睡眠五秒</span>
    <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myptr</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"running"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">testfunc</span><span class="p">,</span> <span class="n">move</span><span class="p">(</span><span class="n">myptr</span><span class="p">));</span> <span class="c1">//卡在这里5秒。因为没有获取返回值。直到任务完成后赋值给临时future对象之后才能执行future临时对象的析构。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"blocked"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码执行的时候，调用线程会由于异步线程没有执行完毕，而且因为没有获取返回值，所以卡在async这行。直到异步线程执行完毕后赋值给临时future对象之后才能执行future临时对象的析构。才会继续输出blocked。</p><ul><li><strong>如果async函数的返回值有<code class="language-plaintext highlighter-rouge">future</code>对象接住他（显式获取返回值），而且没有对<code class="language-plaintext highlighter-rouge">future</code>对象用使用<code class="language-plaintext highlighter-rouge">get</code>来阻塞主线程，因为满足下面的条件，所以主线程依旧会等待异步线程结束。因为该<code class="language-plaintext highlighter-rouge">future</code>对象的析构函数被阻塞了</strong><ul><li>注意：此条件仅限于如下条件为真：<ul><li><code class="language-plaintext highlighter-rouge">future</code>对象以 <code class="language-plaintext highlighter-rouge">std::async</code> 的调用创建，且<strong>共享状态仍未就绪</strong>，且<code class="language-plaintext highlighter-rouge"> this</code> 是到共享状态的最后引用。<ul><li>最后面那个条件原文是：this was the last reference to the shared state. 我的理解其实是：这个<code class="language-plaintext highlighter-rouge">future</code>对象是<code class="language-plaintext highlighter-rouge">async</code>调用创建的那个对象的最后的引用。<ul><li>也就是如果当前的<code class="language-plaintext highlighter-rouge">future</code>对象此时是<code class="language-plaintext highlighter-rouge">async</code>调用创建的那个<code class="language-plaintext highlighter-rouge">future</code>对象，唯一与其有关联的实例。</ul></ul></ul></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">accumulate3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">last</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"async begin"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//异步线程睡眠5秒</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"async end"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">exe</span><span class="p">(){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"exe begin"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">accumulate_future</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">accumulate3</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="c1">//通过async调用创建的future对象，且共享状态仍未就绪，且除了这个future对象以外，没有其他的对共享状态的引用。所以会阻塞。</span>
    <span class="c1">//std::cout &lt;&lt; "result=" &lt;&lt; accumulate_future.get() &lt;&lt; '\n'; 没有对`future`对象用使用`get`来阻塞主线程</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"exe end"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">exe</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
输出：
exe begin
exe end
async begin
(睡眠五秒...)
async end
200
*/</span>
</pre></table></code></div></div><p>我们可以看到，启用了异步线程，并且有<code class="language-plaintext highlighter-rouge">future</code>对象做为返回值，所以没有阻碍临时对象的析构。同时我们没有对<code class="language-plaintext highlighter-rouge">future</code>对象用使用<code class="language-plaintext highlighter-rouge">get</code>来阻塞主线程。但是<strong>虽然exe end被打印，但是因为满足上面的条件，所以该<code class="language-plaintext highlighter-rouge">future</code>对象的析构函数被阻塞了，这个调用线程依旧会被阻塞。所以这个函数的执行没有结束，所以<code class="language-plaintext highlighter-rouge">main</code>函数内的函数调用不会返回。所以调用线程依旧会等待异步线程结束而结束。</strong></p><ul><li><strong>这种阻塞行为可以理解为该future临时对象的析构函数是对底层异步执行任务的线程实施了一次隐式的<code class="language-plaintext highlighter-rouge">join</code></strong> –emc++ 条款38<ul><li>在future的析构函数不被阻塞时（不满足上述条件的时候），可以理解为对底层线程实施了一次隐式的<code class="language-plaintext highlighter-rouge">detach</code>。</ul></ul><h2 id="future-packaged_tast-promise三者的关系"><span class="mr-2">future, packaged_tast, promise三者的关系</span><a href="#future-packaged_tast-promise三者的关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>std::future用于访问异步操作的结果，而std::promise和std::packaged_task包住了future，它们内部都有一个future，promise包装的是一个值，packaged_task包装的是一个函数（异步操作本身），当需要获取线程中的某个值，可以使用std::promise，当需要获取线程函数返回值，可以使用std::packaged_task。</p><p>这三个东西和async都是互相搭配使用的。具体在哪个线程阻塞，哪个线程获取，哪个先哪个后，包括是传引用还是move都是依照情况而定的。</p><ul><li>packaged_task ≈ promise + function<li>async ≈ thread + packaged_task<li>通过promise的get_future()可拿到future<li>通过future的share()可拿到shared_future</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/v2-4ef189e8c5a3473494ab9855002b312d_r.jpg" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/v2-4ef189e8c5a3473494ab9855002b312d_r.jpg" alt="v2-4ef189e8c5a3473494ab9855002b312d_r" class="lazyload" data-proofer-ignore></a></p><p>https://www.zhihu.com/question/547132461/answer/2657296340</p><h2 id="杂项"><span class="mr-2">杂项</span><a href="#杂项" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>std::future提供访问异步操作结果的机制。std::future 只能与指定事件相关联，而 std::shared_future 就能关联多个事件。future对象本身并不提供同步访问（需要使用get/wait)。future的get()函数的设计包含移动语义，即只能调用一次，第二次调用时会报异常。shared_future的get()函数的设计包含复制语义，可以多次调用。std::shared_future对象可以通过std::future对象隐式转换，也可以通过显示调用std::future::share显示转换，在这两种情况下，原std::future对象都将变得无效。<li>当不着急让任务结果时，可以使用 std::async 启动一个异步任务。std::async 会返回一个 std::future 对象。get()等价与先调用wait()再调用get()。 std::launch::defered 表明函数调用延迟到wait()或get()函数调用时才执行，std::launch::async 表明函数必须在其所在的独立线程上执行。<li>std::packaged_task&lt;&gt; 会将future与函数或可调用对象进行绑定。当 std::packaged_task 作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在 std::future 中。<li>std::promise/std::future 对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。<li>任何情况下，当future的状态还不是“就绪”时，调用 std::promise 或 std::packaged_task 的析构函数，将会存储一个与 std::future_errc::broken_promise 错误状态相关的 std::future_error 异常。<ul><li>当调用抛出一个异常时，这个异常就会存储到future中，之后调用get()会抛出已存储的异常。<li>std::current_exception() 来检索抛出的异常，可用 std::copy_exception() 作为替代方案， std::copy_exception() 会直接存储新的异常而不抛出。</ul><li>因为 std::future 是只移动的，所以其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而 std::shared_future 实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。<li>当多线程 在没有额外同步的情况下，访问一个独立的 std::future 对象时，就会有数据竞争和未定义的 行为。这是因为： std::future 模型独享同步结果的所有权，并且通过调用get()函数，一次性 的获取数据，这就让并发访问变的毫无意义——只有一个线程可以获取结果值，因为在第一 次调用get()后，就没有值可以再获取了。<li>在每一个 std::shared_future 的独立对象上成员函数调用返回的结果还是不同步的，所以为 了在多个线程访问一个独立对象时，避免数据竞争，可以使用两种方式：<ul><li>锁<li>每一个线程有自己的shared_future对象，然后都通过自己的这个shared_future对象来获取结果。</ul></ul><h2 id="async-future搭配数组进行多线程accumulate的小例子"><span class="mr-2">async future搭配数组进行多线程accumulate的小例子</span><a href="#async-future搭配数组进行多线程accumulate的小例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">custom_acc</span><span class="p">{</span>
    <span class="kt">int</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//使用自定义累加。注意第一个参数是int。因为是把第二个参数作用域第一个参数上</span>
        <span class="c1">//其次，这里future不要忘记指定模板参数。</span>
        <span class="c1">//第三，这里future对象不可设置为const。因为get参数会更改future的内部状态。所以get不是const函数。const对象不能调用非const函数</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="c1">//使用get取出计算结果。</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">acc_calc</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin_iter</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end_iter</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">begin_iter</span><span class="p">,</span> <span class="n">end_iter</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//这里老规矩。和async解析一样。任务函数。</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">my_vec</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">//要计算的数组</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">my_futures</span><span class="p">;</span> <span class="c1">//装有future对象的数组</span>
    <span class="kt">int</span> <span class="n">curpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">my_futures</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">acc_calc</span><span class="p">,</span> <span class="n">my_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">curpos</span><span class="p">,</span> <span class="n">my_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">curpos</span><span class="o">+</span><span class="mi">200</span><span class="p">));</span>
        <span class="c1">//这里我们在future对象数组内原地构造一个async对象。async对象传入启动方式，任务函数，和函数参数。</span>
        <span class="n">curpos</span><span class="o">+=</span><span class="mi">200</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span><span class="n">my_futures</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">my_futures</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">custom_acc</span><span class="p">());</span> <span class="c1">//这里我们逐个取出future对象数组并使用我们自定义的方法进行累加。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="atomic">atomic</h1><p>https://youtu.be/ZQFzMfHIxng</p><h2 id="无锁编程不一定会让程序更快甚至会有副作用它并不具有加速行为"><span class="mr-2">无锁编程不一定会让程序更快，甚至会有副作用。它并不具有加速行为。</span><a href="#无锁编程不一定会让程序更快甚至会有副作用它并不具有加速行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>无锁编程不保证性能，不保证程序更快。</p><p>证明一个无锁代码的正确性非常难，如果必须使用无锁，最好使用库而不要自己搓轮子。</p><blockquote><p>基本上如果架构没有太大问题，整个系统的瓶颈不会出现在某个锁上，换句话说，出现因为锁的性能瓶颈时大都是因为架构的问题，很多时候根本没必要上lock-free，一般的同步手段完全可以满足我们的需求。但是因为这样我们就可以不了解这个问题吗？我想作为一个IT行业未来的从业者不应该这样想，我们应该很清楚我们的代码经过了哪些变化，指令重排有时会对代码造成影响。</p></blockquote><h2 id="打算使用无锁编程提升性能之前先检查其他部分比如算法"><span class="mr-2">打算使用无锁编程提升性能之前，先检查其他部分，比如算法。</span><a href="#打算使用无锁编程提升性能之前先检查其他部分比如算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h2 id="stdatomic_flag"><span class="mr-2">std::atomic_flag</span><a href="#stdatomic_flag" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">std::atomic_flag</code> 是原子布尔类型。不同于所有 std::atomic 的特化，<strong>它保证是免锁的</strong>。不同于 <code class="language-plaintext highlighter-rouge">std::atomic&lt;bool&gt;</code> ， <code class="language-plaintext highlighter-rouge">std::atomic_flag</code> 不提供加载或存储操作。</p><p><code class="language-plaintext highlighter-rouge">std::atomic_flag</code>是最简单的原子类型，这个类型的对象可以在两个状态间切换：</p><ul><li><p>设置</p><li><p>清除</p></ul><h3 id="默认构造函数"><span class="mr-2">默认构造函数</span><a href="#默认构造函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>构造一个新<code class="language-plaintext highlighter-rouge">std::atomic_flag</code>对象，不过未指明状态。这里未指定默认构造出来的<code class="language-plaintext highlighter-rouge">std::atomic_flag</code>实例是<code class="language-plaintext highlighter-rouge">clear</code>状态，还是<code class="language-plaintext highlighter-rouge">set</code>状态（c++20后默认构造函数初始化的状态为clear）。因为对象存储过程是静态的，所以初始化必须是静态的。<strong><code class="language-plaintext highlighter-rouge">std::atomic_flag</code> 必须使用<code class="language-plaintext highlighter-rouge">ATOMIC_FLAG_INIT</code>进行初始化</strong>，这样构造出来的实例状态为<code class="language-plaintext highlighter-rouge">clear</code>。<strong>另外，<code class="language-plaintext highlighter-rouge">atomic_flag</code>不能被拷贝，也不能 <code class="language-plaintext highlighter-rouge">move</code></strong></p><h3 id="stdatomic_flagtest_and_set"><span class="mr-2">std::atomic_flag::test_and_set</span><a href="#stdatomic_flagtest_and_set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>原子地更改 <code class="language-plaintext highlighter-rouge">std::atomic_flag</code>的状态为设置（ true ）并返回它先前保有的值。</p><h3 id="stdatomic_flagclear"><span class="mr-2">std::atomic_flag::clear</span><a href="#stdatomic_flagclear" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>原子地更改 <code class="language-plaintext highlighter-rouge">std::atomic_flag</code>的状态为清除（ false ）。</p><h3 id="stdatomic_flagwaitnotify_onenotify_all"><span class="mr-2">std::atomic_flag::wait/notify_one/notify_all</span><a href="#stdatomic_flagwaitnotify_onenotify_all" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C++20内容</p><h2 id="stdatomic"><span class="mr-2">std::atomic</span><a href="#stdatomic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">std::atomic</code>模板的每个实例化和专门化都定义了一个原子类型。如果一个线程在另一个线程读取它时写入一个原子对象，那么行为就会被明确定义(参见关于数据竞争的详细信息的内存模型)。此外，对原子对象的访问可以建立线程间的同步，并按照<code class="language-plaintext highlighter-rouge">std::memoryorder</code>指定非原子性的内存访问。</p><ul><li><p><code class="language-plaintext highlighter-rouge">std::atomic</code>可以用任何简单的可复制的<code class="language-plaintext highlighter-rouge">t</code>实例化。同时<code class="language-plaintext highlighter-rouge">std::atomic</code>是<strong>不可复制的，不可移动的。</strong></p><li><p>注意初始化方式只能使用直接初始化。因为拷贝赋值和拷贝构造被禁用且不提供移动构造和移动赋值。<strong>这个初始化方式非原子</strong>。</p><ul><li><strong>c++17后可以使用拷贝初始化。强制使用了复制省略技术。前提是右侧必须是prvalue临时对象</strong><li><code class="language-plaintext highlighter-rouge">atomic</code>不可以使用聚合初始化（aggregate initialization）</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//c++14错误, c++17 OK</span>
<span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></table></code></div></div><li><p>具体特化类型参考https://zh.cppreference.com/w/cpp/atomic/atomic</p><li><p>特化成员函数操作，操作符重载加减之类的不讲了。</p><li><p><strong>注意原子操作没有乘法和除法</strong></p><li>注意带有赋值操作符的时候不能保证整条语句的原子性。<div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//只保证读取a和a+5并且赋值分别是原子的。也就是原子读 + 原子写。不能保证原子读+写。</span>
 <span class="c1">//也就是此时在原子操作：把A读出来 和原子操作：把A+5然后写回A 之间，任何指令都可以插入。</span>
 <span class="c1">//可能存在把A读出来，然后其他操作把A修改为100000，然后A被修改为A+5然后写回。这样的情况。</span>
</pre></table></code></div></div><li><p>c++20前，浮点类型不支持自增操作。</p><li><p>主 <code class="language-plaintext highlighter-rouge">std::atomic</code> 模板可用任何满足<a href="https://zh.cppreference.com/w/cpp/named_req/CopyConstructible"><em>可复制构造</em> <em>(CopyConstructible)</em> </a>及<a href="https://zh.cppreference.com/w/cpp/named_req/CopyAssignable"><em>可复制赋值</em> <em>(CopyAssignable)</em> </a>的<a href="https://zh.cppreference.com/w/cpp/named_req/TriviallyCopyable"><em>可平凡复制</em> <em>(TriviallyCopyable)</em> </a>类型 <code class="language-plaintext highlighter-rouge">T</code> 特化。若下列任何值为 <code class="language-plaintext highlighter-rouge">false</code> 则程序为非良构：</p><ul><li><p><a href="http://zh.cppreference.com/w/cpp/types/is_trivially_copyable">std::is_trivially_copyable</a><T>::value</T></p><li><p><a href="http://zh.cppreference.com/w/cpp/types/is_copy_constructible">std::is_copy_constructible</a><T>::value</T></p><li><p><a href="http://zh.cppreference.com/w/cpp/types/is_move_constructible">std::is_move_constructible</a><T>::value</T></p><li><p><a href="http://zh.cppreference.com/w/cpp/types/is_copy_assignable">std::is_copy_assignable</a><T>::value</T></p><li><p><a href="http://zh.cppreference.com/w/cpp/types/is_move_assignable">std::is_move_assignable</a><T>::value</T></p></ul><li><strong>针对原子对象的操作并不一定全是“原子”的。也就是不一定保证无锁。需要看内存是否对齐了。可以使用<code class="language-plaintext highlighter-rouge">is_lock_free()</code>进行判断针对该原子对象的操作是否是无锁的。详细查看<a href="https://youtu.be/ZQFzMfHIxng?t=1724">这个视频</a></strong></ul><h3 id="stdatomicstore"><span class="mr-2">std::atomic<T>::store</T></span><a href="#stdatomicstore" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">store</span><span class="p">(</span> <span class="n">T</span> <span class="n">desired</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>原子地</strong>以 <code class="language-plaintext highlighter-rouge">val</code> 替换当前值。按照 <code class="language-plaintext highlighter-rouge">order</code> 的值影响内存。<code class="language-plaintext highlighter-rouge">order</code> 必须是 <code class="language-plaintext highlighter-rouge">std::memory_order_relaxed</code> 、 <code class="language-plaintext highlighter-rouge">std::memory_order_release</code> 或 <code class="language-plaintext highlighter-rouge">std::memory_order_seq_cs</code>t 之一。否则行为未定义。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">//次操作在含以上等同于x = y;</span>
</pre></table></code></div></div><h3 id="stdatomicload"><span class="mr-2">std::atomic<T>::load</T></span><a href="#stdatomicload" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">load</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span> <span class="p">)</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><p>原子地加载并返回原子变量的当前值。按照 <code class="language-plaintext highlighter-rouge">order</code> 的值影响内存。</p><p><code class="language-plaintext highlighter-rouge">order</code> 必须是 <code class="language-plaintext highlighter-rouge">std::memory_order_relaxed</code>、 <code class="language-plaintext highlighter-rouge">std::memory_order_consume</code> 、 <code class="language-plaintext highlighter-rouge">std::memory_order_acquire</code> 或 <code class="language-plaintext highlighter-rouge">std::memory_order_seq_cst</code> 之一。否则行为未定义。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">T</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="c1">//此操作在含义上等同于 T y = x;</span>
</pre></table></code></div></div><h3 id="stdatomicoperator"><span class="mr-2">std::atomic<T>::operator=</T></span><a href="#stdatomicoperator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>等于<code class="language-plaintext highlighter-rouge">store() </code>注意用法。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>这个等号不是拷贝赋值的那个等号。</strong></p><h3 id="stdatomicoperator-t"><span class="mr-2">std::atomic<T>::operator T</T></span><a href="#stdatomicoperator-t" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>等于<code class="language-plaintext highlighter-rouge">load()</code></p><h3 id="stdatomicexchange"><span class="mr-2">std::atomic<T>::exchange</T></span><a href="#stdatomicexchange" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">exchange</span><span class="p">(</span> <span class="n">T</span> <span class="n">desired</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span> <span class="p">)</span>
</pre></table></code></div></div><p>原子地以 <code class="language-plaintext highlighter-rouge">desired</code> 替换底层值。操作为读-修改-写操作。根据 <code class="language-plaintext highlighter-rouge">order</code> 的值影响内存。</p><p>返回调用前原子对象的值。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">T</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="n">y</span><span class="p">);</span> <span class="c1">//此操作在含义上等同 z = x; x = y;</span>
</pre></table></code></div></div><h3 id="stdatomiccompare_exchange_weakstrong"><span class="mr-2">std::atomic<T>::compare_exchange_weak/strong</T></span><a href="#stdatomiccompare_exchange_weakstrong" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>上面的exchange只是原子交换。但是这个就是著名的CAS</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">compare_exchange_weak</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">expected</span><span class="p">,</span> <span class="n">T</span> <span class="n">desired</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">success</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">failure</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">compare_exchange_strong</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">expected</span><span class="p">,</span> <span class="n">T</span> <span class="n">desired</span><span class="p">,</span>
                              <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">success</span><span class="p">,</span>
                              <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">failure</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>原子地比较 <code class="language-plaintext highlighter-rouge">*this</code> 和<code class="language-plaintext highlighter-rouge"> expected</code> 的对象表示，而若它们逐位相等，则以 <code class="language-plaintext highlighter-rouge">desired</code> 替换前者（进行读修改写操作）。否则，将 <code class="language-plaintext highlighter-rouge">*this</code> 中的实际值加载进 <code class="language-plaintext highlighter-rouge">expected</code> （进行加载操作）<ul><li>若成功更改底层原子值则返回 <code class="language-plaintext highlighter-rouge">true</code> ，否则为<code class="language-plaintext highlighter-rouge"> false</code> 。</ul><li><p><strong>归纳一下这个函数的使用要点：</strong></p><ul><li>当前值与期望值<strong>(expect)</strong>相等时，修改当前值为设定值<strong>(desired)</strong>，返回<code class="language-plaintext highlighter-rouge">true</code><li>当前值与期望值<strong>(expect)</strong>不等时，将期望值<strong>(expect)</strong>修改为当前值，返回<code class="language-plaintext highlighter-rouge">false</code><ul><li>这一行非常关键。如果当前值和期望值不相等，会修改期望值而不是修改当前值。所以下面我们实现简单的自旋锁的时候必须要搭配<code class="language-plaintext highlighter-rouge">while</code>，而且<code class="language-plaintext highlighter-rouge">while</code>内需要把值改回去。</ul><li>这个函数可能在满足<code class="language-plaintext highlighter-rouge">true</code>的情况下仍然返回<code class="language-plaintext highlighter-rouge">false</code>，所以只能在循环里使用，否则可以使用它的strong版本<ul><li><strong>weak版和strong版的区别：</strong><ul><li>weak版本的CAS允许偶然出乎意料的返回（比如在当前值和期待值一样的时候却返回了false），不过在一些循环算法中，这是可以接受的。通常它比起strong有更高的性能。<li>如果此事偶然发生，可以对期望值(expect)进行检查。期望值应该不会改变。<li>用人话说就是<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code> 有可能在当前值与 <code class="language-plaintext highlighter-rouge">expected</code> 相等时仍然不执行交换并返回 <code class="language-plaintext highlighter-rouge">false</code>; <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code> 则不会有这个问题. weak 版本能让编译器在一些平台下生成一些更优的代码, 在 x86 下是没区别的.</ul></ul></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
<span class="c1">//此操作含义为：</span>
<span class="c1">//如果x == y, 则让 x = z 并且返回true</span>
<span class="c1">//如果x != y, 则让 y = x 并且返回false</span>
</pre></table></code></div></div><p>有没有注意到为啥这个函数有俩<code class="language-plaintext highlighter-rouge">memory_order</code>?</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230116025214.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230116025214.png" alt="QQ截图20230116025214" class="lazyload" data-proofer-ignore></a></p><p>为了支持指定两个内存顺序: 成功时的内存顺序和失败时的内存顺序. 一个用于读取一个用于写入</p><p>在 x86 下 <code class="language-plaintext highlighter-rouge">compare_exchange_*</code> 会被编译成一条 <code class="language-plaintext highlighter-rouge">cmpxchgl</code> 指令, 因此操作是原子且无锁的.</p><p>https://blog.csdn.net/feikudai8460/article/details/107035480</p><p>https://luyuhuang.tech/2022/10/30/lock-free-queue.html</p><h3 id="额外说一下fetch系列操作这里就说一下fetch_add"><span class="mr-2">额外说一下fetch系列操作。这里就说一下fetch_add</span><a href="#额外说一下fetch系列操作这里就说一下fetch_add" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>指针特化的fetch_add在下面。这里针对普通类型。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">T</span> <span class="n">fetch_add</span><span class="p">(</span> <span class="n">T</span> <span class="n">arg</span><span class="p">,</span>
             <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>原子地以值和 <code class="language-plaintext highlighter-rouge">arg</code> 的算术加法结果替换当前值。运算是读修改写操作。按照 <code class="language-plaintext highlighter-rouge">order</code> 的值影响内存。<li>其实就是 <code class="language-plaintext highlighter-rouge">+=</code><li><strong>但是返回值是原值！！！！！！</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span> <span class="c1">//z = x; x += y。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//z是x修改前的值。200</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//x是220</span>
</pre></table></code></div></div><h2 id="stdatomict特化"><span class="mr-2">std::atomic&lt;T*&gt;特化</span><a href="#stdatomict特化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>针对指针类型的特化，代表指针指向的对象<strong>不是</strong>原子的。<strong>而是</strong>代表这个指针本身是原子的。<li>同样不可拷贝构造和拷贝赋值。<li>但是他可以通过合适的指针类型（不一定非得是原子的）进行构造和赋值。</ul><h2 id="针对指针特化类型的特殊操作"><span class="mr-2">针对指针特化类型的特殊操作</span><a href="#针对指针特化类型的特殊操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>特化的函数这里主要简单介绍<code class="language-plaintext highlighter-rouge">fetch_add</code>, <code class="language-plaintext highlighter-rouge">fetch_sub</code>, <code class="language-plaintext highlighter-rouge">operator++</code>, <code class="language-plaintext highlighter-rouge">operator--</code></p><p>自增自减没啥好说的。这里就举个<code class="language-plaintext highlighter-rouge">fetch_add</code>的例子</p><ul><li><p><code class="language-plaintext highlighter-rouge">fetch_add</code></p><ul><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">T</span><span class="o">*</span> <span class="n">fetch_add</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span> <span class="n">arg</span><span class="p">,</span>
              <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span> <span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</pre></table></code></div></div><li><p>原子地以值和 <code class="language-plaintext highlighter-rouge">arg</code> 的算术加法结果替换当前值。运算是读修改写操作。按照 <code class="language-plaintext highlighter-rouge">order</code> 的值影响内存。</p><li>其实就是<code class="language-plaintext highlighter-rouge">+=</code>操作。注意这个加法是指针加法。</ul></ul><h3 id="stdatomicwaitnotify_onenotify_all"><span class="mr-2">std::atomic<T>::wait/notify_one/notify_all</T></span><a href="#stdatomicwaitnotify_onenotify_all" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C++20内容</p><h2 id="atomic-支持操作总结"><span class="mr-2">atomic 支持操作总结</span><a href="#atomic-支持操作总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th style="text-align: center">操作<th><code class="language-plaintext highlighter-rouge">atomic_flag</code><th style="text-align: center"><code class="language-plaintext highlighter-rouge">atomic&lt;bool&gt;</code><th style="text-align: center"><code class="language-plaintext highlighter-rouge">atomic&lt;T*&gt;</code><th style="text-align: center"><code class="language-plaintext highlighter-rouge">atomic&lt;integral_type&gt;</code><th style="text-align: center"><code class="language-plaintext highlighter-rouge">atomic&lt;other_type&gt;</code><tbody><tr><td style="text-align: center">test_and_set<td>✓<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">clear<td>✓<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center"> <tr><td style="text-align: center">is_lock_free<td> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<tr><td style="text-align: center">load<td> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<tr><td style="text-align: center">store<td> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<tr><td style="text-align: center">exchange<td> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<tr><td style="text-align: center">compare_exchange_weak/strong<td> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center">✓<tr><td style="text-align: center">fetch_add, +=<td> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center"> <tr><td style="text-align: center">fetch_sub, -=<td> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center"> <tr><td style="text-align: center">fetch_or, |=<td> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center"> <tr><td style="text-align: center">fetch_and, &amp;=<td> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center"> <tr><td style="text-align: center">fetch_xor, ^=<td> <td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center"> <tr><td style="text-align: center">++,–<td> <td style="text-align: center"> <td style="text-align: center">✓<td style="text-align: center">✓<td style="text-align: center"> </table></div><ul><li>关于用户定义类型，有非常严格要求。建议去官方文档看。</ul><h1 id="修改顺序-指令重排缓存一致性内存屏障和内存模型">修改顺序, 指令重排，缓存一致性，内存屏障和内存模型</h1><h2 id="修改顺序"><span class="mr-2">修改顺序</span><a href="#修改顺序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对一个原子变量的所有修改操作总是存在一定的先后顺序, 且所有线程都认可这个顺序, 即使这些修改操作是在不同的线程中执行的. 这个所有线程一致同意的顺序就称为<strong>修改顺序 (modification order)</strong>. 这意味着</p><ul><li>两个修改操作不可能同时进行, 一定存在一个先后顺序. 这很容易理解, 因为这是原子操作必须保证的, 否则就有数据竞争的问题.<li>即使每次运行的修改顺序可能都不同, 但所有线程看到的修改顺序总是一致的. 如果线程 a 看到原子变量 x 由 1 变成 2, 那么线程 b 就不可能看到 x 由 2 变成 1.</ul><p>无论使用哪种内存顺序, 原子变量的操作总能满足修改顺序一致性, 即使是最松散的 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>. 我们来看一个例子</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">a</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">a</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread3</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread4</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread1</span><span class="p">),</span> <span class="n">t2</span><span class="p">(</span><span class="n">thread2</span><span class="p">),</span> <span class="n">t3</span><span class="p">(</span><span class="n">thread3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v3</span><span class="p">),</span> <span class="n">t4</span><span class="p">(</span><span class="n">thread4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v4</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v3</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v4</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的代码创建了 4 个线程. <code class="language-plaintext highlighter-rouge">thread1</code> 和 <code class="language-plaintext highlighter-rouge">thread2</code> 分别将偶数和奇数依次写入原子变量 <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">thread3</code> 和 <code class="language-plaintext highlighter-rouge">thread4</code> 则读取它们. 最后输出 <code class="language-plaintext highlighter-rouge">thread3</code> 和 <code class="language-plaintext highlighter-rouge">thread4</code> 每次读取到的值. 程序运行的结果可能是这样的</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>1 8 7 7 7 9 9 9 9 9
0 2 8 8 8 7 9 9 9 9
-------------------
1 2 5 6 9 9 9 8 8 8
1 3 2 5 9 8 8 8 8 8
</pre></table></code></div></div><p>虽然每次运行的修改顺序不同, 各个线程也不太可能看到每次修改的结果, 但是它们看到的修改顺序是一致的. 例如 <code class="language-plaintext highlighter-rouge">thread3</code> 看到的顺序是 8 7 9, 那么<code class="language-plaintext highlighter-rouge">thread4</code>看到的顺序也是8 7 9. <code class="language-plaintext highlighter-rouge">thread3</code>看到的顺序是1 5 9 8 那么 <code class="language-plaintext highlighter-rouge">thread4</code>看到的顺序一样是1 5 9 8</p><h2 id="指令重排"><span class="mr-2">指令重排</span><a href="#指令重排" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="happens-before-关系"><span class="mr-2">Happens-Before 关系</span><a href="#happens-before-关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>A、B 是两个在多核 CPU 上执行的操作。如果 A <strong>happens-before</strong> B，那么 A 所产生的内存变化会在 B 操作执行之前被看到（visible）。</p></blockquote><p>简而言之, 如果操作 a “happens-before” 操作 b, 则操作 a 的结果对于操作 b 可见. happens-before 的关系可以建立在用一个线程的两个操作之间, 也可以建立在不同的线程的两个操作之间.</p><p>不管我们使用什么编程语言，在同一个线程下的顺序语句总是遵循 happens-before 原则的。</p><p>就像下面代码所示：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在单线程的情况下，断言是永远不会为假的。（不然这还怎么写程序…）</p><p>但这并不代表 b 在内存中后于 a 被修改。就像下面这段伪代码所示的：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>mov %eax, 42
mov (b), %eax
mov (a), %eax
</pre></table></code></div></div><p>虽然这并不能说明编译器就是这么处理的，但足以说明程序语义上的 happens-before 不能代表操作是真的 happened before 了。</p><h4 id="happens-before-的第一种场景-sequenced-before单线程"><span class="mr-2">Happens-before 的第一种场景: sequenced before(单线程)</span><a href="#happens-before-的第一种场景-sequenced-before单线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>单线程的情况很容易理解. 函数的语句按顺序依次执行, 前面的语句先执行, 后面的后执行. 正式地说, 前面的语句总是 <strong>“sequenced-before”</strong> 后面的语句. 显然, 根据定义, sequenced-before 具有传递性:</p><ul><li>如果操作 <code class="language-plaintext highlighter-rouge">a</code> “sequenced-before” 操作 <code class="language-plaintext highlighter-rouge">k</code>, 且操作 <code class="language-plaintext highlighter-rouge">k</code> “sequenced-before” 操作 <code class="language-plaintext highlighter-rouge">b</code>, 则操作 <code class="language-plaintext highlighter-rouge">a</code> “sequenced-before” 操作 <code class="language-plaintext highlighter-rouge">b</code>.</ul><p>Sequenced-before 可以直接构成 happens-before 的关系. 如果操作 <code class="language-plaintext highlighter-rouge">a</code> “sequenced-before” 操作 <code class="language-plaintext highlighter-rouge">b</code>, 则操作 <code class="language-plaintext highlighter-rouge">a</code> “happens-before” 操作 <code class="language-plaintext highlighter-rouge">b</code>. 这是最基本的场景:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// (1)</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// (2)</span>
</pre></table></code></div></div><p>语句 (1) 在语句 (2) 的前面, 因此语句 (1) “sequenced-before” 语句 (2), 也就是 (1) “happens-before” 语句 (2). 所以 (2) 可以打印出 (1) 赋值的结果且没有任何问题</p><h4 id="happens-before-的第二种场景-synchronizes-with-和-inter-thread-happens-before多线程"><span class="mr-2">Happens-before 的第二种场景: synchronizes-with 和 inter-thread happens-before(多线程)</span><a href="#happens-before-的第二种场景-synchronizes-with-和-inter-thread-happens-before多线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一般来说, 如果在多个线程间没有正确的同步操作, 就无法保证两个操作之间有 <strong>happens-before</strong> 的关系. 如果我们通过一些手段, 让不同线程的两个操作同步, 我们称这两个操作之间有 <strong>synchronizes-with</strong> 的关系. 稍后我们会详细讨论如何组合使用 6 种内存顺序, 让两个操作达成 synchronizes-with 的关系.</p><p>如果线程 1 中的操作 <code class="language-plaintext highlighter-rouge">a</code> “synchronizes-with” 线程 2 中的操作 <code class="language-plaintext highlighter-rouge">b</code>, 则操作 <code class="language-plaintext highlighter-rouge">a</code> <strong>“inter-thread happens-before”</strong> 操作<code class="language-plaintext highlighter-rouge">b</code>. 此外 synchronizes-with 还可以 “后接” 一个 sequenced-before 关系组合成 inter-thread happens-before 的关系:</p><ul><li>如果操作 a “synchronizes-with” 操作 k, 且操作 k “sequenced-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</ul><p>Inter-thread happens-before 关系则可以 “前接” 一个 sequenced-before 关系以延伸它的范围; 而且 inter-thread happens-before 关系具有传递性:</p><ul><li>如果操作 a “sequenced-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.<li>如果操作 a “inter-thread happens-before” 操作 k, 且操作 k “inter-thread happens-before” 操作 b, 则操作 a “inter-thread happens-before” 操作 b.</ul><p>正如它的名字暗示的, 如果操作 a “inter-thread happens-before” 操作 b, 则操作 a “happens-before” 操作 b. 下图展示了这几个概念之间的关系:</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/image-20240610001317806.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/image-20240610001317806.png" alt="image-20240610001317806" class="lazyload" data-proofer-ignore></a></p><p>注意, 虽然 sequenced-before 和 inter-thread happens-before 都有传递性, 但是 <strong>happens-before 没有传递性</strong>.</p><p>例子1：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">flag</span> <span class="p">{</span> <span class="nb">false</span> <span class="p">};</span>

<span class="c1">// Execute in thread A</span>
<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>  <span class="c1">// (1)</span>
    <span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="c1">// Execute in thread B</span>
<span class="kt">void</span> <span class="nf">consume</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>  <span class="c1">// (3)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>  <span class="c1">// (4)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>让两个函数分别在两个线程中运行，(4) 所示的断言将有一定几率 为假，这是为什么呢？虽然我们使用原子量 flag 作为“同步信号”，而且同一个线程中 happens-before 原则也一定会被遵循，但我们并不能保证 (4) 执行时 (1) 的修改一定会被 B 线程看到, 可能是2-3-4-1这个顺序。这<strong>是由于现代处理器对于程序可能会采取指令重排来提高运行效率，CPU 的读写 Cache 也可能并没有写回内存。</strong></p><p>所以，企图在多线程环境中通过某原子量来做非原子量的 Synchronization 并不是可靠的（当没有 Memory Order 的约束时候）。</p><p><strong>当然，上面的代码其实基本上不会为假，因为 C++ 默认使用 memory_order_seq_cst顺序约束。而且 x86 架构中也做不到松弛（memory_order_relaxed）内存模型。也就是说，这种过于松弛的模型理论上存在，但其实不会发生。因为如果允许这个级别的松弛那么代码没法写了。</strong></p><p>例子2, <strong>假设下面的代码中 <code class="language-plaintext highlighter-rouge">unlock()</code> 操作 “synchronizes-with” <code class="language-plaintext highlighter-rouge">lock()</code> 操作</strong>:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// (1)</span>
    <span class="n">unlock</span><span class="p">();</span> <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">();</span> <span class="c1">// (3)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// (4)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>假设直到 <code class="language-plaintext highlighter-rouge">thread1</code> 执行到 (2) 之前, <code class="language-plaintext highlighter-rouge">thread2</code> 都会阻塞在 (3) 处的 <code class="language-plaintext highlighter-rouge">lock()</code> 中. 那么可以推导出:</p><ul><li>根据语句顺序, 有 (1) “sequenced-before” (2) 且 (3) “sequenced-before” (4);<li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);<li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4); 所以 (1) “happens-before” (4).</ul><p>因此 (4) 可以读到 (1) 对变量 <code class="language-plaintext highlighter-rouge">a</code> 的修改</p><p><strong>在上面的例子中，我们主要讲述的是指令重排。但是内存屏障不仅仅是为了防止指令重排，也会解决缓存一致性问题。在最后我们会详细探讨这其中的关系。</strong></p><h2 id="缓存一致性"><span class="mr-2">缓存一致性</span><a href="#缓存一致性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们都知道二维数组横向遍历比纵向遍历要快。为什么？</p><ul><li>我们知道有L1 L2 L3三级cache。然后才是内存。CPU需要把内存里的数据读到cache中。但是CPU为了最大化利用cache line的能力，一般会读取一个固定大小的数据区块。一般来说 L3 Cache 比 L1 Cache 和 L2 Cache 大很多，这是因为 <strong>L1 Cache 和 L2 Cache 都是每个 CPU 核心独有的，而 L3 Cache 是多个 CPU 核心共享的。</strong></ul><p>这也就是为什么连续内存操作会比较快，也是为什么内存对齐十分重要。因为如果起点在奇数位就会有二次操作。</p><p><strong>CPU cache到内存的映射有三种：</strong></p><ul><li>直接映射<ul><li>直接映射通俗易懂。就是内存地址映射到的cache line是固定的。比较好找。但是问题在于这个数量非常少。如果多个数据抢占同一个cache line，就会发生cache频繁的换入换出。</ul><li>全相连映射<ul><li>全相连映射的意思是任意一个内存地址可以映射到任意一个cache line。也就是见缝插针。问题在于在寻找一个内存地址是否已被映射的时候，需要遍历每一个cacheline</ul><li>组相连映射<ul><li>组相连映射也就是组间采用直接映射，组内采用全相连映射。</ul></ul><h3 id="cpu-cache读取过程"><span class="mr-2">CPU cache读取过程</span><a href="#cpu-cache读取过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假设我们的L1 Cache Line是64字节：</p><p>比如，有一个 <code class="language-plaintext highlighter-rouge">int array[100]</code> 的数组，当载入 <code class="language-plaintext highlighter-rouge">array[0]</code> 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会<strong>顺序加载</strong>数组元素到 <code class="language-plaintext highlighter-rouge">array[15]</code>，意味着 <code class="language-plaintext highlighter-rouge">array[0]~array[15]</code> 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。</p><p><strong>事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。</strong></p><p>我们刚提到过直接映射会把内存的固定地址映射到固定的cache line。一般来说是通过取模运算来确定的。所以会存在多个内存区块映射到同一个cache line位置上。这时候就要区分他们了。为了区别不同的内存块，在对应的 CPU Line 中我们还会存储一个<strong>组标记（Tag）</strong>。这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。</p><p>除了组标记信息外，CPU Line 还有两个信息：</p><ul><li>一个是，从内存加载过来的实际存放<strong>数据（Data）</strong>。<li>另一个是，<strong>有效位（Valid bit）</strong>，它是用来标记对应的 CPU Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。</ul><p>CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<strong>字（*Word*）</strong>。那怎么在对应的 CPU Line 中数据块中找到所需的字呢？答案是，需要一个<strong>偏移量（Offset）</strong>。</p><p>因此，一个内存的访问地址，包括<strong>组标记、CPU Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114224502.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114224502.png" alt="QQ截图20230114224502" class="lazyload" data-proofer-ignore></a></p><p>如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：</p><ol><li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址；<li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；<li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；<li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</ol><p>问题在于，我们并不是只读数据。我们还会写入。<strong>那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。</strong></p><p>问题来了，那在什么时机才把 Cache 中的数据写回到内存呢？为了应对这个问题，下面介绍两种针对写入数据的方法：</p><ul><li><p>写直达（<em>Write Through</em>）</p><ul><li><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（*Write Through*）</strong>。</p><li><p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p><ul><li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</ul><p>写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p></ul><li><p>写回（<em>Write Back</em>）</p><ul><li>既然写直达由于每次写操作都会把数据写回到内存，而导致影响性能，于是为了要减少数据写回内存的频率，就出现了<strong>写回（*Write Back*）的方法</strong>。<li>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。<li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；<li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。</ul><p>可以发现写回这个方法，在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p><p>这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p></ul><p>现在有一个问题。我们东西确实是写入L1/L2 cache了。但是L1/L2 cache是每个核心独有的。也就是说，有可能在一个核心修改完数据后，修改的数据还在自己的缓存里。另一个核心从自己的缓存里读就会读到没有修改过的值。</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114224941.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114224941.png" alt="QQ截图20230114224941" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>这里的意思是有可能r2 = 0 且 r4 = 0。为什么？</strong><ul><li><strong>我们可能会回答指令重排。但是X86是不允许写-写重排的。所以导致这个情况的就是我们本节的缓存一致性。</strong><li>但是具体原因是什么呢？我们先看看MESI协议。</ul></ul><p><strong>那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：</strong></p><ul><li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（*Wreite Propagation*）</strong>；<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（*Transaction Serialization*）</strong>。</ul><p>第一点写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。而对于第二点事务事的串形化，我们举个例子来理解它。：</p><ul><li>假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量<code class="language-plaintext highlighter-rouge"> i</code>（初始值为 0 ）。A 号核心先把 <code class="language-plaintext highlighter-rouge">i </code>值变为 <code class="language-plaintext highlighter-rouge">100</code>，而此时同一时间，B 号核心先把 <code class="language-plaintext highlighter-rouge">i </code>值变为 <code class="language-plaintext highlighter-rouge">200</code>，这里两个修改，都会「传播」到 C 和 D 号核心。</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114225424.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114225424.png" alt="QQ截图20230114225424" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114225429.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114225429.png" alt="QQ截图20230114225429" class="lazyload" data-proofer-ignore></a></p><p>那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量<code class="language-plaintext highlighter-rouge"> i</code> 是先变成<code class="language-plaintext highlighter-rouge"> 100</code>，后变成<code class="language-plaintext highlighter-rouge"> 200</code>。</p><p>而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量<code class="language-plaintext highlighter-rouge"> i </code>先变成<code class="language-plaintext highlighter-rouge"> 200</code>，再变成 <code class="language-plaintext highlighter-rouge">100</code>，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。</p><p>所以，我们要保证 C 号核心和 D 号核心都能看到<strong>相同顺序的数据变化</strong>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串形化。</p><p>要实现事务串形化，要做到 2 点：</p><ul><li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；<li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</ul><h2 id="mesi-协议"><span class="mr-2">MESI 协议</span><a href="#mesi-协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：</p><ul><li><em>Modified</em>，已修改<li><em>Exclusive</em>，独占<li><em>Shared</em>，共享<li><em>Invalidated</em>，已失效</ul><p>这四个状态来标记 Cache Line 四个不同的状态。</p><ul><li>「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。<li>「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。<li>「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。<ul><li>「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。<li>另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。</ul><li>那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。</ul><p>我们举个具体的例子来看看这四个状态的转换：</p><ol><li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；<li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；<li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。<li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。<li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</ol><p><strong>说完了MESI协议，回到我们Example 8.5的那张图。具体缓存一致性在哪儿出问题了？</strong></p><p>假设在cache line中状态为<code class="language-plaintext highlighter-rouge">共享</code>，在某个核更新数据时候会向总线发送<code class="language-plaintext highlighter-rouge">已失效</code>消息以获取数据的所有权，其他消息得到此消息后更新相应cache line状态为<code class="language-plaintext highlighter-rouge">已失效</code>，并回复<code class="language-plaintext highlighter-rouge">Invalidate Acknowledge</code>消息。显然我们可以看到这个过程非常的繁琐，如果每个操作生效前都需要这么多操作那也太低效了，所以引入了<code class="language-plaintext highlighter-rouge">Invaildate queue</code>和<code class="language-plaintext highlighter-rouge">Store Buffer</code>，为的就是异步执行指令，提高以上过程的效率。</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114230210.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114230210.png" alt="QQ截图20230114230210" class="lazyload" data-proofer-ignore></a></p><p>因为写入到<code class="language-plaintext highlighter-rouge">Invaildate queue</code>和<code class="language-plaintext highlighter-rouge">Store Buffer</code>的数据并不会被立即执行。在执行写操作的核会把数据写入<code class="language-plaintext highlighter-rouge">store buffer</code>，后面<strong>异步的刷新</strong>到cache line，当然也会广播失效消息。而当另一个执行读操作的核收到这个失效消息时，会把消息写入自身的<code class="language-plaintext highlighter-rouge">Invalidate Queue</code>中，随后<strong>异步</strong>将cache line设为<code class="language-plaintext highlighter-rouge">失效</code>状态。写操作的核在读取的时候会扫描<code class="language-plaintext highlighter-rouge">store buffer</code>，而这个执行读操作的核在读取数据的时候并不会扫描<code class="language-plaintext highlighter-rouge">Invaildate queue</code>，<strong>这意味着读操作可能会在一段时间内读到老旧数据。</strong></p><p>首先process 0和process 1把<code class="language-plaintext highlighter-rouge">1</code>放入到地址<code class="language-plaintext highlighter-rouge">_x</code>和<code class="language-plaintext highlighter-rouge">_y</code>的内存上，但是此时可能这些数据还存在自己的<code class="language-plaintext highlighter-rouge">store buffer</code>中，也就是对方都还没意识到数据已经发生修改，然后执行操作<code class="language-plaintext highlighter-rouge">r2</code>和<code class="language-plaintext highlighter-rouge">r4</code>的操作，此时就发生脏读，导致 <code class="language-plaintext highlighter-rouge">r2 = 0</code> 且<code class="language-plaintext highlighter-rouge"> r4 = 0</code>这种奇怪的事情发生。</p><ul><li>也就是在processor 1把<code class="language-plaintext highlighter-rouge">y</code>的值更改为<code class="language-plaintext highlighter-rouge">1</code>的时候，并没有直接写入内存。此时在<code class="language-plaintext highlighter-rouge">processor 0</code>眼里<code class="language-plaintext highlighter-rouge">y</code>还是<code class="language-plaintext highlighter-rouge">0</code>。所以<code class="language-plaintext highlighter-rouge">r2</code>就是<code class="language-plaintext highlighter-rouge">0</code></ul><p>https://mp.weixin.qq.com/s/Sz7QXx1h4sS7xWRUSP4ZCw</p><h2 id="内存屏障"><span class="mr-2">内存屏障</span><a href="#内存屏障" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>经过上面的总结，我们可以得出结论。内存屏障存在的意义是在一定程度上避免缓存一致性所带来的问题和指令重排。</strong></p><p>在广义角度上，Intel有三种内存模型：</p><blockquote><p>SFENCE，LFENCE和MFENCE指令提供了一种性能高效的方式，可确保在产生弱排序结果的例程和使用该数据的例程之间load和store内存排序。 这些指令的功能如下：</p></blockquote><ul><li>SFENCE：序列化(动词，理解为串行化) 程序指令流中，在SFENCE指令之前发生的所有 store（写）操作，但不影响 load（读）操作。<li>LFENCE：序列化 程序指令流中，在LFENCE指令之前发生的所有 load（读）操作，但不影响 store（写）操作。<li>MFENCE：序列化 程序指令流中，在MFENCE指令之前发生的所有 store 和 load 操作。</ul><p>当然，还有一些其他操作含有内存屏障的作用</p><blockquote><ul><li>总线上的内存映射设备和其他I / O设备通常对其I / O缓冲区的写入顺序敏感。可以使用I / O指令（IN和OUT指令）对此类访问施加强的写入顺序，如下所示。在执行I / O指令之前，处理器将等待程序中所有先前的指令完成，并等待所有缓冲的写入操作耗尽到内存。只有指令提取和页表遍历可以传递I / O指令。直到处理器确定I / O指令已完成，后续指令的执行才开始。<li><strong>多处理器系统中的同步机制可能取决于强大的内存排序模型。在这里，程序可以使用诸如<code class="language-plaintext highlighter-rouge">XCHG</code>指令或<code class="language-plaintext highlighter-rouge">LOCK</code>前缀之类的锁定指令，以确保原子地执行对存储器的读-修改-写操作。锁定操作通常类似于I / O操作，因为它们等待所有先前的指令完成并且等待所有缓冲的写操作排入内存。</strong><li>程序同步也可以通过序列化指令执行（请参见第8.3节）。这些指令通常用于关键过程或任务边界，以在跳到新的代码段或上下文切换之前强制完成所有先前的指令。像I / O和锁定指令一样，处理器在执行序列化指令之前要等到所有先前的指令都已完成并且所有缓冲的写操作都已排入内存为止。</ul><p>请注意，与CPUID指令相比，SFENCE，LFENCE和MFENCE指令提供了一种更有效的控制内存顺序的方法。</p></blockquote><p>从上面，我们可以看出：<strong>内存屏障，带Lock或XCHG前缀的指令，I/O操作都会把数据载入内存，自然就不存在前面我们提到的脏读问题了。</strong></p><p>我们一直以来提到的指令重排指的是运行时排序。编译器也会导致指令重排。这里更多的讨论见<a href="https://blog.51cto.com/u_15703183/5464436">这里</a></p><h2 id="内存模型内存序"><span class="mr-2">内存模型（内存序）</span><a href="#内存模型内存序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><strong>我们前面提到了程序运行时的指令重排，内存模型其实规定的就是这些指令的重排哪些排列顺序是正确的，也就是指明在特定要求下，哪些是可以出现的，哪些是不可以出现的。</strong></p><p>事实上对于内存模型的描述我们可以从两个方面来看，一个是硬件角度的内存模型，也就是厂商给我们提供了怎样的一种一致性保证；还有一种是软件级别的内存模型，其实说直白一点就是一些高级语言给程序员提供的一致性保证，显然此时我们可以不必费尽心机去考虑代码如何适配不同的机器。</p><p>比如X86的强模型和ARM的弱模型，如果仅仅依靠硬件提供的内存屏障这个代码将非常难写， 因为不同硬件本身的提供的内存模型是不一样的，甚至有时操作也不相同。但是如果基于软件级别的内存模型，比如使用C++的内存模型（手段为内存序），那么编译器就会帮我们自动去适配不同的机器，因为这是语言保证的。</p><blockquote><p>英特尔酷睿2双核，英特尔凌动，英特尔酷睿双核，奔腾4和P6家族处理器还使用处理器排序的内存排序模型，该模型可以进一步定义为“使用存储缓冲区转发进行写入排序”。 该模型的特征如下。 在用于定义为WB的内存区域的单处理器系统中，内存排序模型遵循以下原则（请注意，单处理器和多处理器系统的内存排序原则是从在以下环境中执行软件的角度编写的。其中术语“处理器”是指逻辑处理器。例如，支持多核和/或Intel超线程技术的物理处理器被视为多处理器系统。）</p><ul><li><p>读操作之间无法排序</p><li><p>写操作不能和旧的读操作之间排序</p><li><p>写操作与写操作之间除了以下情况以外不能重新排序：</p><ul><li><p>带有non-temporal move指令的流存储（写入）（MOVNTI, MOVNTQ, MOVNTDQ, MOVNTPS, 和 MOVNTPD）</p><li><p>串操作</p></ul><li>执行CLFLUSH指令不能重新排序对存储器的写操作。 可以通过执行CLFLUSHOPT指令的执行来重新排序写操作，该指令将刷新除正在写入的高速缓存行以外的其他高速缓存行。 CLFLUSH指令的执行不会相互重新排序。 访问不同缓存行的CLFLUSHOPT的执行可能会相互重新排序。 CLFLUSHOPT的执行可以与访问不同缓存行的CLFLUSH的执行重新排序。<li>读取可能会与不同地址的较旧写入重新排序，但对不同地址的较旧写入则不会重新排序。（store load重排）<li><strong>读写操作不能与IO操作，带LOCK的指令，序列化指令重排序。</strong>（上面曾提到过这个问题）<li>读操作不能越过前面的LFENCE和MFENCE操作<li>写操作和CLFLUSH和CLFLUSHOPT的执行不能越过前面的LFENCE，SFENCE和MFENCE指令。<li>LFENCE不能越过前面的读操作<li>SFENCE不能越过前面的写操作<li>MFENCE不能越过前面的读写操作以及CLFLUSH和CLFLUSHOPT的执行。</ul></blockquote><p>https://zhuanlan.zhihu.com/p/269221065?utm_id=0</p><p>https://blog.51cto.com/u_15703183/5464436</p><p>https://blog.csdn.net/qq_22642239/article/details/114022306</p><p>https://redrain.blog.csdn.net/article/details/111327141</p><h2 id="c中的内存序-三四种模型和六种枚举值"><span class="mr-2">C++中的内存序—-三（四）种模型和六种枚举值</span><a href="#c中的内存序-三四种模型和六种枚举值" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p><code class="language-plaintext highlighter-rouge">std::memory_order</code> 指定内存访问，包括常规的非原子内存访问，<strong>如何围绕原子操作排序</strong>。在没有任何制约的多处理器系统上，多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。其实，更改的顺序甚至能在多个读取线程间相异。一些类似的效果还能在单处理器系统上出现，因为内存模型允许编译器变换。</p></blockquote><p>注意，其实内存序并不能简单描述成为禁止某某操作排到某某操作后面。因为就算单纯禁止重排，也有可能发生我们提过的缓存一致性问题。所以说，应该用可见性这个词。可见性这个词包含了描述重排和缓存一致性的情况。所以说，我们说某某操作现在是可见的，表明了确实我们保证操作正确。也就是不仅正确处理了重排，也正确处理了缓存一致性问题。</p><h3 id="顺序一致sequentially-consistent-ordering"><span class="mr-2">顺序一致（sequentially consistent ordering）</span><a href="#顺序一致sequentially-consistent-ordering" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="memory_order_seq_cst"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code></span><a href="#memory_order_seq_cst" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>C++使用这个做为操作原子变量的默认值。可以直接看文档。</strong></p><ul><li>Load/store/RMW操作都可以使用该枚举值，用于 <code class="language-plaintext highlighter-rouge">load operation</code>（原子读操作）的时候有<code class="language-plaintext highlighter-rouge">acquire operation</code>的特性，用于<code class="language-plaintext highlighter-rouge"> store operation</code>(原子写操作）的时候有<code class="language-plaintext highlighter-rouge">release operation</code>的特性, 用于 <code class="language-plaintext highlighter-rouge">read-modify-write operation</code>（RMW）的时候有<code class="language-plaintext highlighter-rouge">acq_rel operation</code>的特性，且所有操作都相当于一个双向屏障，<strong>前后语句都不能跨越该操作进行重排</strong>。<strong>并且所有线程的语句都以全局的内存修改顺序为参照</strong>。<li><p>看起来，这个和<code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>差不多啊？并不是。<strong>这种内存序列会对拥有此标签的内存操作建立一个单独全序</strong>。<code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>比<code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>更强，<code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>的顺序保障，是要基于同一个原子变量的，也就是说，在这个原子变量之前的读写，不能重排到这个原子变量之后，同时这个原子变量之后的读写，也不能重排到这个原子变量之前。但是，如果两个线程基于<code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>使用了两个不同的原子变量x1, x2，那在x1之前的读写，重排到x2之后，是完全可能的，在x1之后的读写，重排到x2之前，也是被允许的。然而，如果两个原子变量x1,x2，是基于<code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>在操作，那么即使是x1之前的读写，也不能被重排到x2之后，x1之后的读写，也不能重排到x2之前，也就说，如果都用<code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>，那么<strong>程序代码顺序(Program Order)就将会是你在多个线程上都实际观察到的顺序(Observed Order)</strong></p><li>简而言之: 在这个模型下, 所有线程看到的所有操作都有一个一致的顺序, 即使这些操作可能针对不同的变量, 运行在不同的线程. 2.1 节中我们介绍了修改顺序 (modification order), 即单一变量的修改顺序在所有线程看来都是一致的. <strong>Sequencial consistent 则将这种一致性扩展到了所有变量</strong>. 例如</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// (1)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">thread1</code> 和 <code class="language-plaintext highlighter-rouge">thread2</code> 分别修改原子变量 <code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code>. 运行过程中, 有可能先执行 (1) 再执行 (2), 也有可能先执行 (2) 后执行 (1). 但无论如何, 所有线程中看到的顺序都是一致的. 因此如果我们这样测试这段代码:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">read_x_then_y</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">));</span> <span class="c1">// (3)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (4)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_y_then_x</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">));</span> <span class="c1">// (5)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (6)</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">a</span><span class="p">(</span><span class="n">thread1</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">thread2</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">read_x_then_y</span><span class="p">),</span> <span class="n">d</span><span class="p">(</span><span class="n">read_y_then_x</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">d</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// (7)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(7) 处的断言永远不会失败. 因为 <code class="language-plaintext highlighter-rouge">x</code> 和 <code class="language-plaintext highlighter-rouge">y</code> 的修改顺序是全局一致的, 如果先执行 (1) 后执行 (2), 则 <code class="language-plaintext highlighter-rouge">read_y_then_x</code> 中循环 (5) 退出时, 能保证 <code class="language-plaintext highlighter-rouge">y</code> 为 <code class="language-plaintext highlighter-rouge">true</code>, 此时 <code class="language-plaintext highlighter-rouge">x</code> 也必然为 <code class="language-plaintext highlighter-rouge">true</code>, 因此 (6) 会被执行; 同理, 如果先执行 (2) 后执行 (1), 则循环 (3) 退出时 <code class="language-plaintext highlighter-rouge">y</code> 也必然为 <code class="language-plaintext highlighter-rouge">true</code>, 因此 (4) 会被执行. 无论如何, <code class="language-plaintext highlighter-rouge">z</code> 最终都不会等于 0.</p><p><strong>所有线程会以相同的顺序观察到这两个操作的执行顺序. 所以如果某个线程看到<code class="language-plaintext highlighter-rouge">thread1</code>先执行, 那么其余所有线程都会看到<code class="language-plaintext highlighter-rouge">thread1</code>先执行.</strong> 然而，这并不意味着线程1和线程2的操作之间有任何特定的顺序。具体来说，<code class="language-plaintext highlighter-rouge">x.store(true)</code> 和 <code class="language-plaintext highlighter-rouge">y.store(true)</code> 的顺序在不同的线程之间是有序的，但在同一线程中没有保证它们的相对顺序。</p><p>Sequencial consistent 可以实现 synchronizes-with 的关系. 如果一个 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 的 load 操作在某个原子变量上读到了一个 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 的 store 操作在这个原子变量中写入的值, 则 store 操作 “synchronizes-with” load 操作. 在上面的例子中, 有 (1) “synchronizes-with” (3) 和 (2) “synchronizes-with” (5).</p><p><strong>顺序一致模型有一个最大的问题：它的性能差。我们很多时候并不需要对整体的原子操作进行排序。一般都是局部有序。注意到锁和内存屏障的区别。锁一般来说都是局部的，也就是针对某一个区域加锁解锁。但是不同的锁之间往往是没有顺序的。也就是说，锁更像<code class="language-plaintext highlighter-rouge">acquire--release</code>模型，而不是<code class="language-plaintext highlighter-rouge">seq_cst</code>模型。</strong></p><h3 id="获取发布-release-acquireconsume-ordering"><span class="mr-2">获取发布 （release-acquire/consume ordering）</span><a href="#获取发布-release-acquireconsume-ordering" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="memory_order_consume"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_consume</code></span><a href="#memory_order_consume" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>类似于<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>，也是用于<code class="language-plaintext highlighter-rouge">load</code>操作，但更为宽松。针对于该<code class="language-plaintext highlighter-rouge">load</code>操作，不允许<code class="language-plaintext highlighter-rouge">load</code>之后的<strong>有关联（依赖）的</strong>操作重排到<code class="language-plaintext highlighter-rouge">load</code>之前。</p><li><p><code class="language-plaintext highlighter-rouge">memory_order_consume</code>适用于<code class="language-plaintext highlighter-rouge">load operation</code>（原子读操作），对于采用此内存序的<code class="language-plaintext highlighter-rouge">load operation</code>，我们可以称为<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作），设有一个原子变量M上的<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作），对周围内存序的影响是：</p><ul><li><p>当前线程中该<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作）后的<strong>依赖</strong>该<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作）读取的值的写入或读取操作不能被重排到该<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作）前，其他线程中所有对M的<code class="language-plaintext highlighter-rouge">release operation</code>（原子写操作）及其之前的对数据依赖变量的写入都对当前线程从该<code class="language-plaintext highlighter-rouge">consume operation</code>(consume原子读操作）开始往后的操作可见</p><li><p>相比较于下面讲的<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>，<code class="language-plaintext highlighter-rouge">memory_order_consume</code>只是阻止了之后有依赖关系的重排。绝大部分平台上，这个内存序只会影响到编译器优化，依赖于dependency chain。但实际上很多编译器都没有正确地实现consume，导致等同于acquire。</p><li><p>见下图，如果我们把<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>换成了<code class="language-plaintext highlighter-rouge">memory_order_consume</code>，那么将只有<code class="language-plaintext highlighter-rouge">int r2 = x-&gt;i</code> 是有效的，因为其读取的值依赖原子变量<code class="language-plaintext highlighter-rouge">p</code>，但<code class="language-plaintext highlighter-rouge">int r1 = A</code>并不能保证读到线程1写入到<code class="language-plaintext highlighter-rouge">A</code>的值，因为<code class="language-plaintext highlighter-rouge">A</code>值并不依赖<code class="language-plaintext highlighter-rouge">p</code>。</p></ul></ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png" alt="QQ截图20220909144257" class="lazyload" data-proofer-ignore></a></p><h4 id="memory_order_acquire---理解为-acquire-lock"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_acquire</code> —- 理解为 acquire lock</span><a href="#memory_order_acquire---理解为-acquire-lock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>针对于该<code class="language-plaintext highlighter-rouge">load</code>操作，不允许<code class="language-plaintext highlighter-rouge">load</code>之后的操作重排到<code class="language-plaintext highlighter-rouge">load</code>之前。<li>说人话就是：单向加载内存屏障，表示<strong>线程中的读写指令不能重排到此<em>读</em>屏障指令<em>之前</em>，另一个执行<em>写</em>原子变量的线程里写操作之前的变量，可以被此线程 读取</strong>。<ul><li>理解为<code class="language-plaintext highlighter-rouge">lock()</code>。也就是<code class="language-plaintext highlighter-rouge">lock</code>之后的代码不能放到<code class="language-plaintext highlighter-rouge">lock</code>之前。理解为我们acquire其他线程publish的操作。</ul><li><code class="language-plaintext highlighter-rouge">memory_order_acquire</code>适用于<code class="language-plaintext highlighter-rouge">load operation</code>（原子读操作），对于采用此内存序的<code class="language-plaintext highlighter-rouge">load operation</code>（原子读操作），我们可以称为<code class="language-plaintext highlighter-rouge">acquire operation</code>，设有一个原子变量M上的<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作），对周围内存序的影响是：<ul><li>当前线程中该<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作）后的任何内存读写操作都不能被重排到该<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作）前。<li>结合下面的<code class="language-plaintext highlighter-rouge">memory_order_release</code>我们能推导出从而会有其他线程中所有对M的<code class="language-plaintext highlighter-rouge">release operation</code>（原子写操作）及其之前的写入都对当前线程从该<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作）开始往后的操作可见。</ul></ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114235531.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114235531.png" alt="QQ截图20230114235531" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115005233.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115005233.png" alt="QQ截图20230115005233" class="lazyload" data-proofer-ignore></a></p><p>此时在一个线程上执行时，<strong>读取<code class="language-plaintext highlighter-rouge">x</code>的内存屏障操作之前的指令允许重排到<code class="language-plaintext highlighter-rouge">x</code>之后，但是读取<code class="language-plaintext highlighter-rouge">x</code>之后的指令不会被重排到<code class="language-plaintext highlighter-rouge">x</code>前面。</strong></p><p>实际上<code class="language-plaintext highlighter-rouge">memory_order_release</code>用于写入、<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>用于读取，他们是成对使用：线程A使用<code class="language-plaintext highlighter-rouge">memory_order_release</code>写原子变量<code class="language-plaintext highlighter-rouge">x</code>，线程B使用<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>读原子变量<code class="language-plaintext highlighter-rouge">x</code>。线程A写<code class="language-plaintext highlighter-rouge">x</code>之前的操作，都可以被线程B在读<code class="language-plaintext highlighter-rouge">x</code>之后看到</p><h4 id="memory_order_release---理解为-release-unlock"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_release</code> —- 理解为 release unlock</span><a href="#memory_order_release---理解为-release-unlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>针对于该<code class="language-plaintext highlighter-rouge">store</code>操作，不允许<code class="language-plaintext highlighter-rouge">store</code>之前的操作重排到<code class="language-plaintext highlighter-rouge">store</code>之后。<li>说人话就是：单向释放内存屏障，表示<strong>线程中的<em>读写</em>指令不能重排到此<em>写</em>原子变量指令<em>之后</em>。另一个执行<em>读</em>原子变量的线程，可以正确<em>读取</em>指令之前的变量</strong><ul><li>理解为<code class="language-plaintext highlighter-rouge">unlock()</code>。也就是<code class="language-plaintext highlighter-rouge">unlock</code>前面的代码不能放到<code class="language-plaintext highlighter-rouge">unlock</code>后面。理解为我们把我们对内存的更改 release掉。也就是publish给其他线程<li><code class="language-plaintext highlighter-rouge">memory_order_release</code>适用于<code class="language-plaintext highlighter-rouge">store operation</code>（原子写操作），对于采用此内存序的写入操作，我们可以称为<code class="language-plaintext highlighter-rouge">release operation</code>，设有一个原子变量M上的<code class="language-plaintext highlighter-rouge">release operation</code>(写入操作），对周围内存序的影响是：<ul><li><p>该<code class="language-plaintext highlighter-rouge">release operation</code>(写入操作）前的内存读写都不能重排到该<code class="language-plaintext highlighter-rouge">release operation</code>(写入操作）之后。(该<code class="language-plaintext highlighter-rouge">store</code>操作，不允许<code class="language-plaintext highlighter-rouge">store</code>之前的操作重排到<code class="language-plaintext highlighter-rouge">store</code>之后。)结合<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>的左右从而有：</p><ul><li>当前线程截止到该<code class="language-plaintext highlighter-rouge">release operation</code>（原子写操作）的所有内存写入都对另外线程对M的<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作）以及之后的内存操作可见，这就是<code class="language-plaintext highlighter-rouge">release acquire</code> 语义。<li>当前线程截止到该operation的所有M所依赖的内存写入都对另外线程对M的<code class="language-plaintext highlighter-rouge">consume operation</code>以及之后的内存操作可见，这就是<code class="language-plaintext highlighter-rouge">release consume</code>语义。</ul></ul></ul></ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114234826.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114234826.png" alt="QQ截图20230114234826" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115005203.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115005203.png" alt="QQ截图20230115005203" class="lazyload" data-proofer-ignore></a></p><p>此时在一个线程上执行时，<strong>写入<code class="language-plaintext highlighter-rouge">x</code>的内存屏障操作之后的指令允许重排到<code class="language-plaintext highlighter-rouge">x</code>之前，但是写入x之前的指令不会被重排到x后面。</strong> <strong>不过写入x指令前后的那些指令的顺序是允许重排的</strong>。所以使用<code class="language-plaintext highlighter-rouge">memory_order_release</code>屏障后，可以保障另一个线程在执行了读取<code class="language-plaintext highlighter-rouge">x</code>操作之后，读取<code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code>的值是正确的，因为<code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>、<code class="language-plaintext highlighter-rouge">c</code>的写入操作一定不会被重排到<code class="language-plaintext highlighter-rouge">x</code>操作之后</p><h4 id="memory_order_acq_rel"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code></span><a href="#memory_order_acq_rel" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>双向的”加载-释放”内存屏障。<li>多用于CAS操作。比如<code class="language-plaintext highlighter-rouge">compare_exchange_weak/strong</code>, <code class="language-plaintext highlighter-rouge">fetch_add/sub/...</code>等<li>用于RMW(read-modify-write)原子操作，RMW操作前后的语句都不允许跨越该操作而重排。该操作相当于兼具load(acquire)和store(release)，可以看作由这两个操作组成，但是整体上是原子的。<li><code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>适用于<code class="language-plaintext highlighter-rouge">read-modify-write operation</code>(RMW操作)，对于采用此内存序的<code class="language-plaintext highlighter-rouge">read-modify-write operation</code>，我们可以称为<code class="language-plaintext highlighter-rouge">acq_rel operation</code>，既属于<code class="language-plaintext highlighter-rouge">acquire operation</code> 也是<code class="language-plaintext highlighter-rouge">release operation</code>. 设有一个原子变量M上的<code class="language-plaintext highlighter-rouge">acq_rel operation</code>：自然的，因为同时具有两种属性，所以该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>之前的内存读写都不能重排到该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>之后，该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>之后的内存读写都不能重排到该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>之前. 其他线程中所有对M的<code class="language-plaintext highlighter-rouge">release operation</code>(写入操作）及其之前的写入都对当前线程从该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>开始的操作可见，并且截止到该<code class="language-plaintext highlighter-rouge">acq_rel operation</code>的所有内存写入都对另外线程对M的<code class="language-plaintext highlighter-rouge">acquire operation</code>（原子读操作）以及之后的内存操作可见。<li><strong>注意，针对内存屏障，多线程之间必须要使用的是同一个原子变量。因为是使用这一个原子变量的值进行同步的。这里和顺序一致模型有区别</strong></ul><p>release-acquire 可以实现 synchronizes-with 的关系. 如果一个 acquire 操作在同一个原子变量上读取到了一个 release 操作写入的值, 则这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看一个例子:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (3)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span> <span class="c1">// (4)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在上面的例子中, 语句 (2) 使用 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 在 <code class="language-plaintext highlighter-rouge">y</code> 中写入 <code class="language-plaintext highlighter-rouge">true</code>, 语句 (3) 中使用 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 从 <code class="language-plaintext highlighter-rouge">y</code> 中读取值. 循环 (3) 退出时, 它已经读取到了 <code class="language-plaintext highlighter-rouge">y</code> 的值为 <code class="language-plaintext highlighter-rouge">true</code>, 也就是读取到了操作 (2) 中写入的值. 因此有 (2) “synchronizes-with” (3). 所以我们可以推导出:</p><ul><li>因为 (2) “synchronizes-with” (3) 且 (3) “sequenced-before” (4), 所以 (2) “inter-thread happens-before” (4);<li>因为 (1) “sequenced-before” (2) 且 (2) “inter-thread happens-before” (4), 所以 (1) “inter-thread happens-before” (4);</ul><p>所以 (1) “happens-before” (4). 因此 (4) 能读取到 (1) 中写入的值, 断言永远不会失败. 即使 (1) 和 (4) 用的是 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>.</p><p>我们提到 sequencial consistent 模型可以实现 synchronizes-with 关系. 事实上, 内存顺序为 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 的 load 操作和 store 操作可以分别视为 acquire 操作和 release 操作. 因此对于两个指定了 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 的 store 操作和 load 操作, 如果后者读到了前者写入的值, 则前者 “synchronizes-with” 后者.</p><p>为了实现 synchronizes-with 关系, acquire 操作和 release 操作应该成对出现. 如果 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 的 load 读到了 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code> 的 store 写入的值, 或者 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code> 的 load 读到了 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的 store 写入的值, 都不能实现 synchronizes-with 的关系.</p><p>虽然 sequencial consistent 顺序一致模型能够像 release-acquire 一样实现同步, <strong>但是反过来 release-acquire 模型不能像 sequencial consistent 一样提供全局顺序一致性</strong>. 如果将顺序一致一节例子中的 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 换成 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 和 <code class="language-plaintext highlighter-rouge">memory_order_release</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (1)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_x_then_y</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (3)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (4)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_y_then_x</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (5)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (6)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>则最终不能保证 <code class="language-plaintext highlighter-rouge">z</code> 不为 0. 在同一次运行中, <code class="language-plaintext highlighter-rouge">read_x_then_y</code> 有可能看到先 (1) 后 (2), 而 <code class="language-plaintext highlighter-rouge">read_y_then_x</code> 有可能看到先 (2) 后 (1). 这样有可能 (4) 和 (6) 的 load 的结果都为 <code class="language-plaintext highlighter-rouge">false</code>, 导致最后 <code class="language-plaintext highlighter-rouge">z</code> 仍然为 0.</p><p>release-acquire 的开销比 sequencial consistent 小. 在 x86 架构下, <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 和 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的操作不会产生任何其他的指令, 只会影响编译器的优化: 任何指令都不能重排到 acquire 操作的前面, 且不能重排到 release 操作的后面; 否则会违反 release-acquire 的语义. 因此很多需要实现 synchronizes-with 关系的场景都会使用 release-acquire</p><h3 id="宽松relaxed-ordering-"><span class="mr-2">宽松（relaxed ordering ）</span><a href="#宽松relaxed-ordering-" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="memory_order_relaxed"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code></span><a href="#memory_order_relaxed" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code> 可以用于 store, load 和 read-modify-write 操作</p><ul><li>这种模型下, 只能保证操作的原子性和修改顺序 (modification order) 一致性, 无法实现 synchronizes-with 的关系. 对于其它读写操作没有任何同步和重排的限制，仅要求保证读写的原子性和内存一致性。除此之外，不提供任何跨线程的同步。<li><strong>一般应用于计数器场景</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Thread 1:</span>
<span class="n">r1</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// A</span>
<span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// B</span>
<span class="c1">// Thread 2:</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// C </span>
<span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// D</span>
</pre></table></code></div></div><p>执行完上面的程序，可能出现<code class="language-plaintext highlighter-rouge">r1 == r2 == 42</code>。理解这一点并不难，因为编译器允许调整 C 和 D 的执行顺序。如果程序的执行顺序是 D -&gt; A -&gt; B -&gt; C，那么就会出现<code class="language-plaintext highlighter-rouge">r1 == r2 == 42</code>。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">thread1</code> 对不同的变量执行 store 操作. 那么在某些线程看来, 有可能是 <code class="language-plaintext highlighter-rouge">x</code> 先变为 <code class="language-plaintext highlighter-rouge">true</code>, y 后变为 <code class="language-plaintext highlighter-rouge">true</code>; 另一些线程看来, 又有可能是 <code class="language-plaintext highlighter-rouge">y</code> 先变为 <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">x</code> 后变为 <code class="language-plaintext highlighter-rouge">true</code>. 如果这样测试这段代码:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span> <span class="c1">// (3)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">());</span> <span class="c1">// (4)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>(4) 处的断言就有可能失败. 因为 (2) 与 (3) 之间没有 synchronizes-with 的关系, 所以就不能保证 (1) “happens-before” (4). 因此 (4) 就有可能读到 <code class="language-plaintext highlighter-rouge">false</code>.</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114234414.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230114234414.png" alt="QQ截图20230114234414" class="lazyload" data-proofer-ignore></a></p><ul><li>图中x代表atomic类型变量。此时在一个线程上执行时，在这个线程认为不影响最终结果的前提下，实际执行时指令可能完全是乱的。写入a、写入b的操作实际执行时可能是调换了；写入c的操作可能实际在写入x之后执行；读出b的操作实际在写入x之前执行</ul><p>Relaxed 顺序模型的开销很小. 在 x86 架构下, <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code> 的操作不会产生任何其他的指令, 只会影响编译器优化, 确保操作是原子的. Relaxed 模型可以用在一些不需要线程同步的场景, 但是使用时要小心. <strong>例如 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 增加引用计数时用的就是 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>, 因为不需要同步; 但是减小应用计数不能用它, 因为需要与析构操作同步</strong></p><h3 id="小的总结"><span class="mr-2">小的总结</span><a href="#小的总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th>操作<th>有效的Memory order枚举值<th>备注<tbody><tr><td>Load<td><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>, <code class="language-plaintext highlighter-rouge">memory_order_consume</code>, <code class="language-plaintext highlighter-rouge">memory_order_acquire</code>, <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code><td>其它枚举值不合法， MS STL的实现是将其当作memory_order_seq_cst处理<tr><td>Store<td><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>, <code class="language-plaintext highlighter-rouge">memory_order_release</code>, <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code><td>同上<tr><td>read-modify-write<td><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>, <code class="language-plaintext highlighter-rouge">memory_order_consume</code>, <code class="language-plaintext highlighter-rouge">memory_order_acquire</code>, <code class="language-plaintext highlighter-rouge">memory_order_release</code>, <code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>, <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code><td> </table></div><ul><li><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>: 最宽松的内存顺序, 只保证操作的<strong>原子性</strong>和<strong>修改顺序 (modification order)</strong>.<li><code class="language-plaintext highlighter-rouge">memory_order_acquire</code>, <code class="language-plaintext highlighter-rouge">memory_order_release</code> 和 <code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>: 实现 <strong>acquire 操作</strong>和 <strong>release 操作</strong>, 如果 acquire 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>synchronizes-with 关系</strong>, 进而可以推导出 <strong>happens-before 的关系</strong>.<li><code class="language-plaintext highlighter-rouge">memory_order_consume</code>: 实现 <strong>consume 操作</strong>, 能实现数据依赖相关的同步关系. 如果 consume 操作读到了 release 操作写入的值, 或其 release sequence 写入的值, 则构成 <strong>dependency-ordered before 的关系</strong>, 对于有数据依赖的操作可以进而推导出 <strong>happens-before 的关系</strong>.<li><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>: 加强版的 acquire-release 模型, 除了可以实现 <strong>synchronizes-with 关系</strong>, 还保证<strong>全局顺序一致</strong>.</ul><p>参考资料：https://zhuanlan.zhihu.com/p/382372072?utm_id=0</p><p>https://blog.csdn.net/wxj1992/category_11580766.html</p><p>https://lday.me/2017/12/02/0018_cpp_atomic_summary/</p><h2 id="memory_order_acquire和memory_order_release-如何搭配使用"><span class="mr-2"><code class="language-plaintext highlighter-rouge">memory_order_acquire</code>和<code class="language-plaintext highlighter-rouge">memory_order_release</code> 如何搭配使用</span><a href="#memory_order_acquire和memory_order_release-如何搭配使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>往往<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>和<code class="language-plaintext highlighter-rouge">memory_order_release</code>是配合着一起使用的：</p><ol><li>线程1使用<code class="language-plaintext highlighter-rouge">memory_order_release</code>写入<strong>原子变量x</strong><li>线程2使用<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>读出<strong>原子变量x</strong></ol><p>所有在线程1上，在写入x之前的写入操作，都将在线程2上，在读出x之后，被看到。使用单向“加载”+单向“释放”协议的场景往往是：</p><ol><li>线程1，写入一些实际数据，接着通过将原子变量x设置为某个值<code class="language-plaintext highlighter-rouge">A</code>（通过使用<code class="language-plaintext highlighter-rouge">memory_order_release</code>写入原子变量x）来“发布”这些数据。<li>线程2，通过读取并判断x已被设置为<code class="language-plaintext highlighter-rouge">A</code>（通过使用<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>来读取原子变量x），进而读取线程1实际“发布”的那些数据</ol><p><strong>必须操作的是同一个原子变量。</strong></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011213.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011213.png" alt="QQ截图20230115011213" class="lazyload" data-proofer-ignore></a></p><p>如上图所示，thread_1在<code class="language-plaintext highlighter-rouge">release</code>写入<code class="language-plaintext highlighter-rouge">x</code>(值:<code class="language-plaintext highlighter-rouge">A</code>)之前，写入了待发布的<code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>的数据，而thread_2，将在<code class="language-plaintext highlighter-rouge">acquire</code>读出<code class="language-plaintext highlighter-rouge">x</code>且为<code class="language-plaintext highlighter-rouge">A</code>之后，将读到thread_1发布的<code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>的数据。同时，我们可以注意到，在thread_2上，在<code class="language-plaintext highlighter-rouge">acquire</code>读出<code class="language-plaintext highlighter-rouge">x</code>之前，如果对<code class="language-plaintext highlighter-rouge">a</code>进行读操作，我们是无法确认读到的<code class="language-plaintext highlighter-rouge">a</code>一定会thread_1在之前最后写入的<code class="language-plaintext highlighter-rouge">a</code>，这里的顺序是不会被保证的，重排是被允许的。同时，在之后，读取<code class="language-plaintext highlighter-rouge">c</code>，读到的是否为thread_1最后写入的<code class="language-plaintext highlighter-rouge">c</code>，也是不确定的，因为，在<code class="language-plaintext highlighter-rouge">x</code>写入之后，thread_1上又出现了一次写入，而如果在此之前，还有一次写入， 这两次写入之间，是不存在限制，可能会被重排的。</p><p>thread_1上有了<code class="language-plaintext highlighter-rouge">release_store</code>，对于<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">b</code>的写入就一定会在<code class="language-plaintext highlighter-rouge">x</code>的改变之前，在thread_2上，就不会出现类似读出<code class="language-plaintext highlighter-rouge">c</code>，的不确定性。thread_2上有了acquire_load，右侧的读出<code class="language-plaintext highlighter-rouge">a</code>，就不会被重排读到左侧，而左侧读出<code class="language-plaintext highlighter-rouge">a</code>的不确定性，也不存在。thread_1卡住的是：对于数据<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">b</code>的写入不能排到<code class="language-plaintext highlighter-rouge">x</code>的写入之后，thread_2卡住的，是对于数据<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">b</code>的读取，不能排到读取<code class="language-plaintext highlighter-rouge">x</code>之前，这样，就保证了数据<code class="language-plaintext highlighter-rouge">a</code>，<code class="language-plaintext highlighter-rouge">b</code>，与”信号量”<code class="language-plaintext highlighter-rouge">x</code>，之间，在thread_1, thread_2上的同步关系。</p><h2 id="release-sequences-释放序列"><span class="mr-2">Release sequences 释放序列</span><a href="#release-sequences-释放序列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>到目前为止我们看到的, 无论是 sequencial consistent 还是 release-acquire, 要想实现 synchronizes-with 的关系, acquire 操作必须在<strong>同一个原子变量</strong>上读到 release 操作的写入的值. 如果 acquire 操作没有读到 release 操作写入的值, 那么它俩之间通常没有 synchronizes-with 的关系. 例如</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (3)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread3</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (4)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// (5)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的例子中, 只要 <code class="language-plaintext highlighter-rouge">y</code> 的值非 0 循环 (4) 就会退出. 当它退出时, 有可能读到 (2) 写入的值, 也有可能读到 (3) 写入的值. 如果是后者, 则只能保证 (3) “synchronizes-with” (4), 不能保证与 (2) 与 (4) 之间有同步关系. 因此 (5) 处的断言就有可能失败.</p><p>但并不是只有在 acquire 操作读取到 release 操作写入的值时才能构成 synchronizes-with 关系. 为了说这种情况, 我们需要引入 <strong>release sequence</strong> 这个概念.</p><p>针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由</p><ul><li>同一线程上的写操作, 或者<li>任意线程上的 read-modify-write 操作</ul><p>这两种构成的, 则称这一连串的操作为<strong>以 release 操作 A 为首的 release sequence</strong>. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.</p><p>如果一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作. 我们来看个例子</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flag</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// (1)</span>
    <span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="c1">// (3) 注意此处使用了宽松</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread3</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// (4)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// (5)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的例子中, (3) 处的 <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code> 是一种 RMW 操作, 它判断原子变量的值是否与期望的值 (第一个参数) 相等, 如果相等则将原子变量设置成目标值 (第二个参数) 并返回 <code class="language-plaintext highlighter-rouge">true</code>, 否则将第一个参数 (引用传递) 设置成原子变量当前值并返回 <code class="language-plaintext highlighter-rouge">false</code>. 操作 (3) 会一直循环检查, 当 <code class="language-plaintext highlighter-rouge">flag</code> 当值为 1 时, 将其替换成 2. 所以 (3) 属于 (2) 的 release sequence. 而循环 (4) 退出时, 它已经读到了 (3) 写入的值, 也就是 release 操作 (2) 为首的 release sequence 写入的值. 所以有 (2) “synchronizes-with” (4). 因此 (1) “happens-before” (5), (5) 处的断言不会失败.</p><p>注意 (3) 处的 <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code> 的内存顺序是 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>, 所以 (2) 与 (3) 并不构成 synchronizes-with 的关系. 也就是说, 当循环 (3) 退出时, 并不能保证 <code class="language-plaintext highlighter-rouge">thread2</code> 能读到 <code class="language-plaintext highlighter-rouge">data.at(0)</code> 为 42. 但是 (3) 属于 (2) 的 release sequence, 当 (4) 以 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 的内存顺序读到 (2) 的 release sequence 写入的值时, 可以与 (2) 构成 synchronizes-with 的关系</p><p><strong>注意, 这种只是一种概念. 依赖于代码的正确性. 同时, 我们说 “当循环 (3) 退出时, 并不能保证 <code class="language-plaintext highlighter-rouge">thread2</code> 能读到 <code class="language-plaintext highlighter-rouge">data.at(0)</code> 为 42”的原因是 这个插入操作由于缓存一致性的原因, 并不保证被刷新到thread2的cache内. 尽管从逻辑上讲, 当flag从1变为2的时候, 写入操作已经发生了, 但是这个时候这个写入并不一定保证对thread2<em>可见</em>. 当然了, 假设这个原子变量和写入数据在一个cache line中, 这个操作可能对thread2是可见的</strong></p><h2 id="如何理解内存序和锁之间的联系"><span class="mr-2">如何理解内存序和锁之间的联系？</span><a href="#如何理解内存序和锁之间的联系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>多线程编程，临界区是一个很重要的概念。我们对此再做进一步的认识。</p><p>对于临界区区内的语句，显而易见，我们不能将其移出临界区，如下图所示，编译器和CPU都不会做这种移出临界区的优化：</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011701.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011701.png" alt="QQ截图20230115011701" class="lazyload" data-proofer-ignore></a></p><p><strong>但我们可以将临界区区外的代码移进来，如下图所示</strong></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011724.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115011724.png" alt="QQ截图20230115011724" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230116025012.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230116025012.png" alt="QQ截图20230116025012" class="lazyload" data-proofer-ignore></a></p><p>从上面两张图我们可以看出，<code class="language-plaintext highlighter-rouge">lock</code>和<code class="language-plaintext highlighter-rouge">unlock</code>可以看作两个单方向的屏障，<strong><code class="language-plaintext highlighter-rouge">lock</code>对应的屏障，只允许代码往下方向移动，而`unlock则只允许上方向移动。</strong></p><p><strong>所以我们是不是发现：<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>类似<code class="language-plaintext highlighter-rouge">lock</code>，<code class="language-plaintext highlighter-rouge">memory_order_release</code>类似<code class="language-plaintext highlighter-rouge">unlock</code>，这两个都是单方向的屏障（One-way Barriers: acquire barrier, release barrier）。</strong></p><p>所以借助内存屏障+原子变量，在比互斥锁更底层的层面，我们也能实现线程间同步。比如下图的例子：</p><p><code class="language-plaintext highlighter-rouge">p</code>原子变量，当线程2看到<code class="language-plaintext highlighter-rouge">p</code>为非空时，后续的<code class="language-plaintext highlighter-rouge">r1 = A</code>语句可以看到线程1对<code class="language-plaintext highlighter-rouge">A</code>的写操作结果。这是因为线程1对<code class="language-plaintext highlighter-rouge">p</code>的<code class="language-plaintext highlighter-rouge">store</code>操作Synchronizes-with线程2对<code class="language-plaintext highlighter-rouge">p</code>的<code class="language-plaintext highlighter-rouge">load</code>操作，这样加之Happens-before关系，我们实现了线程间同步。值得一提的是，线程1中，<code class="language-plaintext highlighter-rouge">A=B+1</code>Happens-before <code class="language-plaintext highlighter-rouge">B = 1</code>，但<code class="language-plaintext highlighter-rouge">B = 1</code>可能先执行，但线程1对<code class="language-plaintext highlighter-rouge">A</code>的写操作的结果，依旧能正确地被线程2中<code class="language-plaintext highlighter-rouge">int r1 = A</code>语句读取。</p><p>换句话说，我们利用了<code class="language-plaintext highlighter-rouge">memory_order_release</code>，使得针对<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>的写入一定会发生在写入原子变量<code class="language-plaintext highlighter-rouge">p</code>之前。我们利用了<code class="language-plaintext highlighter-rouge">memory_order_acquire</code>使得针对<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">x</code>的读取一定发生在读取原子变量<code class="language-plaintext highlighter-rouge">p</code>之前。</p><p>有人也许会问，用非原子变量难道不能实现Synchronizes-with关系？首先，非原子变量，显然不能被多个线程同时读写，再者，其无法提供内存屏障，不要忘了前文重排的例子，试想，若线程1中<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>的写入操作被重排到了<code class="language-plaintext highlighter-rouge">p.store</code>的后面，且即使替换<code class="language-plaintext highlighter-rouge">p.store</code>的非原子变量操作在多线程下可以正确执行，但此时<code class="language-plaintext highlighter-rouge">int r1 = A</code>能读取到正确的值吗？</p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909144257.png" alt="QQ截图20220909144257" class="lazyload" data-proofer-ignore></a></p><h3 id="这里所谓的指定内存序指的是对执行语句所在的线程内部的限制也就是只影响一个cpu核心但是这些对单线程内部的限制组合起来就能实现多线程之间数据同步的效果"><span class="mr-2">这里所谓的指定内存序，<strong>指的是对执行语句所在的线程内部的限制，也就是只影响一个cpu核心，但是这些对单线程内部的限制组合起来就能实现多线程之间数据同步的效果</strong>，</span><a href="#这里所谓的指定内存序指的是对执行语句所在的线程内部的限制也就是只影响一个cpu核心但是这些对单线程内部的限制组合起来就能实现多线程之间数据同步的效果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h2 id="同步的传递性和acquire搭配release的小例子"><span class="mr-2">同步的传递性和acquire搭配release的小例子</span><a href="#同步的传递性和acquire搭配release的小例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">sync1</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">sync2</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">thread_1_func</span><span class="p">(){</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">store</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">sync1</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">//注释1</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_2_func</span><span class="p">(){</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">sync1</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">//注释2</span>
  <span class="n">sync2</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">//注释3</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread_3_func</span><span class="p">(){</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">sync2</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">//注释4</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">load</span><span class="p">(</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"all success"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kr">thread</span> <span class="n">th1</span><span class="p">(</span><span class="n">thread_1_func</span><span class="p">);</span>
  <span class="kr">thread</span> <span class="n">th2</span><span class="p">(</span><span class="n">thread_2_func</span><span class="p">);</span>
  <span class="kr">thread</span> <span class="n">th3</span><span class="p">(</span><span class="n">thread_3_func</span><span class="p">);</span>

  <span class="n">th1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">th2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="n">th3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>在<code class="language-plaintext highlighter-rouge">func1</code>当中，我们的数据存储使用了<code class="language-plaintext highlighter-rouge">relaxed</code>，所以可能是乱序，但是无关紧要。我们的核心目的是保证<code class="language-plaintext highlighter-rouge">thread3</code>能看到<code class="language-plaintext highlighter-rouge">thread1</code>中存储的全部数据。所以：<li>在<code class="language-plaintext highlighter-rouge">func1</code>中，我们针对<code class="language-plaintext highlighter-rouge">sync1</code>的写入使用了<code class="language-plaintext highlighter-rouge">release</code>。也就是说，在把<code class="language-plaintext highlighter-rouge">sync1</code>修改为<code class="language-plaintext highlighter-rouge">true</code>的这个操作之前，可以保证前面的操作全部完成，不会重排到这个操作之后，同时也保证缓存一致性，也就是之前的操作全部对其他线程可见。<li>在<code class="language-plaintext highlighter-rouge">func2</code>中，我们针对<code class="language-plaintext highlighter-rouge">sync1</code>的读取使用了<code class="language-plaintext highlighter-rouge">acquire</code>操作。也就是说，在读取到<code class="language-plaintext highlighter-rouge">sync1</code>是<code class="language-plaintext highlighter-rouge">true</code>之前，任何操作不能被重排到该操作之前。也就保证了针对<code class="language-plaintext highlighter-rouge">sync2</code>的修改一定发生在发现<code class="language-plaintext highlighter-rouge">sync1</code>是<code class="language-plaintext highlighter-rouge">true</code>之后。<li>随后在<code class="language-plaintext highlighter-rouge">func2</code>中，我们针对<code class="language-plaintext highlighter-rouge">sync3</code>的写入使用了<code class="language-plaintext highlighter-rouge">release</code>。原因同上。<li>在<code class="language-plaintext highlighter-rouge">func3</code>中，针对<code class="language-plaintext highlighter-rouge">sync3</code>的读取使用了<code class="language-plaintext highlighter-rouge">acquire</code>，原因同上。<li>最后在<code class="language-plaintext highlighter-rouge">assert</code>中，乱序可能发生，但是无所谓。</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115184315.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230115184315.png" alt="QQ截图20230115184315" class="lazyload" data-proofer-ignore></a></p><ul><li><strong><code class="language-plaintext highlighter-rouge">acquire</code>和<code class="language-plaintext highlighter-rouge">release</code>的语义可以形象理解为：如果我不释放（release），你的请求（acquire）必须等待，直到我释放为止。</strong></ul><h2 id="atomic_thread_fence分类和效果"><span class="mr-2">atomic_thread_fence分类和效果</span><a href="#atomic_thread_fence分类和效果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在C++ 11及之后的标准里，除了利用原子操作指定内存序，还定义了单独使用memory fence（<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence</code>）的方式，fence可以和原子操作组合进行同步，也可以fence之间进行同步，fence不光可以不依赖原子操作进行同步，而且相比较于同样memory order的原子操作，具有更强的内存同步效果</p><p>和<code class="language-plaintext highlighter-rouge">atomic</code>变量类似，<code class="language-plaintext highlighter-rouge">atomic_thread_fence</code>也可以指定六种内存序，指定不同内存序的fence可以分为以下几类： （1） <code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_relaxed)</code>，没有任何效果。 （2） <code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_acquire)</code> 和 <code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_consume)</code> 属于acquire fence。 （3）<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_release)</code>属于release fence。 （4）<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_acq_rel)</code>既是acquire fence 也是release fence，为了方便这里称为full fence。 （5）<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_seq_cst)</code>额外保证有单独全序的full fence。</p><p>也就是说，如果不考虑单独全序，那么有release fence、acquire fence 和full fence三种。下面就根据以前介绍过的四种重排来介绍下这三种fence的效果。</p><p>不同类型的Fence对于乱序的保护是不一样的。我们可以将读和写的交错分成下面四种情况：</p><ul><li>Load-Load：读接着读<li>Load-Store：先读后写<li>Store-Load：先写后读<li>Store-Store：写接着写</ul><h3 id="release-fence"><span class="mr-2">release fence</span><a href="#release-fence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">Release fence</code>可以防止fence前的内存操作重排到fence后的任意store（写入）之后，即阻止load-store重排和store-store重排。（<strong>阻止了所有在它之前的读写操作和在它之后的写操作乱序</strong>）</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153644.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153644.png" alt="QQ截图20220909153644" class="lazyload" data-proofer-ignore></a></p><h3 id="acquire-fence"><span class="mr-2">acquire fence</span><a href="#acquire-fence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">acquire fence</code>可以防止fence后的内存操作重排到fence前的任意load（读取）之前，即阻止load-load重排和load-store重排。（<strong>阻止了所有在它之前的读操作与在它之后的读写操作乱序。</strong>）</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153840.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909153840.png" alt="QQ截图20220909153840" class="lazyload" data-proofer-ignore></a></p><h3 id="full-fence"><span class="mr-2">full fence</span><a href="#full-fence" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>因为<code class="language-plaintext highlighter-rouge">full fence</code>是release fence和acquire fence的组合，所以也就是防止load-load、load-store、store-store重排</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909154223.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220909154223.png" alt="QQ截图20220909154223" class="lazyload" data-proofer-ignore></a></p><h3 id="c标准中三种fence不禁止store-load先写后读的重排"><span class="mr-2">C++标准中，三种fence不禁止store-load（先写后读）的重排。</span><a href="#c标准中三种fence不禁止store-load先写后读的重排" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>即便是<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(memory_order_seq_cst)</code>也一样，只是需要额外保证单独全序，<strong>但是在实际的实现上为了实现这个全序编译器大都是采用了硬件层面的能够阻止storeload重排的full barrier指令</strong></p><p>参考资料：</p><p>https://paul.pub/cpp-memory-model/</p><p>https://blog.csdn.net/wxj1992/article/details/103917093</p><p>https://luyuhuang.tech/2022/06/25/cpp-memory-order.html</p><p>https://zhuanlan.zhihu.com/p/682286231</p><p><a href="https://nekrozqliphort.github.io/posts/happens-b4/">什么是strongly happens before</a></p><p>来自<a href="https://mp.weixin.qq.com/s?__biz=Mzg5MjU0NTI5OQ==&amp;mid=2247489076&amp;idx=1&amp;sn=748bf716d94d5ed2739ea8a9385cd4a6&amp;chksm=c03d2648f74aaf5e11298cf450c3453a273eb6d2161bc90e411b6d62fa0c1b96a45e411af805&amp;token=1987775079&amp;lang=zh_CN&amp;scene=21#wechat_redirect">百度</a>的介绍内存访问，分配，MESI，内存序优化的简短文章</p><h3 id="memory-barrier-和-memory-fence的细微区别"><span class="mr-2">memory barrier 和 memory fence的细微区别</span><a href="#memory-barrier-和-memory-fence的细微区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>chatGPT的回答：</p><blockquote><p>在C++11标准中，memory fence和memory barrier是等价的概念，它们都用于确保多线程环境下的内存可见性和顺序性。</p><p><strong>在C++11之前，memory fence通常是指硬件级别的操作，而memory barrier则是指编译器级别的操作，但是这种区分在C++11之后已经不再重要。</strong></p><p>在C++11中，memory fence和memory barrier都有两种类型：acquire和release。acquire fence/barrier用于确保之前的读操作在当前之后的操作之前执行，release fence/barrier用于确保之后的写操作在当前之前的操作之后执行。</p><p><strong>区别在于，memory fence是一种完全的内存屏障，它会禁止编译器和CPU对内存操作的任何优化，强制所有线程按照特定的顺序执行内存操作。而memory barrier只是一种编译器屏障，它只能保证编译器不会对内存操作进行优化，但不能保证CPU不进行优化，因此在某些平台上可能不够稳定。所以memory barrier又称为 compiler barrier</strong></p><p>此外，memory fence和memory barrier的使用需要根据具体的情况来确定。通常，只有在需要非常精细的内存控制时才需要使用memory fence和memory barrier，因为它们会影响程序的性能。在一般情况下，可以通过使用std::atomic类型来实现线程安全的操作，它会自动处理内存屏障和同步操作。</p></blockquote><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230421014842.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230421014842.png" alt="QQ截图20230421014842" class="lazyload" data-proofer-ignore></a></p><h1 id="null和nullptr区别">NULL和nullptr区别</h1><p>其实<code class="language-plaintext highlighter-rouge">NULL</code>根据命名全大写可以看出来，<strong>它是一个常量，既然是常量，就需要进行宏定义。</strong></p><ul><li>C语言的标准头文件是这样定义的<code class="language-plaintext highlighter-rouge"> #define NULL ((void*)0)</code><li>而到了C++中，则变成了<code class="language-plaintext highlighter-rouge">#define NULL 0</code></ul><p>从定义中可以看出，C++中，NULL其实就是0，但是也可以用作空指针，只是用作空指针可能是为了兼容C，迫于无奈。</p><p>但是当NULL既可以表示0又可以表示空指针的时候，发生函数重载的时候就会有二义性</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"p is pointer "</span><span class="o">&lt;&lt;</span><span class="n">p</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="p">}</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"num is int "</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">test</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">//NULL是int还是指针？</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>很明显，NULL存在二义性，它既是整数，也是一个指针，函数test()无法根据参数的数据类型判断应该调用哪一个实现。 这时使用nullptr的优越性就体现出来了，因为它可以很好地把空指针这一层意思给剥离出来。nullptr就是C++11为了解决这个痛点而推出的东西。</p><h1 id="lockguard和uniquelock">lockguard和uniquelock</h1><p><strong>注意一下锁的含义。为什么锁叫互斥量？不要认为锁和资源是挨着的。或者是资源一定和锁连着。</strong></p><p><strong>锁，互斥量是独立的。什么意思？假设我们有规定：想要打开抽屉，必须从桌子上拿走令牌。如果没有令牌则不能打开抽屉。所以说资源（抽屉）和锁（互斥量）不一定在一起。资源在抽屉里，锁在桌子上。两者是分离的。我只要确保每个人都可以访问到令牌（锁）和抽屉（资源）即可。</strong></p><ul><li><code class="language-plaintext highlighter-rouge">unique_lock</code>功能丰富灵活得多。如果需要实现更复杂的锁策略可以用<code class="language-plaintext highlighter-rouge">unique_lock</code><li>如果只需要基本的锁功能，优先使用更严格高效的<code class="language-plaintext highlighter-rouge">lock_guard</code>。<li><strong>注意区分<code class="language-plaintext highlighter-rouge">mutex</code>和<code class="language-plaintext highlighter-rouge">lock_guard</code>/<code class="language-plaintext highlighter-rouge">unique_lock</code>。后者是前者的RAII包装器。所以如果要锁的话必须这样</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">mutex</span> <span class="n">lock</span><span class="p">;</span>
<span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lkc</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
</pre></table></code></div></div><p>两种锁的简单概述与策略对比见下表：</p><div class="table-wrapper"><table><thead><tr><th><strong>类模板</strong><th><strong>描述</strong><th><strong>策略</strong><tbody><tr><td><strong>std::lock_guard</strong><td>严格基于作用域(scope-based)的锁管理类模板，构造时是否加锁是可选的(不加锁时假定当前线程已经获得锁的所有权—使用std::adopt_lock策略)，析构时自动释放锁，<strong>所有权不可转移，对象生存期内不允许手动加锁和释放锁</strong><td>std::adopt_lock<tr><td><strong>std::unique_lock</strong><td>更加灵活的锁管理类模板，构造时是否加锁是可选的，在对象析构时如果持有锁会自动释放锁，<strong>所有权可以转移。对象生命期内允许手动加锁和释放锁</strong><td>std::adopt_lock std::defer_lock std::try_to_lock</table></div><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064910.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064910.png" alt="QQ截图20220926064910" class="lazyload" data-proofer-ignore></a></p><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064919.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20220926064919.png" alt="QQ截图20220926064919" class="lazyload" data-proofer-ignore></a></p><ul><li><strong><code class="language-plaintext highlighter-rouge">lock_guard</code>不能手动解锁</strong>。这也是为什么使用条件变量的时候互斥锁一定要使用unique_lock，因为wait函数内部会进行解锁。详细查看项目相关的条件变量。<li><p><code class="language-plaintext highlighter-rouge">lock_guard</code>不能创建时不锁定，也就是没有<code class="language-plaintext highlighter-rouge">defer</code>功能。</p><li>使用<code class="language-plaintext highlighter-rouge">std::lock</code>对多个<code class="language-plaintext highlighter-rouge">unique_lock</code>一起加锁可以避免死锁<ul><li>同时，只要传入的多个锁中的一个发生了异常，则所有已锁定的对象都会被解锁。也就是要么全都锁，要么全都不锁。<li>原理其实也是一个包装器。遵循了<strong><em>多线程按照同一个顺序对多个锁进行加锁一定不会死锁</em></strong> 这一个唯一原则。</ul></ul><h1 id="shared_lock">shared_lock</h1><p><code class="language-plaintext highlighter-rouge">shared_lock</code>本身和<code class="language-plaintext highlighter-rouge">unique_lock</code>的接口差不多.</p><p>一般我们是用<code class="language-plaintext highlighter-rouge">shared_lock</code>管理共享互斥量. 如<code class="language-plaintext highlighter-rouge">shared_mutex</code>. 注意, 非共享互斥量不可以用<code class="language-plaintext highlighter-rouge">shared_lock</code>管理</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="c1">    //unique_lock</span><span class="cp">
#include</span> <span class="cpf">&lt;shared_mutex&gt;</span><span class="c1"> //shared_mutex shared_lock</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ThreadSaferCounter</span>
<span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">mutex_</span><span class="p">;</span> <span class="c1">// 这个mutable的作用是在下面的const成员函数中可以修改它. 更多查看杂记2</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">ThreadSaferCounter</span><span class="p">(</span><span class="cm">/* args */</span><span class="p">)</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">ThreadSaferCounter</span><span class="p">()</span> <span class="p">{};</span>
    
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">//读者, 获取共享锁, 使用shared_lock</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">//等同于执行mutex_.lock_shared();</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>  <span class="c1">//lck 析构, 执行mutex_.unlock_shared();</span>
    <span class="p">}</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//写者, 获取独占锁, 使用unique_lock</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">//等同于执行mutex_.lock();</span>
        <span class="n">value_</span><span class="o">++</span><span class="p">;</span>   <span class="c1">//lck 析构, 执行mutex_.unlock();</span>
        <span class="k">return</span> <span class="n">value_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//写者, 获取独占锁, 使用unique_lock</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span><span class="c1">//等同于执行mutex_.lock();</span>
        <span class="n">value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">//lck 析构, 执行mutex_.unlock();</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">ThreadSaferCounter</span> <span class="n">counter</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">reader</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ulck</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="c1">//cout也需要锁去保护, 否则输出乱序</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"reader #"</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" get value "</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>    
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writer</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">){</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">ulck</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="c1">//cout也需要锁去保护, 否则输出乱序</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"writer #"</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" write value "</span> <span class="o">&lt;&lt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">increment</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">rth</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">wth</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">rth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">wth</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">rth</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">wth</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>通过实例我们可以得知. <strong>真正的锁本身其实是互斥量</strong>. 互斥量本身需要是<code class="language-plaintext highlighter-rouge">shared_mutex</code>.</p><p>所以:</p><ul><li>读锁使用<code class="language-plaintext highlighter-rouge">shared_lock</code>锁定<code class="language-plaintext highlighter-rouge">shared_mutex</code><li>写锁使用<code class="language-plaintext highlighter-rouge">unique_lock</code>锁定.<code class="language-plaintext highlighter-rouge">shared_mutex</code></ul><p><a href="https://blog.csdn.net/princeteng/article/details/103952888">参考来自</a></p><h1 id="互斥锁的底层实现">互斥锁的底层实现</h1><p>https://zhiqiang.org/coding/std-mutex-implement.html</p><ul><li>内存中准备一个表示锁定状态的整数<li>使用CAS操作来尝试修改值（上锁）<li><strong>提供一个函数让互斥锁在被锁定的情况下等待。Linux里面这个操作是<code class="language-plaintext highlighter-rouge">futex</code>系统调用</strong>。这会将线程放入队列中，并监视内存中的整数。<li>可能包括防止指令重排的内存屏障</ul><h1 id="futex">Futex</h1><h2 id="为什么要有futex"><span class="mr-2">为什么要有futex</span><a href="#为什么要有futex" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们已经有了互斥锁和自旋锁。我们也知道了它们的优缺点。自旋锁的主要缺点是在等待时浪费CPU资源。互斥锁的主要缺点是就算无需等待（争抢），也需要进行上下文切换进行系统调用。那么我们为何不将二者的缺点去掉，保留优点呢？所以Futex就来了。</p><p>Futex是一种用户态和内核态混合的同步机制。同步的进程间通过mmap共享一段内存，futex变量就位于这段共享的内存中且操作是原子的，当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的futex变量，<strong>如果没有竞争发生，则只修改futex</strong>，而不用再执行系统调用，仅当通过访问futex变量告诉进程有竞争发生时，才执行系统调用去完成相应的处理。总结就是：<strong>使用一条原子指令，如果上锁成功立即返回。如果上锁失败，执行系统调用进行睡眠。</strong></p><ul><li>首先，同步的进程间通过<code class="language-plaintext highlighter-rouge">mmap</code>共享一段内存，<code class="language-plaintext highlighter-rouge">futex</code>变量就位于这段共享的内存中。且操作是原子的<li>当进程尝试进入互斥区或者退出互斥区的时候，先去查看共享内存中的<code class="language-plaintext highlighter-rouge">futex</code>变量，如果没有竞争发生，则只修改<code class="language-plaintext highlighter-rouge">futex</code>,而不 用再执行系统调用了。<li>当通过访问<code class="language-plaintext highlighter-rouge">futex</code>变量告诉进程有竞争发生，则还是得执行系统调用去完成相应的处理(<code class="language-plaintext highlighter-rouge">wait</code> 或者 <code class="language-plaintext highlighter-rouge">wake up</code>)。<li>当进程尝试持有锁或者要进入互斥区的时候，对<code class="language-plaintext highlighter-rouge">futex</code>执行”down”操作，即原子性的给<code class="language-plaintext highlighter-rouge">futex</code>同步变量减1<ul><li>如果同步变量变为0，则没有竞争发生， 进程照常执行。无需进入内核态进行系统调用。<li>如果同步变量是个负数，则意味着有竞争发生，需要调用<code class="language-plaintext highlighter-rouge">futex</code>系统调用的<code class="language-plaintext highlighter-rouge">futex_wait</code>操作休眠当前进程。</ul><li>当进程释放锁或者要离开互斥区的时候，对<code class="language-plaintext highlighter-rouge">futex</code>进行”up”操作，即原子性的给<code class="language-plaintext highlighter-rouge">futex</code>同步变量加1。<ul><li>如果同步变量由0变成1，则没有竞争发生，进程照常执行。无需进入内核态进行系统调用。<li>如果加之前同步变量是负数，则意味着有竞争发生，需要调用<code class="language-plaintext highlighter-rouge">futex</code>系统调用的<code class="language-plaintext highlighter-rouge">futex_wake</code>操作唤醒一个或者多个等待进程。</ul></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">//uaddr指向一个地址，val代表这个地址期待的值，当*uaddr==val时，才会进行wait</span>
<span class="kt">int</span> <span class="nf">futex_wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span>

<span class="c1">//唤醒n个在uaddr指向的锁变量上挂起等待的进程</span>
<span class="kt">int</span> <span class="nf">futex_wake</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">futex_wait</code>是用来协助加锁操作的。线程调用<code class="language-plaintext highlighter-rouge">pthread_mutex_lock</code>，如果发现锁的值不是0，就会调用<code class="language-plaintext highlighter-rouge">futex_wait</code>，告知内核，线程须要等待在<code class="language-plaintext highlighter-rouge">uaddr</code>对应的锁上，请将线程挂起。<strong>内核会建立与<code class="language-plaintext highlighter-rouge">uaddr</code>地址对应的等待队列。</strong><ul><li>为什么需要内核维护等待队列？因为一旦互斥量的持有者线程释放了互斥量，就需要及时通知那些等待在该互斥量上的线程。如果没有等待队列，内核将无法通知到那些正陷入阻塞的线程。<li><strong>如果整个系统有很多这种互斥量，是不是需要为每个<code class="language-plaintext highlighter-rouge">uaddr</code>地址建立一个等待队列呢？事实上不需要</strong>。理论上讲，<code class="language-plaintext highlighter-rouge">futex</code>只需要在内核之中维护一个队列就够了，当线程释放互斥量时，可能会调用<code class="language-plaintext highlighter-rouge">futex_wake</code>，此时会将<code class="language-plaintext highlighter-rouge">uaddr</code>传进来，内核会去遍历该队列，查找等待在该<code class="language-plaintext highlighter-rouge">uaddr</code>地址上的线程，并将相应的线程唤醒。</ul><li><code class="language-plaintext highlighter-rouge">futex_wake</code>操作是用来实现解锁操作的。glibc就是使用该操作来实现互斥量的解锁函数<code class="language-plaintext highlighter-rouge">pthread_mutex_unlock</code>的。当线程执行完临界区代码，解锁时，内核需要通知那些正在等待该锁的线程。这时候就需要发挥<code class="language-plaintext highlighter-rouge">futex_wake</code>操作的作用了。<code class="language-plaintext highlighter-rouge">futex_wake</code>的第二个参数<code class="language-plaintext highlighter-rouge">n</code>，表明需要唤醒几个睡眠的线程。对于互斥量而言，该值总是1，表示唤醒1个线程。当然，也可以唤醒所有正在等待该锁的线程，但是这样做并无好处，因为被唤醒的多个线程会再次竞争，却只能有一个线程抢到锁，这时其他线程不得不再次睡去，徒增了很多开销。</ul><p><a href="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230423212039.png" class="popup img-link "><img data-src="/assets/blog_res/2022-09-05-%E6%9D%82%E8%AE%B03.assets/QQ%E6%88%AA%E5%9B%BE20230423212039.png" alt="QQ截图20230423212039" class="lazyload" data-proofer-ignore></a></p><p>然而，实际上，我们会使用下面这个大的<code class="language-plaintext highlighter-rouge">futex</code>系统调用，通过置入选项的方式来决定是调用<code class="language-plaintext highlighter-rouge">futex_wait</code>还是<code class="language-plaintext highlighter-rouge">futex_wake</code></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">long</span> <span class="nf">syscall</span><span class="p">(</span><span class="n">SYS_futex</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">futex_op</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">,</span>
                    <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>   <span class="cm">/* or: uint32_t val2 */</span>
                    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val3</span><span class="p">);</span>
</pre></table></code></div></div><p>futex无论在什么平台都是32位。同时，第二个参数<code class="language-plaintext highlighter-rouge">futex_op</code>用来指明到底要等待还是唤醒。</p><h2 id="futex的等待队列"><span class="mr-2">Futex的等待队列</span><a href="#futex的等待队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们说过，<code class="language-plaintext highlighter-rouge">futex</code>变量创建于用户空间，在进程或线程间共享，当进程或线程想要进入临界区时，通常会判断<code class="language-plaintext highlighter-rouge">futex</code>变量是否满足条件，若满足则成功进入临界区，否则则阻塞在该<code class="language-plaintext highlighter-rouge">futex</code>变量上；当进程或线程将要离开临界区时，则会唤醒阻塞在<code class="language-plaintext highlighter-rouge">futex</code>变量上的其他进程或线程。<strong>在内核中通过<code class="language-plaintext highlighter-rouge">struct futex_q</code>结构将一个<code class="language-plaintext highlighter-rouge">futex</code>变量与一个挂起的进程（线程）关联起来</strong>，其定义以及关键成员的作用如下：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">futex_q</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">plist_node</span> <span class="n">list</span><span class="p">;</span>        <span class="c1">//链表节点</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>      <span class="c1">//挂起在该futex变量关联的进程（线程）</span>
    <span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock_ptr</span><span class="p">;</span>          <span class="c1">//自旋锁，控制链表访问</span>
    <span class="k">union</span> <span class="n">futex_key</span> <span class="n">key</span><span class="p">;</span>           <span class="c1">//futex变量地址标识</span>

    <span class="c1">//下面三个与优先级继承相关，在此不多介绍</span>
    <span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">rt_waiter</span><span class="p">;</span>
    <span class="k">union</span> <span class="n">futex_key</span> <span class="o">*</span><span class="n">requeue_pi_key</span><span class="p">;</span>
     
    <span class="n">u32</span> <span class="n">bitset</span><span class="p">;</span>                    <span class="c1">//类似掩码匹配</span>
<span class="p">};</span>
</pre></table></code></div></div><p><strong>内核中通过一个全局哈希表来维护所有挂起阻塞在<code class="language-plaintext highlighter-rouge">futex</code>变量上的进程（线程），不同的<code class="language-plaintext highlighter-rouge">futex</code>变量会根据其地址标识计算出一个hash key并定位到一个bucket上，因此挂起阻塞在同一个<code class="language-plaintext highlighter-rouge">futex</code>变量的所有进程（线程）会对应到同一个bucket上，数据结构如下：</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//bucket</span>
<span class="k">struct</span> <span class="nc">futex_hash_bucket</span> <span class="p">{</span>
    <span class="c1">//当前自旋等待哈希桶的waiter数目</span>
	<span class="n">atomic_t</span> <span class="n">waiters</span><span class="p">;</span>

    <span class="c1">//自旋锁，用于控制chain的访问，</span>
    <span class="c1">//struct futex_q中lock_ptr，就是引用其所在的bucket的自旋锁</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="c1">//优先级链，与传统等待队列不同，futex使用优先级链表来实现等待队列，</span>
    <span class="c1">//是为了实现优先级继承，从而解决优先级翻转问题</span>
	<span class="k">struct</span> <span class="nc">plist_head</span> <span class="n">chain</span><span class="p">;</span>
<span class="p">}</span> <span class="n">____cacheline_aligned_in_smp</span><span class="p">;</span>

<span class="c1">//全局哈希表</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="nc">futex_hash_bucket</span> <span class="o">*</span><span class="n">queues</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>            <span class="n">hashsize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__futex_data</span> <span class="n">__read_mostly</span> <span class="nf">__aligned</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="cp">#define futex_queues   (__futex_data.queues)
#define futex_hashsize (__futex_data.hashsize)
</span></pre></table></code></div></div><p>参考来自<a href="https://www.openeuler.org/zh/blog/wangshuo/Linux_Futex_Principle_Analysis/Linux_Futex_Principle_Analysis.html">这里</a>，<a href="https://pzh2386034.github.io/Black-Jack/pthread/2020/02/15/linux%E9%94%81%E5%AE%9E%E7%8E%B0-futex%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0/">这里</a>，Linux环境编程 7.7.4 和 <a href="https://www.bilibili.com/video/BV1HN41197Ko/?p=9&amp;share_source=copy_web&amp;vd_source=d59bd34fbf591f4881d60ad6a8742eba">南京大学操作系统课程2021P9</a></p><p>futex 的基本思想是<strong>竞争态总是很少发生的，只有在竞争态才需要进入内核，否则在用户态即可完成</strong>。futex的两个目标是：</p><ul><li>尽量避免系统调用；(因为需要切换到内核态。比如线程的挂起和唤醒都需要切换至内核态)<li>避免不必要的上下文切换（导致的TLB失效等）。</ul><h2 id="不同操作系统的futex区别"><span class="mr-2">不同操作系统的futex区别</span><a href="#不同操作系统的futex区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://outerproduct.net/futex-dictionary.html</p><p>当做扩展阅读看看就行</p><h1 id="自旋锁的底层实现">自旋锁的底层实现</h1><p>区别就是不挂起，一直使用CAS尝试上锁。</p><h1 id="自旋锁和互斥锁的区别">自旋锁和互斥锁的区别</h1><ul><li><p><strong>自旋锁是一种非阻塞锁</strong>，也就是说，<strong>如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁</strong>。<strong>不会引起切换</strong></p><li><p><strong>互斥量是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行</strong>。<strong>会引起切换</strong></p><li><p>两种锁适用于不同场景：</p><ul><li>如果是多核处理器，<strong>如果预计线程等待锁的时间很短，短到比线程两次上下文切换时间要少的情况下，使用自旋锁是划算的。</strong><li>如果是多核处理器，<strong>如果预计线程等待锁的时间较长，至少比两次线程上下文切换的时间要长，建议使用互斥量。</strong><li>如果是单核处理器，一般建议不要使用自旋锁。因为，在同一时间只有一个线程是处在运行状态，那如果运行线程发现无法获取锁，只能等待解锁，但因为自身不挂起，所以那个获取到锁的线程没有办法进入运行状态，只能等到运行线程把操作系统分给它的时间片用完，才能有机会被调度。这种情况下使用自旋锁的代价很高。<li><strong>如果加锁的代码经常被调用，但竞争情况很少发生时，应该优先考虑使用自旋锁，自旋锁的开销比较小，互斥量的开销较大</strong></ul></ul><p>自旋锁的真正使用场景应该是操作系统内核的并发数据结构。</p><h1 id="可重入锁和不可重入锁">可重入锁和不可重入锁</h1><p>简单来说我们说过同一个线程对一个锁上锁两次会被死锁。因为第二次进行上锁的时候会尝试拿锁，但是一直拿不到。所以线程会被挂起。除非其他线程帮我们解锁。（查看笔试题整理）</p><ul><li><p>可重入锁（reentrant lock）：</p><ul><li>可重入锁简单如字面而言，就是可以重新进入的锁，允许同一进程多次获取同一把锁，是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提是同一个对象或者class），这样的锁就叫做可重入锁，也叫做递归锁。<li><code class="language-plaintext highlighter-rouge">recursive_mutex</code></ul><li>不可重入锁（non-reentrant lock）：<ul><li>不可重入锁与可重入锁相反，如果当前线程已经获取了该锁，那么再次尝试获取该锁时，就会出现死锁的状况，被阻塞。在这个线程解锁之前，其他线程无法用这个锁再来加锁。</ul><li>可重入锁不与可重入锁的区别：<ul><li><strong>不可重入锁只判断这个锁有没有被锁上</strong>，只要被锁上申请锁的线程都会被要求等待。实现起来较为简单。而<strong>可重入锁不仅要判断锁有没有被锁上，还会判断锁是谁锁上的，当就是自己锁上的时候，那么他依旧可以再次访问临界资源，并把加锁次数加一。</strong></ul></ul><h1 id="cas-的底层实现">CAS 的底层实现</h1><p>汇编指令<code class="language-plaintext highlighter-rouge">LOCK CMPXCHG </code>让CPU锁住cache line。获取该cache line的独占权来针对原子变量进行原子操作。</p><p>https://www.cnblogs.com/kendoziyu/p/16571887.html</p><p>https://stackoverflow.com/questions/27837731/is-x86-cmpxchg-atomic-if-so-why-does-it-need-lock</p><h1 id="cas-的缺点">CAS 的缺点</h1><ul><li><p>自旋时间太长</p><ul><li>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。</ul><li><p>只能保证一个共享变量原子操作</p><ul><li>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高低位。（https://www.cnblogs.com/wait-pigblog/p/9350569.html）</ul><li><p>ABA问题</p><ul><li>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：<strong>如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，只是又回到了原来的值而已，这就是所谓的ABA问题。</strong>对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</ul></ul><h1 id="实现一个简单的自旋锁">实现一个简单的自旋锁</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SpinLock</span> <span class="p">{</span>

<span class="nl">public:</span>
    <span class="n">SpinLock</span><span class="p">()</span> <span class="o">:</span> <span class="n">flag_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">expect</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//注意，这里就是为什么这个代码不会发生竞争。这里的expect是局部变量</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">//这里一定要将expect复原，因为如果当前flag是true，expect是false，不相等的话exchange会把expect换成当前flag值也就是换成true。如果不换回去就拉稀了。</span>
            <span class="n">expect</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">flag_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">flag_</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">SpinLock</span> <span class="n">myLock</span><span class="p">;</span>
    <span class="n">myLock</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>

    <span class="c1">//do something</span>

    <span class="n">myLock</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们看一下原理。</p><ol><li>首先我们初始设定类内的原子变量为false。<li>当我们上锁的时候：<ol><li>第一个线程进来，进行<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>判断。此时发现当前值和<code class="language-plaintext highlighter-rouge">expect</code>值相同。则设定当前值为<code class="language-plaintext highlighter-rouge">true</code>。<li>又因为返回值不为<code class="language-plaintext highlighter-rouge">false</code>，不进入<code class="language-plaintext highlighter-rouge">while</code>循环。跳出。<li>剩下的线程进来的时候，发现当前值是<code class="language-plaintext highlighter-rouge">true</code>，和<code class="language-plaintext highlighter-rouge">expect</code>值不同。则修改期望值（<code class="language-plaintext highlighter-rouge">expect</code>）为当前值也就是<code class="language-plaintext highlighter-rouge">true</code>。同时返回值是<code class="language-plaintext highlighter-rouge">false</code>，进入<code class="language-plaintext highlighter-rouge">while</code>循环忙等待。<li>此时进入循环后必须继续将<code class="language-plaintext highlighter-rouge">expect</code>设置为<code class="language-plaintext highlighter-rouge">false</code>。因为我们之前把<code class="language-plaintext highlighter-rouge">expect</code>修改为<code class="language-plaintext highlighter-rouge">true</code>了</ol><li>直到拿到锁的线程调用<code class="language-plaintext highlighter-rouge">unlock</code>，设置当前值为<code class="language-plaintext highlighter-rouge">false</code>。这时候其他线程之一发现，当前值和<code class="language-plaintext highlighter-rouge">expect</code>值相同，继续重复第二步</ol><ul><li>注意，我们的<code class="language-plaintext highlighter-rouge">expect</code>是<code class="language-plaintext highlighter-rouge">lock</code>函数内的局部变量。<strong>意思就是每一个进入到该函数的线程都会有一个自己独有的<code class="language-plaintext highlighter-rouge">expect</code></strong>。所以不会发生一个线程修改<code class="language-plaintext highlighter-rouge">expect</code>是<code class="language-plaintext highlighter-rouge">true</code>之后，在修改回<code class="language-plaintext highlighter-rouge">false</code>之前另一个线程进来发现已经是<code class="language-plaintext highlighter-rouge">true</code>了直接就拿到了锁的这个情况。</ul><p>https://www.cnblogs.com/FateTHarlaown/p/9170474.html</p><p><strong>更为精简和高性能的自旋锁：</strong></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SpinLock</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">SpinLock</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        
        <span class="kt">void</span> <span class="n">lock</span><span class="p">(){</span>
            <span class="k">while</span><span class="p">(</span><span class="n">_flag</span><span class="p">.</span><span class="n">test_and_set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">unlock</span><span class="p">(){</span>
            <span class="n">_flag</span><span class="p">.</span><span class="n">clear</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">atomic_flag</span> <span class="n">_flag</span> <span class="o">=</span> <span class="n">ATOMIC_FLAG_INIT</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>首先我们把<code class="language-plaintext highlighter-rouge">atomic</code>变量换成了简单的<code class="language-plaintext highlighter-rouge">atomic_flag</code>。<li>注意，在<code class="language-plaintext highlighter-rouge">lock</code>函数中，<code class="language-plaintext highlighter-rouge">test_and_set</code>的作用是给<code class="language-plaintext highlighter-rouge">flag</code>原子赋值为<code class="language-plaintext highlighter-rouge">true</code>并返回之前的值。也就是说当有线程抢锁的时候，发现当前的<code class="language-plaintext highlighter-rouge">flag</code>已经是<code class="language-plaintext highlighter-rouge">true</code>了，就再次设定为<code class="language-plaintext highlighter-rouge">true</code>并且返回当前的<code class="language-plaintext highlighter-rouge">true</code>值。<code class="language-plaintext highlighter-rouge">while</code>循环就是要判断如果返回的是<code class="language-plaintext highlighter-rouge">true</code>就一直循环等待。<li>内存序更为合适：我们反复强调了<code class="language-plaintext highlighter-rouge">acquire</code>理解为<code class="language-plaintext highlighter-rouge">lock</code>。也就是针对这一行原子操作之后的操作不允许前移。<code class="language-plaintext highlighter-rouge">release</code>操作理解为<code class="language-plaintext highlighter-rouge">unlock</code>，也就是针对这一行原子操作之前的操作不允许后移。如果使用全序模型则会降低性能。但是这里我们并不阻止合法的指令重排。</ul><p>我们可以对任何带有<code class="language-plaintext highlighter-rouge">lock()</code>和<code class="language-plaintext highlighter-rouge">unlock()</code>函数的互斥类使用<code class="language-plaintext highlighter-rouge">lock_guard</code>。看一眼源码就知道了。</p><h1 id="前向声明">前向声明</h1><p>前向声明可以解决两个类互相包含的问题。因为前向声明属于不完整类型，所以有如下限制：</p><ul><li>可以<ul><li>将成员声明为指向不完整类型的<strong>指针或引用</strong><li><strong>声明</strong>接受/返回不完整类型的函数或方法<li><strong>定义</strong>接受/返回指向不完整类型的指针/引用的函数或方法（但不使用其成员）</ul><li>不可以<ul><li>将其用作基类<li>用它来声明一个成员（使用对象）<li><strong>使用该类型定义函数或方法</strong><li>使用其方法或字段，实际上试图解引用类型不完整的变量<ul><li>这里就是使用这个前向声明类型的指针然后对其解引用使用其类型包含的数据或方法。</ul></ul><li><strong>实际上只需要分文件或者类外编写函数的定义就可以了。也就是实际使用的时候等到类已经被正式定义完毕就可以了。</strong></ul><h2 id="delete-作用于不完整类型是不合法的"><span class="mr-2">delete 作用于不完整类型是不合法的</span><a href="#delete-作用于不完整类型是不合法的" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://en.cppreference.com/w/cpp/language/delete.html</p><blockquote><p>如果被删除的对象在删除时具有不完整的类类型，并且完整的类具有非平凡的析构函数或释放函数，则行为未定义（直到 C++26）程序格式不正确（自 C++26 起）。</p></blockquote><h1 id="模板相关">模板相关</h1><h2 id="类模板定义规则"><span class="mr-2">类模板定义规则</span><a href="#类模板定义规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>注意c++类模板定义方法 类模板没有自动类型推导。所以只要使用了就必须显式指定参数类型。<li>但是类模板可以有默认参数和偏特化<li>类模板中的成员函数只有在调用的时候才会被创建。因为在编译阶段，编译器无法确认模板的参数类型，所以无法创建模板类成员函数</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="err">模板参数表</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="err">类名</span><span class="p">{</span>
    <span class="c1">// 类定义．．．．．．</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>注意全特化和偏特化的语法</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="n">T1</span> <span class="n">data1</span><span class="p">;</span>
    <span class="n">T2</span> <span class="n">data2</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//全特化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">data1</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//偏特化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">data1</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="模板调用顺序-规则"><span class="mr-2">模板调用顺序 规则</span><a href="#模板调用顺序-规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>类模板： 对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类&gt;偏特化类&gt;主版本模板类。这样的优先级顺序对性能也是最好的。<li>函数模板： 如果函数模板和普通函数都可以实现，优先调用普通函数 <strong>可以使用空模板参数列表来强制调用函数模板</strong> 函数模板也可以重载 如果函数版可以产生更好的匹配，则优先调用函数模板.<ul><li><strong>函数模板只能全特化</strong></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"普通函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"模板函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">c</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"重载的模板函数"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//输出普通函数</span>
    <span class="n">test</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//使用空模板参数列表 输出模板函数</span>
    <span class="n">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//输出重载的模板函数</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="模板模板参数"><span class="mr-2">模板模板参数</span><a href="#模板模板参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>模板的模板参数的经典应用是在某些自定义指定储存容器类型的时候不指定元素类型。</p><ul><li>最基本的举例</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">container</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span> <span class="c1">// 最基本的举例</span>
<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="n">container</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">;</span>
    <span class="n">container</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span> <span class="n">a2</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><ul><li>茴字的三种写法, 都可以</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Container</span><span class="p">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="p">&gt;</span>
</pre></table></code></div></div><ul><li>更好的理解的写法:</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">Container</span><span class="p">&gt;</span>
</pre></table></code></div></div><ul><li>更多例子参见template_template_parameter_*文件</ul><h2 id="模板参数按值传递还是引用传递"><span class="mr-2">模板参数按值传递还是引用传递</span><a href="#模板参数按值传递还是引用传递" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://vinkle.top/2021/06/12/cpp-template-7/#7-%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92</p><h2 id="非类型模板参数"><span class="mr-2">非类型模板参数</span><a href="#非类型模板参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这块之前居然忽略了。必须简单说一下</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">){</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>我们都知道模板参数一般都是类型。比如这里，T就是int。是类型。</p><p>但是如果我们有时候需要一些特殊情况， 例如想要传点奇怪东西的时候。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">MAXSIZE</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func1</span><span class="p">(</span><span class="n">T</span> <span class="n">obj</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">MAXSIZE</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 			<span class="c1">//干啥了不解释了 忽略即可</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这里的<code class="language-plaintext highlighter-rouge">int MAXSIZE</code>就是非类型模板参数。因为他不是类型，而是变量。</p><p>使用非类型模板参数是有限制的。通常它们只能是：</p><ol><li>整型常量或字面值（包含枚举，或可隐式转换的比如<code class="language-plaintext highlighter-rouge">bool</code>）（<code class="language-plaintext highlighter-rouge">string</code> <code class="language-plaintext highlighter-rouge">double</code>都不可以。前者是类对象，后者是浮点数）<li>指向对象/函数/成员变量的指针<li>对象/函数的左值引用<li><code class="language-plaintext highlighter-rouge">std::nullptr_t</code></ol><p>当传递对象的指针或者引用作为模板参数时，对象不能是字符串常量，临时变量或者数据成员以及其他子对象。由于C++17之前，C++每次版本更新都会放宽以上限制，因此还有一些针对不同版本的限制：</p><ul><li>C++11中，对象必须要有外部链接<li>C++14中，对象必须是外部链接或者内部链接</ul><p>所以：传入的<code class="language-plaintext highlighter-rouge">s</code>必须是常量。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>	<span class="c1">//必须是const</span>
<span class="n">func1</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">s</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">func2</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//或者直接传入字面值。</span>
</pre></table></code></div></div><h3 id="搭配类模板偏特化的小例子"><span class="mr-2">搭配类模板偏特化的小例子</span><a href="#搭配类模板偏特化的小例子" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">option</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">myclass</span><span class="p">;</span> <span class="c1">//主模板不实现</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">myclass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nb">true</span><span class="o">&gt;</span><span class="p">{</span> <span class="c1">//偏特化1，注意语法。T在这里依旧要写上。</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"true one"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">myclass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span><span class="p">{</span> <span class="c1">//偏特化2，注意语法。T在这里依旧要写上。</span>
    <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"false one"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">myoption</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">myclass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span> <span class="c1">//直接使用字面值</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
    <span class="n">myclass</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">myoption</span><span class="o">&gt;</span> <span class="n">obj1</span><span class="p">;</span> <span class="c1">//或必须用const常量变量。</span>
    <span class="n">obj1</span><span class="p">.</span><span class="n">func</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="enable_if"><span class="mr-2">enable_if</span><a href="#enable_if" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>简单看一下原型</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="o">=</span><span class="kt">void</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">enable_if</span> <span class="p">{</span>
<span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">///&lt; 第一个模板参数为 true</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>           <span class="c1">///&lt; type 才有定义</span>
<span class="p">};</span>
</pre></table></code></div></div><p>意思就是，前面的表达式为真，后面的类型定义才有意义。</p><p>一般三种用法：</p><ul><li>控制函数返回类型<li>校验函数模板参数类型<li>类型偏特化</ul><p>这里就随便写个控制函数返回类型的例子：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">stat</span><span class="p">&gt;</span> <span class="c1">//这里是非模板类型参数。上面提到了。注意一下</span>
<span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">stat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">checkstate</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"type is bool"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">stat</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">stat</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">checkstate</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"type is int"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">bool</span> <span class="n">stat</span><span class="p">&gt;</span>			<span class="c1">//bool也可以。隐式转换为整型了，但是必须要常量。</span>
<span class="k">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span><span class="n">stat</span> <span class="o">==</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">checkstate1</span><span class="p">(){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"type is int"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">myobj</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 	<span class="c1">//必须是const</span>
    <span class="n">checkstate</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">();</span>	<span class="c1">//输出"type is bool" </span>
    <span class="n">checkstate</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">();</span>		<span class="c1">//输出"type is int" </span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意事项：返回类型前必须加<code class="language-plaintext highlighter-rouge">typename</code>来告知<code class="language-plaintext highlighter-rouge">enable_if::type</code>是个类型。还有就是非模板类型参数的限制。</p><h2 id="函数的变长参数模板"><span class="mr-2">函数的变长参数模板</span><a href="#函数的变长参数模板" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>基本定义</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span> 
<span class="c1">// 如果函数参数列表中一个参数的类型是一个模板参数包,</span>
<span class="c1">// 则此参数也是一个函数参数包</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">rest</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>C++17之前的写法：因为没有折叠表达式</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print</span> <span class="p">(){</span>
<span class="c1">//必须要有无参重载，否则会无限递归。也就是最后一次无参无法被调用。</span>
<span class="c1">//最后一次被解包后，参数包会为空。所以会调用无参函数。</span>
<span class="p">}</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span> <span class="p">(</span><span class="n">T</span> <span class="n">firstArg</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">firstArg</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//print first argument</span>
    <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span> <span class="c1">// call print() for remaining arguments</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="s">"b23"</span><span class="p">,</span> <span class="mf">1.123</span><span class="p">,</span> <span class="s">"HahaahaH"</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>C++17之后的写法：有了折叠表达式</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="c1">//要有单参打印的重载。不然会无限调用。</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
    <span class="p">(</span><span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">),...);</span> <span class="c1">//这里外部一定要加括号。注意语法</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="s">"b23"</span><span class="p">,</span> <span class="mf">1.123</span><span class="p">,</span> <span class="s">"HahaahaH"</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>多种变长参数模板可以同时存在 尽管直观看起来会有二义性</strong></ul><h3 id="搭配列表初始化"><span class="mr-2">搭配列表初始化</span><a href="#搭配列表初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>函数变长参数模板搭配列表初始化。<ul><li>这个函数会返回一个<code class="language-plaintext highlighter-rouge">T</code>类型的<code class="language-plaintext highlighter-rouge">vector</code>，元素是<code class="language-plaintext highlighter-rouge">args</code></ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">Args</span><span class="o">&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">args</span><span class="p">...};</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="k">auto</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span><span class="n">vec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
输出：
1
2
3
4
5
6
7
*/</span>
</pre></table></code></div></div><h2 id="类的变长参数模板"><span class="mr-2">类的变长参数模板</span><a href="#类的变长参数模板" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>基本定义：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">Variadic</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><p>其模板实例化：</p><ul><li><p>0个参数的模板类 <code class="language-plaintext highlighter-rouge">Variadic&lt;&gt; zero;</code></p><li><p>多个参数的模板类 <code class="language-plaintext highlighter-rouge">Variadic&lt;int, double, std::string, std::list&lt;int&gt;&gt; sample;</code></p></ul></ul><h2 id="模板类对象做为函数参数传入"><span class="mr-2">模板类对象做为函数参数传入</span><a href="#模板类对象做为函数参数传入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">T1</span> <span class="n">_a</span><span class="p">;</span>
    <span class="n">T2</span> <span class="n">_b</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">_a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">testprint1</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//方法1 显式指定传入类型</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_a</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">testprint2</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//方法2 使用参数模板</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_a</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">testprint3</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">){</span> <span class="c1">//方法3 利用函数模板的自动推导特性</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_a</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">testprint1</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">testprint2</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">testprint3</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="类模板-模板类-的继承-子类调用父类构造函数"><span class="mr-2">类模板 模板类 的继承 子类调用父类构造函数</span><a href="#类模板-模板类-的继承-子类调用父类构造函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>当有多继承的时候，子类继承的父类必须全部拥有默认无参构造函数。因为创建子类对象时，一定会先调用父类构造函数。如果子类的构造函数没有指明调用父类的有参构造的话，就会调用默认构造。但是一旦类有了一个构造函数，编译器就不会自动生成默认构造函数，导致编译失败。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">T1</span> <span class="n">_a</span><span class="p">;</span>
    <span class="n">T2</span> <span class="n">_b</span><span class="p">;</span>

    <span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">_a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">showitem</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>


<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T3</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T4</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span><span class="p">{</span> <span class="c1">//!继承模板父类，子类父类都要是模板类。而且要显式指定父类模板类型。</span>
<span class="nl">public:</span>
    <span class="c1">// T1 _a;   //!如果子类也有自己的_a 和_b变量的话 那就不能调用父类构造函数赋值。</span>
                <span class="c1">//!想一下，子类自己的东西怎么可能让父类构造函数赋值？</span>
                <span class="c1">//@所以调用父类构造函数赋值其实相当于给子类的父类成分赋值。</span>
    <span class="c1">// T2 _b;</span>
    <span class="n">T3</span> <span class="n">_c</span><span class="p">;</span>
    <span class="n">T4</span> <span class="n">_d</span><span class="p">;</span>
    <span class="c1">//test1(T3 a, T4 b) : _a(a), _b(b) {}</span>
    <span class="n">test1</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">,</span> <span class="n">T3</span> <span class="n">c</span><span class="p">,</span> <span class="n">T4</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">),</span><span class="n">_c</span><span class="p">(</span><span class="n">c</span><span class="p">),</span><span class="n">_d</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="c1">//调用父类构造函数赋值 //!记得调用模板类父类构造函数的时候要显式指定数据类型</span>
    <span class="p">{</span>
        <span class="c1">//!可以用构造列表也可以普通构造函数</span>
        <span class="c1">// _c = c; </span>
        <span class="c1">// _d = d;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">showitem</span><span class="p">(){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_a</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_b</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_c</span> <span class="o">&lt;&lt;</span> <span class="s">","</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_d</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">showitem</span><span class="p">();</span>
    <span class="n">test1</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">test1</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">showitem</span><span class="p">();</span>
    
    <span class="c1">//指针和对象都可以</span>
    <span class="n">test</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bb</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">bb</span><span class="p">.</span><span class="n">showitem</span><span class="p">();</span>
    <span class="n">test1</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">cc</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">cc</span><span class="p">.</span><span class="n">showitem</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="普通类的子类调用父类构造函数长这样"><span class="mr-2">普通类的子类调用父类构造函数长这样</span><a href="#普通类的子类调用父类构造函数长这样" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">A</span><span class="p">(){}</span>
        <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span><span class="n">m_a</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">virtual</span><span class="o">~</span><span class="n">A</span><span class="p">(){}</span>
    <span class="kt">int</span> <span class="n">m_a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">B</span><span class="p">(){}</span>
        <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">m_b</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span>
        <span class="n">B</span><span class="p">(</span><span class="kt">int</span> <span class="n">no</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="n">A</span><span class="p">(</span><span class="n">no</span><span class="p">),</span><span class="n">m_b</span><span class="p">(</span><span class="n">x</span><span class="p">){}</span> <span class="c1">//子类调用父类构造。必须用初始化列表。</span>
        <span class="o">~</span><span class="n">B</span><span class="p">(){}</span>
        <span class="kt">int</span> <span class="n">m_b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">m_a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="模板类-类模板-成员函数-类外实现"><span class="mr-2">模板类 类模板 成员函数 类外实现</span><a href="#模板类-类模板-成员函数-类外实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="n">T1</span> <span class="n">_a</span><span class="p">;</span>
    <span class="n">T2</span> <span class="n">_b</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">){}</span> <span class="c1">//构造1</span>
    <span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">){}</span> <span class="c1">//构造2</span>
    <span class="kt">void</span> <span class="nf">func1</span><span class="p">();</span> <span class="c1">//无参函数1</span>
    <span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">);</span> <span class="c1">//有参函数2</span>
<span class="p">};</span>

<span class="cm">/*
类模板 成员函数 类外实现
头部要加模板
作用域部分要显式指明数据类型
*/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;::</span><span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">_a</span><span class="p">(</span><span class="n">a</span><span class="p">){}</span> <span class="c1">//构造1 使用初始化列表</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span> 
<span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;::</span><span class="n">test</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">,</span> <span class="n">T2</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//构造2</span>
    <span class="n">_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;::</span><span class="n">func1</span><span class="p">(){</span> <span class="c1">//无参函数1</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"func1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">test</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&gt;::</span><span class="n">func2</span><span class="p">(</span><span class="n">T1</span> <span class="n">a</span><span class="p">){</span> <span class="c1">//有参函数2</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"func2"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="万能引用相关"><span class="mr-2">万能引用相关</span><a href="#万能引用相关" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>参见杂记。</p><h1 id="auto">auto</h1><ul><li>auto 变量必须在定义时初始化，这类似于const关键字。<li>定义在一个auto序列的变量必须始终推导成同一类型。例如：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">a4</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">a5</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">a6</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span><span class="c1">//正确</span>
<span class="k">auto</span> <span class="n">b4</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">b5</span> <span class="o">=</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">b6</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span><span class="c1">//错误,没有推导为同一类型</span>
</pre></table></code></div></div><ul><li><strong>如果初始化表达式是引用，则去除引用语义。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
 
<span class="k">auto</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span><span class="c1">//c的类型为int而非int&amp;（去除引用）</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//100</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//10</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//10</span>
</pre></table></code></div></div><p>我们看到了即使<code class="language-plaintext highlighter-rouge">b</code>是<code class="language-plaintext highlighter-rouge">a</code>的引用，我们使用<code class="language-plaintext highlighter-rouge">b</code>初始化<code class="language-plaintext highlighter-rouge">c</code>的时候依旧使用了值语义。也就是<code class="language-plaintext highlighter-rouge">c</code>是一个独立变量。更改<code class="language-plaintext highlighter-rouge">c</code>的值不影响<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code></p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

<span class="k">auto</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span><span class="c1">//c的类型为int&amp;</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//100</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//100</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//100</span>
</pre></table></code></div></div><ul><li><strong>如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span>  <span class="n">b1</span><span class="o">=</span> <span class="n">a1</span><span class="p">;</span> <span class="c1">//b1的类型为int而非const int（去除const）</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">;</span><span class="c1">//此时c1的类型为const int</span>
<span class="n">b1</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//合法</span>
<span class="n">c1</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span><span class="c1">//非法</span>
</pre></table></code></div></div><ul><li>如果auto关键字带上&amp;，则不去除const语意。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">a2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="k">auto</span><span class="o">&amp;</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span><span class="c1">//因为auto带上&amp;，故不去除const，b2类型为const int</span>
<span class="n">b2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//非法</span>
</pre></table></code></div></div><ul><li><strong>初始化表达式为数组时，auto关键字推导类型（退化）为指针。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a3</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">a3</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">b3</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//int *</span>
</pre></table></code></div></div><ul><li>若表达式为数组且auto带上&amp;，则推导类型为数组类型</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a7</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span>
<span class="k">auto</span> <span class="o">&amp;</span> <span class="n">b7</span> <span class="o">=</span> <span class="n">a7</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">b7</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//int[3]</span>
</pre></table></code></div></div><ul><li><strong>时刻要注意auto并不是一个真正的类型。</strong><ul><li>auto仅仅是一个占位符，它并不是一个真正的类型，不能使用一些以类型为操作数的操作符，如sizeof或者typeid</ul></ul><p><strong>所以我们才会有<code class="language-plaintext highlighter-rouge">auto&amp; </code>, <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code>，<code class="language-plaintext highlighter-rouge">const auto</code>,<code class="language-plaintext highlighter-rouge">const auto&amp;</code>等等。还可以有<code class="language-plaintext highlighter-rouge">auto*</code>，也可以被cv修饰</strong></p><ul><li><strong>注意在使用增强for循环遍历容器元素时，如果声明为auto则最好变成<code class="language-plaintext highlighter-rouge">const auto&amp; </code>防止修改和拷贝。</strong><ul><li>使用增强for循环遍历容器元素时，<code class="language-plaintext highlighter-rouge">auto</code>的类型是容器内元素的类型。所以需要加<code class="language-plaintext highlighter-rouge">const</code>或<code class="language-plaintext highlighter-rouge">&amp;</code></ul></ul><h2 id="auto是万能引用"><span class="mr-2">auto&amp;&amp;是万能引用</span><a href="#auto是万能引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>格外注意：auto&amp;&amp;是万能引用，除了从花括号包围的初始化器列表推导时除外</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span><span class="c1">//这个不是万能引用。（初始化器列表的特殊情形）</span>
</pre></table></code></div></div><p>其他细节参见列表初始化。</p><h1 id="c17-复制省略技术">C++17 复制省略技术</h1><ol><li><p>返回值优化（RVO），即通过将返回值所占空间的分配地点从被调用端转移至调用端的手段来避免拷贝操作。返回值优化包括具名返回值优化（NRVO）与无名返回值优化（URVO），两者的区别在于返回值是具名的局部变量还是无名的临时对象。</p><li><p><strong>右值拷贝优化，当某一个类类型的临时对象被拷贝赋予同一类型的另一个对象时，通过直接利用该临时对象的方法来避免拷贝操作。</strong></p><ul><li>在一个变量的等号右侧是 <strong>临时变量(prvalue)</strong> 的时候，这里会用 direct-initalize，而不是尝试使用 copy/move initialize。对于一些没有拷贝构造或移动构造的对象，如<code class="language-plaintext highlighter-rouge">unique_ptr</code>、<code class="language-plaintext highlighter-rouge">atomic</code>，<code class="language-plaintext highlighter-rouge">std::array</code>等可以使用等号初始化了。但是前提是右侧是一个临时对象以满足右值拷贝优化。</ul></ol><p>所以</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">9</span><span class="p">};</span>  <span class="c1">//c++14 error， C++17 OK</span>
<span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span><span class="c1">//c++14 error， C++17 OK</span>
</pre></table></code></div></div><h2 id="注意一个常见误区"><span class="mr-2">注意一个常见误区</span><a href="#注意一个常见误区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="p">};</span>

<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>

<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">func2</code>可以而<code class="language-plaintext highlighter-rouge">func1</code>编译错误的原因是因为编译器试图将 <code class="language-plaintext highlighter-rouge">p</code>拷贝到一个新的 <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;int&gt;</code> 中。然而，由于 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 不允许拷贝，所以编译器会报错，提示尝试使用被删除的拷贝构造函数。而<code class="language-plaintext highlighter-rouge">func2</code>是使用了移动构造。所以这里和RVO其实没有关系。当然了，如果可行的话编译器会把它优化为NRVO.</p><p>gcc14引入 <code class="language-plaintext highlighter-rouge">-Wnrvo</code> 帮助提醒优化返回值</p><h2 id="rvo是编译时优化"><span class="mr-2">RVO是编译时优化</span><a href="#rvo是编译时优化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>##　理解RVO语义</p><blockquote><p><strong>进行复制消除时，实现将被省略的复制/移动 (C++11 起)操作的源和目标单纯地当做指代同一对象的两种不同方式</strong>，而该对象将在假如不进行优化时两个对象中后被销毁的对象销毁时销毁（但如果被选择的构造函数的形参是对象类型的右值引用，那么该销毁发生于目标对象本应被销毁时） (C++11 起)。</p></blockquote><p>注意这句话：<code class="language-plaintext highlighter-rouge">源和目标单纯地当做指代同一对象的两种不同方式</code></p><p>如何理解呢？</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">myobj</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">){</span>
    <span class="n">myobj</span> <span class="n">d</span> <span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">d</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">int</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>比如这段代码，<code class="language-plaintext highlighter-rouge">myobj</code>只会被构造一次。原因是编译器发现无论进行何种操作，我们返回的都是<code class="language-plaintext highlighter-rouge">d</code>,那么此时可以进行复制消除。也就是返回出去的返回值其实和<code class="language-plaintext highlighter-rouge">d</code>是同一个实例。有点类似于引用的关系。这种就是NRVO。请注意，在这种情况下，<code class="language-plaintext highlighter-rouge">T</code>必须是有可访问的复制或移动构造函数，即使最终没有调用实际的复制或移动构造函数。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">myobj</span> <span class="nf">func</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">){</span>
    <span class="n">myobj</span> <span class="n">d</span> <span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">myobj</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码，一定会进行一次构造，而且一定会有一次拷贝或移动。因为<code class="language-plaintext highlighter-rouge">d</code>一定会被构造，但是具体是返回<code class="language-plaintext highlighter-rouge">d</code>还是一个新的临时对象是完全运行时确定的。编译器无法推测。所以这种情况下，要么是构造+移动，（这里的NRVO是不生效的）要么是构造+构造。（这里的第二次构造临时对象是直接构造在返回值里的。所以RVO是生效的。）</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">myobj</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">bool</span> <span class="n">s</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">myobj</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="n">myobj</span> <span class="n">d</span> <span class="p">{</span><span class="mi">2</span><span class="p">};</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这段代码变得奇怪了。其实是和上一段代码反过来写。但是这次，如果<code class="language-plaintext highlighter-rouge">s</code>是<code class="language-plaintext highlighter-rouge">true</code>， 则RVO生效。所以只有一次构造。</p><p>这一部分可以看一下<a href="https://artificial-mind.net/blog/2021/10/23/return-moves">这篇文章</a></p><h1 id="stringstream">stringstream</h1><h2 id="我们可以使用stringstream方便的在string和其他内置类型之间进行转换"><span class="mr-2">我们可以使用<code class="language-plaintext highlighter-rouge">stringstream</code>方便的在<code class="language-plaintext highlighter-rouge">string</code>和其他内置类型之间进行转换。</span><a href="#我们可以使用stringstream方便的在string和其他内置类型之间进行转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>首先要<code class="language-plaintext highlighter-rouge">#include&lt;sstream&gt;</code><li>然后需要有一个<code class="language-plaintext highlighter-rouge">stringstream</code> 对象<code class="language-plaintext highlighter-rouge">stringstream ss</code><li>我们可以把字符串使用流插入运算符<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>把要转换的字符串插入<code class="language-plaintext highlighter-rouge">stringstream</code> 对象<li>使用流提取运算符<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>把转换完成的对象提取至对应类型的变量内<li>然后记得把<code class="language-plaintext highlighter-rouge">stringstream</code> 对象清空。<li>支持负数自动转换。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">process</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">input</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span> <span class="c1">//stringstream对象</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">input</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">//要转换的东西插入对象</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//提取至我们想要的对象</span>
        <span class="n">ss</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">//清空stringstream对象</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">{</span><span class="s">"1"</span><span class="p">,</span><span class="s">"2"</span><span class="p">,</span><span class="s">"200"</span><span class="p">,</span><span class="s">"-20"</span><span class="p">,</span><span class="s">"-10000"</span><span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="我们还可以使用stringstream进行默认分割此处是根据空格tab和回车换行分割"><span class="mr-2">我们还可以使用stringstream进行默认分割。此处是根据空格，tab和回车换行分割</span><a href="#我们还可以使用stringstream进行默认分割此处是根据空格tab和回车换行分割" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="c1">//字符串放入stringstream对象</span>
    <span class="n">string</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">//储存临时分割对象</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">temp</span><span class="p">){</span> <span class="c1">//直到字符耗尽</span>
        <span class="n">item</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span> <span class="c1">//放入结果数组。</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span><span class="n">item</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><h2 id="我们还可以使用stringstream搭配getline进行自定义分割"><span class="mr-2">我们还可以使用stringstream搭配getline进行自定义分割。</span><a href="#我们还可以使用stringstream搭配getline进行自定义分割" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">&amp;</span> <span class="n">splitter</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">temp</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">temp</span><span class="p">,</span> <span class="n">splitter</span><span class="p">)){</span>
        <span class="n">item</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span><span class="n">item</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><h1 id="stdinitializer_list">std::initializer_list</h1><p>搭配聚合初始化一起看。</p><ul><li><p><strong><code class="language-plaintext highlighter-rouge">initializer_list</code>会在下列情况自动构造：</strong></p><ul><li><p>用花括号初始化器列表列表初始化一个对象，其中对应构造函数接受一个 <code class="language-plaintext highlighter-rouge">std::initializer_list</code> 参数</p><ul><li>这句话的意思就是使用<code class="language-plaintext highlighter-rouge">{}</code>初始化对象并且有匹配<code class="language-plaintext highlighter-rouge">initializer_list</code>的构造函数</ul><li><p>以花括号初始化器列表为赋值的右运算数，或函数调用参数，而对应的赋值运算符/函数接受 <code class="language-plaintext highlighter-rouge">std::initializer_list</code> 参数。</p><ul><li>这句话的意思就是使用<code class="language-plaintext highlighter-rouge">{}</code>初始化对象并且有匹配<code class="language-plaintext highlighter-rouge">initializer_list</code>的函数形参</ul><li><p>绑定花括号初始化器列表到 <code class="language-plaintext highlighter-rouge">auto</code>，包括在范围 for 循环中</p><ul><li><p>这句话的意思就是我们说的 <code class="language-plaintext highlighter-rouge">auto</code>在遇到一个用花括号初始化的对象的时候始终会认为其是一<code class="language-plaintext highlighter-rouge">std::initializer_list</code></p><li><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span> <span class="c1">//t会被推导为initializer_list</span>
      
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">x</span><span class="o">:</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}){</span> <span class="c1">//这里的{1,2,3,4}也是initializer_list</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></table></code></div></div></ul></ul><li><p><strong>在我们使用大括号进行列表初始化的时候，如果我们有显式的符合对应条件的列表初始化构造函数则会优先匹配。</strong></p><ul><li><strong>如果我们使用了大括号进行列表初始化，则编译器会强烈的，尽可能的匹配至形参为<code class="language-plaintext highlighter-rouge">initializer_list</code>的构造函数。如果不匹配则会继续查找其他的构造函数。但凡可以匹配至<code class="language-plaintext highlighter-rouge">initializer_list</code>，编译器就会使用这个。</strong><li><strong><em>在构造函数重载决议期间，只要有任何可能，大括号初始化物就会和带有<code class="language-plaintext highlighter-rouge">std: : initializer_ list</code> 型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表</em></strong><li>！！！！！！这里有个大坑！！！！下面说！！！！</ul><li>注意列表初始化只能使用相同类型或可以被转换为相同类型的参数。<li>匹配<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数必须使用<code class="language-plaintext highlighter-rouge">{}</code><li><p><strong>如果有默认构造函数就算有<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数，但是如果对象构造时入参为空，就算使用了<code class="language-plaintext highlighter-rouge">{}</code>也优先匹配默认构造函数。除非没有默认构造函数。</strong></p><ul><li>语言规定，形如<code class="language-plaintext highlighter-rouge">T obj{}</code>这样的情况下，应该执行默认构造。因为空的大括号表示的是没有实参，而不是空的<code class="language-plaintext highlighter-rouge">initializer_list</code><li>如果确实想要表达出<strong>空的<code class="language-plaintext highlighter-rouge">initializer_list</code></strong>的含义，可以使用<code class="language-plaintext highlighter-rouge">T obj({})</code><li>如果没有默认构造函数，则会匹配<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数。也就是构造对象时就算没有参数要输入也必须加<code class="language-plaintext highlighter-rouge">{}</code></ul><li><code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数拥有高优先级。但是默认构造函数(default constructor)拥有最高优先级</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myclass</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myclass</span><span class="p">(){</span>
          <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"default"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">};</span>
                
        <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span><span class="n">val1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val2</span><span class="p">(</span><span class="n">y</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"cont0"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span><span class="o">:</span><span class="n">val1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val2</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">val3</span><span class="p">(</span><span class="n">z</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"cont1"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">myclass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">val1</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">val2</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">val3</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">s_m</span><span class="p">(</span><span class="n">s</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"cont2"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">myclass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">list</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"initializer_list"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">};</span>

        <span class="n">myclass</span><span class="p">(</span><span class="k">const</span> <span class="n">myclass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"copy const"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">operator</span> <span class="nf">int</span><span class="p">(){</span> <span class="c1">//用户定义转换函数</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"user define conversion"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">val1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">val3</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s_m</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
<span class="p">};</span>




<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myclass</span> <span class="n">obj0</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>		<span class="c1">//initializer_list 因为使用了大括号</span>
    <span class="n">myclass</span> <span class="n">obj1</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>	<span class="c1">//initializer_list 因为使用了大括号</span>
    <span class="n">myclass</span> <span class="n">obj2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span> <span class="s">"abcd"</span><span class="p">};</span><span class="c1">//cont2 虽然使用了大括号但是类型不匹配，所以转而匹配普通的符合条件的构造函数。</span>


    <span class="n">myclass</span> <span class="nf">obj4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>	<span class="c1">//cont0 因为没有使用大括号</span>
    <span class="n">myclass</span> <span class="nf">obj5</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="c1">//cont1 因为没有使用大括号</span>
    <span class="n">myclass</span> <span class="nf">obj6</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="s">"abcd"</span><span class="p">);</span><span class="c1">//cont2 因为没有使用大括号</span>
  
  
  	<span class="n">myclass</span> <span class="n">obj7</span><span class="p">;</span> <span class="c1">//default 注意不能加小括号。那是函数声明。</span>
    <span class="n">myclass</span> <span class="n">obj8</span><span class="p">{};</span> <span class="c1">//default。就算有initializer_list构造函数，但是如果创建对象是无参的也优先匹配默认无参构造函数因为他有最高优先级。除非没有默认无参构造函数。</span>
    <span class="n">myclass</span> <span class="nf">obj9</span><span class="p">({});</span> <span class="c1">//initializer_list。因为小括号套了大括号，表达出空的initializer_list意愿。</span>


    <span class="n">myclass</span> <span class="nf">obj10</span><span class="p">(</span><span class="n">obj7</span><span class="p">);</span> <span class="c1">//copy const 无需解释</span>
    <span class="n">myclass</span> <span class="n">obj11</span><span class="p">{</span><span class="n">obj7</span><span class="p">};</span> <span class="c1">//大坑。先user define conversion，再initializer_list</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>这里就是刚才说的大坑。注意<code class="language-plaintext highlighter-rouge">obj10</code>和<code class="language-plaintext highlighter-rouge">obj11</code>。匹配至<code class="language-plaintext highlighter-rouge">initializer_list</code>的意愿如此强烈，以至于<code class="language-plaintext highlighter-rouge">obj11</code>是先使用了用户定义转换函数转换为<code class="language-plaintext highlighter-rouge">int</code>，然后匹配至<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数。</strong></p><ul><li>特别的，如果<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数被<code class="language-plaintext highlighter-rouge">explicit</code>修饰，则也需遵照其<code class="language-plaintext highlighter-rouge">explicit</code>禁止隐式类型转换的规则。<li><strong>如果构造函数所有参数都有默认值，这个构造函数就成了默认构造函数</strong>。<ul><li>默认构造函数就是要么没有参数，要么所有参数都有默认值。</ul></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">obj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">explicit</span> <span class="n">obj</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span><span class="o">:</span><span class="n">val1</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">val2</span><span class="p">(</span><span class="n">b</span><span class="p">){};</span> <span class="c1">//禁止隐式类型转换。</span>
    <span class="kt">int</span> <span class="n">val1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">val2</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">obj</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">//可以。有默认构造函数。</span>
    <span class="n">obj</span> <span class="n">t2</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">};</span> <span class="c1">//可以，explicit只能限制拷贝初始化。这里是直接初始化。</span>
    <span class="n">obj</span> <span class="n">t3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">};</span> <span class="c1">//不可以，禁止隐式类型转换。</span>
    <span class="n">obj</span> <span class="n">t4</span> <span class="o">=</span> <span class="n">obj</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">};</span> <span class="c1">//可以，显式类型转换。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>注意，当一个类中不仅含有普通构造函数，还含有<code class="language-plaintext highlighter-rouge">initializer_list</code>构造函数，那么这个类在使用<code class="language-plaintext highlighter-rouge">()</code>或<code class="language-plaintext highlighter-rouge">{}</code>初始化的时候会有不同的含义。比如<code class="language-plaintext highlighter-rouge">vector</code>。例子：</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">myobj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">myobj</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
            <span class="n">inner_vec</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span> <span class="c1">//可能会有更优雅的解决方案。</span>
        <span class="p">}</span>
        <span class="n">myobj</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">my_list</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">j</span><span class="o">:</span><span class="n">my_list</span><span class="p">){</span>
                <span class="n">inner_vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">inner_vec</span><span class="p">;</span>
<span class="p">};</span>



<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">myobj</span> <span class="n">ob1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//两个值为3的元素。</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span><span class="n">ob1</span><span class="p">.</span><span class="n">inner_vec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"----------"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">myobj</span> <span class="n">ob2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">};</span> <span class="c1">//把元素1,2,3,4,5,6,7放入vector</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">i</span><span class="o">:</span><span class="n">ob2</span><span class="p">.</span><span class="n">inner_vec</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="原理分析"><span class="mr-2">原理分析</span><a href="#原理分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><p>别他妈瞎研究了。魔法就完了。可以看看它的构造函数长啥样你就知道了。推测是当用<code class="language-plaintext highlighter-rouge">{}</code>进行初始化的时候，首先会创建一个array，并将初始化元素存放起来。然后，调用<code class="language-plaintext highlighter-rouge">initializer_list</code>的构造函数，用array首元素的迭代器和array的元素个数，进行初始化。（https://blog.csdn.net/xiangbaohui/article/details/103609076）。这是汇编层面了。</p><li><p>除此之外，还有如下几个注意点：</p><ul><li><p><code class="language-plaintext highlighter-rouge">initializer_list</code>是一个轻量级的容器类型，内部定义了iterator等容器必需的概念。</p><ul><li><strong>其中有3个成员接口：<code class="language-plaintext highlighter-rouge">size()</code>、<code class="language-plaintext highlighter-rouge">begin()</code>和<code class="language-plaintext highlighter-rouge">end()</code>。遍历时取得的迭代器是只读的，无法修改其中的某一个元素的值；</strong></ul><li><p>对于<code class="language-plaintext highlighter-rouge">initializer_list</code>而言，它可以接收任意长度的初始化列表，但要求元素必须是同种类型T(或可转换为T)；</p><li><p><strong><code class="language-plaintext highlighter-rouge">initializer_list</code>会复制初始化传入的元素至底层的数组。这就是(无编译器优化时)额外开销的来源。但是多个复制的<code class="language-plaintext highlighter-rouge">std::initializer_list</code>共用底层数组空间。</strong></p><ul><li><p>上面这句话比较难理解。<strong>意思是虽然<code class="language-plaintext highlighter-rouge">std::initializer_list</code>会复制初始化传入的元素，但是复制一个 <code class="language-plaintext highlighter-rouge">std::initializer_list</code> 不会复制其底层对象。只会复制其内部的几个指针而已。</strong></p><li><p><strong>再次注意，上面加粗的部分是两句话。</strong></p><ul><li>1：<code class="language-plaintext highlighter-rouge">std::initializer_list</code>会复制初始化传入的元素。所以它是拷贝进去，然后拷贝出去。开销较大。<a href="https://youtu.be/MfFzr9qqPDw?t=951">来自</a><li>2：复制一个 <code class="language-plaintext highlighter-rouge">std::initializer_list</code> 不会复制其底层对象。只会复制其内部的几个指针而已<li><strong>所以<code class="language-plaintext highlighter-rouge">std::initializer_list</code> 一个严重问题之一是元素不适用于仅移动类型。比如<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>。</strong></ul><li><blockquote><p>底层数组是 <code class="language-plaintext highlighter-rouge">const T[N]</code> 类型的<a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion#.E4.B8.B4.E6.97.B6.E9.87.8F.E5.AE.9E.E8.B4.A8.E5.8C.96">临时</a>数组，<strong>其中每个元素都从原始初始化器列表的对应元素复制初始化</strong>（除非窄化转换非法）。底层数组的生存期与任何其他<a href="https://zh.cppreference.com/w/cpp/language/lifetime#.E4.B8.B4.E6.97.B6.E5.AF.B9.E8.B1.A1.E7.9A.84.E7.94.9F.E5.AD.98.E6.9C.9F">临时对象</a>相同，除了从数组初始化 initializer_list 对象会延长数组的生存期，恰如<a href="https://zh.cppreference.com/w/cpp/language/reference_initialization#.E4.B8.B4.E6.97.B6.E9.87.8F.E7.94.9F.E5.AD.98.E6.9C.9F">绑定引用到临时量</a>（有例外，例如对于初始化非静态类成员）。<strong>底层数组可以分配在只读内存。</strong></p></blockquote><li>因此，通过拷贝构造对象与原对象共享列表中的元素空间。也就是说，<code class="language-plaintext highlighter-rouge">initializer_list</code>的内部并没有内含该array的内容，仅仅是拥有指向array的迭代器。如果对这个容器进行拷贝构造或者拷贝赋值的话，array的内容只有一份，但有两份迭代器指向同一片位置。如果对<code class="language-plaintext highlighter-rouge">initializer_list</code>对象copy一个副本，默认是浅拷贝，此时两个对象指向同一个array。这是危险的。</ul></ul><li><p>注意<code class="language-plaintext highlighter-rouge">std::initializer_list</code>底层是常量数组 <code class="language-plaintext highlighter-rouge">const T[N]</code>。所以不能直接修改其存储的元素。返回的引用也是常量引用。迭代器也是常量迭代器。</p></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">func</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">};</span>      <span class="c1">//a与b是局部变量在func返回后会被释放，但是复制的返回值initializer_list不会创建元素副本。而是和临时对象共享空间。所以</span>
                      <span class="c1">//func返回后会被释放，initializer_list内部会存在空悬引用！危险！</span>
                      <span class="c1">//正确的做法可以将返回值改为保存副本的容器，如vector&lt;int&gt;</span>
<span class="p">}</span>

<span class="c1">//注意下面s1、s2、s3和s4均共享元素空间</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"aa"</span><span class="p">,</span> <span class="s">"bb"</span><span class="p">,</span> <span class="s">"cc"</span><span class="p">,</span> <span class="s">"dd"</span> <span class="p">};</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s3</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">s4</span><span class="p">;</span>
<span class="n">s4</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>

<span class="c1">//注意元素会被复制初始化</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">400</span><span class="p">;</span>
<span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mylist</span><span class="p">{</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="p">};</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">mylist</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//200</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//800</span>

</pre></table></code></div></div><h2 id="额外注意initializer_list会导致额外开销但部分可以被编译器优化"><span class="mr-2">额外注意initializer_list会导致额外开销。但部分可以被编译器优化。</span><a href="#额外注意initializer_list会导致额外开销但部分可以被编译器优化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>https://stackoverflow.com/questions/75291691/why-stdinitializer-list-will-cause-overhead-when-use-it-to-initialize-a-vector</p><p>这东西非常看编译器。不建议深入研究。比如Clang就没第二个move。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="n">myobj</span><span class="p">(</span><span class="mi">20</span><span class="p">)};</span>
<span class="cm">/*
const //构建myobj临时对象
mv //这个移动是因为vector有一个构造函数接受std::initializer_list。所以外部的{}花括号初始化器beace-init-list会把它当成std::initializer_list。这个move是为了创建这个std::initializer_list。
mv //这个移动是为了把我们刚才构建好的std::initializer_list值传递给vector的构造函数。可能因为传入的是右值则此时触发移动构造。
copy const //从initializer_list拷贝至容器内。这个是另一个开销。因为std::initializer_list永远复制进来复制出去。所以这个地方不是mv而是copy const。
dest
dest
dest
*/</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">myobj</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">myobj</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">{</span><span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="n">myobj</span><span class="p">(</span><span class="mi">20</span><span class="p">)))},</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span><span class="p">()};</span> <span class="c1">//cpp insight 展开后长成这样。不知道为何有那一大串myobj</span>
</pre></table></code></div></div><ul><li>不使用initializer_list，没有额外开销。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">myobj</span> <span class="nf">obj</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">myobj</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="cm">/*
const //构造myobj对象
copy const //拷贝构造至容器。
dest
dest
*/</span>
</pre></table></code></div></div><p>https://akrzemi1.wordpress.com/2016/07/07/the-cost-of-stdinitializer_list/</p><h1 id="指针a给指针b赋值的意思是将指针a指向的地址赋给指针b">指针A给指针B赋值的意思是将指针A指向的地址赋给指针B</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">digit</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//指针a指向的地址赋给指针b 没有新对象产生所以不会调用拷贝构造。</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">a</span><span class="p">;</span> <span class="c1">//等同于将指针a先解引用（*a = 5），得到指针a指向的的值。然后把这个值取地址(&amp;*a)赋值给指针c。</span>

<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印b储存的地址。也就是b指向的地址。 也就是变量地址。等同于&amp;digit 和&amp;*b</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印b自己的地址。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印b指向的地址的值的地址。等于直接打印指针。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">digit</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印变量地址。等于直接打印指针和&amp;*b</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//解引用b 打印b指向的地址的值。</span>

</pre></table></code></div></div><h1 id="指针加法">指针加法</h1><h2 id="指针直接和数字相加意思是指针当前指向的地址--对应指针类型的大小--数字"><span class="mr-2">指针直接和数字相加：意思是指针当前指向的地址 + 对应指针类型的大小 * 数字。</span><a href="#指针直接和数字相加意思是指针当前指向的地址--对应指针类型的大小--数字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="c1">//分配100字节。</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印p储存的地址。也就是指针指向的地址。是内存首地址。此处输出 0x771410</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//把p指向的地址偏移4位（因为int是4字节）后赋值给y。</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%#x"</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="c1">//打印y储存的地址。也就是指向的地址。此处输出 0x771414</span>
</pre></table></code></div></div><p><strong>也就是说指针直接和数字相加，可以理解为用指针操作数组。加几就是将指针往后移动几位。具体偏移量也就是对应对象的大小*移动位数。</strong></p><h2 id="如果想要指定一个具体的偏移量应该怎么办"><span class="mr-2">如果想要指定一个具体的偏移量应该怎么办？</span><a href="#如果想要指定一个具体的偏移量应该怎么办" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先，可以使用转型将指针转换为对应类型。然后再加数字。</p><p>举例：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">obj</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印p储存的地址。也就是指针指向的地址。是内存首地址。 此处输出 0x771410</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//把p指向的地址偏移1位后赋值给x。因为char是1位。</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span> <span class="c1">//打印x储存的地址。也就是指向的地址。此处输出 0x771411</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//把p指向的地址偏移8位后赋值给x。因为obj是指针类型。8位。</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="c1">//打印y储存的地址。也就是指向的地址。此处输出 0x771418</span>
</pre></table></code></div></div><p><strong>注意：指针类型转换指的是指针转换为对应类型的指针。</strong></p><p><strong>此处不要使用<code class="language-plaintext highlighter-rouge">cout</code></strong></p><p><code class="language-plaintext highlighter-rouge">auto x = (char*)p</code>的意思是把指针<code class="language-plaintext highlighter-rouge">p</code>转为<code class="language-plaintext highlighter-rouge">char*</code>类型的指针。不可以<code class="language-plaintext highlighter-rouge">auto x = (char)p</code>。 这样做的意思是直接转换成了<code class="language-plaintext highlighter-rouge">char</code>。当然，所有的指针都是8字节。记住，指针类型指的是告诉指针应该读取指针指向的地址之后多大的数据。</p><p>怎么理解这个操作呢。我们可以想一下。如果 <code class="language-plaintext highlighter-rouge">a</code>是<code class="language-plaintext highlighter-rouge">int*</code>类型，也就是<code class="language-plaintext highlighter-rouge">int</code>类型指针。意思是指针<code class="language-plaintext highlighter-rouge">a</code>指向的数据是<code class="language-plaintext highlighter-rouge">int</code>，所以需要以<code class="language-plaintext highlighter-rouge">4</code>字节为一段进行读取。也就是一次读取四个字节。那么<code class="language-plaintext highlighter-rouge">a+1</code>其实是对地址进行了<code class="language-plaintext highlighter-rouge">+4</code>操作。因为指针+1的意思是将指针往后移动一个<strong>对象位。也就是指针当前指向的地址 + 对应指针类型的大小（此处为4） * 数量（此处为1）</strong>。但是我们如果想要对地址<code class="language-plaintext highlighter-rouge">+1</code>的话怎么办？我们可以把指针<code class="language-plaintext highlighter-rouge">a</code>转换为<code class="language-plaintext highlighter-rouge">char*</code>类型也就是<code class="language-plaintext highlighter-rouge">char</code>类型指针。而不是<code class="language-plaintext highlighter-rouge">int</code>类型指针。这样相当于告诉编译器，指针<code class="language-plaintext highlighter-rouge">a</code>指向的数据是<code class="language-plaintext highlighter-rouge">char</code>。所以需要以1字节为一段进行读取。也就是一次读取一个字节。所以此时<code class="language-plaintext highlighter-rouge">a+1</code>就是对地址进行了<code class="language-plaintext highlighter-rouge">+1</code>操作。<strong>也就是指针当前指向的地址 + 对应指针类型的大小（此处为1） * 数量（此处为1）。</strong></p><p>移动一个对象位也就是移动的偏移量为对象大小。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">digit</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">digit</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%#x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span>
</pre></table></code></div></div><p><strong>注意！<code class="language-plaintext highlighter-rouge">(char*)a + 1</code>往后移动1位的时候，<code class="language-plaintext highlighter-rouge">(char*)a</code>的意思是把指针a看成指向<code class="language-plaintext highlighter-rouge">char</code>类型的指针（告诉编译器一段是1）。所以<code class="language-plaintext highlighter-rouge">(char*)a + 1</code>不是+2，还是+1。因为指针<code class="language-plaintext highlighter-rouge">a</code>指向的地址根本没变。仅仅是看成了<code class="language-plaintext highlighter-rouge">char</code>类型的指针后+1</strong></p><h1 id="函数入参为指针的时候指针本身会有浅拷贝">函数入参为指针的时候，指针本身会有浅拷贝</h1><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印指针的地址</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">//打印指针指向的变量的地址</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">//打印指针的地址</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//打印指针指向的变量的地址</span>
    <span class="n">func</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
输出：
0x61fe18 //指针地址
0x1b1490 //变量地址
0x61fdf0 //指针地址
0x1b1490 //变量地址
*/</span>

</pre></table></code></div></div><ul><li>我们可以看到，指针入参后，指针本身会发生拷贝。会发生指针给指针赋值。也就是新建了一个指针指向了同一个地址，也就是浅拷贝。所以此时会有两个指针指向同一个地址。一个在<code class="language-plaintext highlighter-rouge">func</code>函数内，一个在<code class="language-plaintext highlighter-rouge">main</code>里。</ul><h1 id="函数指针-和-回调函数">函数指针 和 回调函数</h1><ul><li>函数指针</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//typedef 定义别名</span>
<span class="n">ptr</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">//方法一 函数外直接生成示例并赋值。注意这里typedef之后直接把函数赋值过去即可。</span>
<span class="n">ptr</span> <span class="n">test1</span><span class="p">;</span>
<span class="n">test1</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">//这里是错的。函数体外只能进行全局函数和变量的声明，而无法执行语句或调用函数。</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//不需要传入函数指针了。</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">ptr</span> <span class="n">test</span><span class="p">;</span> <span class="c1">//方法二 函数内进行分离声明</span>
    <span class="n">test</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>回调函数</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//设立callback函数。传入函数指针和参数。</span>
  <span class="err">注意这里如果需要有值传出就要设置为返回</span><span class="kt">int</span>
    <span class="n">ptr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">callback</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>回调函数 c++风格</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">callback</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//回调函数 如果需要返回值就return</span>
    <span class="n">ptr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">test</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="c1">//需要被执行的函数。注意要static。要么就全局。</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">registure</span><span class="p">(){</span> <span class="c1">//注册函数</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
        
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">test</span> <span class="n">Test</span><span class="p">;</span>
    <span class="n">Test</span><span class="p">.</span><span class="n">registure</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>回调函数 c++多态</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">basecase</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testmsg</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">basecase</span><span class="p">(){};</span> <span class="c1">//虽然这里没什么卵用但是还是要记得虚析构，不然无法执行子类析构</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">case1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">basecase</span><span class="p">{</span> <span class="c1">//继承</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">testmsg</span><span class="p">()</span> <span class="k">override</span><span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Case1 coutmsg"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">case2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">basecase</span><span class="p">{</span> <span class="c1">//继承</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">testmsg</span><span class="p">()</span> <span class="k">override</span><span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Case2 coutmsg"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">basecase</span><span class="o">*</span> <span class="n">test1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">case1</span><span class="p">();</span>
    <span class="n">basecase</span><span class="o">*</span> <span class="n">test2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">case2</span><span class="p">();</span>
    <span class="n">test1</span><span class="o">-&gt;</span><span class="n">testmsg</span><span class="p">();</span>
    <span class="n">test2</span><span class="o">-&gt;</span><span class="n">testmsg</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">test1</span><span class="p">;</span> <span class="c1">//养成良好习惯</span>
    <span class="k">delete</span> <span class="n">test2</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="注意c中的类回调函数必须是静态函数或者是全局函数"><span class="mr-2">注意c++中的类回调函数必须是静态函数或者是全局函数。</span><a href="#注意c中的类回调函数必须是静态函数或者是全局函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>一般来说为了封装性质，我们需要把一个函数放入类内。但是调用类成员函数需要加<code class="language-plaintext highlighter-rouge">this</code>，也就是要通过对象调用。但我们不想这样做。于是想舍弃这个<code class="language-plaintext highlighter-rouge">this</code>的话就应该设置为<code class="language-plaintext highlighter-rouge">static</code>静态函数。静态函数就像一个全局函数一样，也就是带作用域的全局函数。满足我们的需求。</p><h2 id="静态函数只能访问静态对象想访问非静态数据怎么办"><span class="mr-2">静态函数只能访问静态对象，想访问非静态数据怎么办？</span><a href="#静态函数只能访问静态对象想访问非静态数据怎么办" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们可以把回调函数的入参设置为一个类对象的指针或者是一个<code class="language-plaintext highlighter-rouge">void*</code>类型的指针。然后通过这个入参来调用。</p><ul><li>例子1：传入类对象指针</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">pThis</span><span class="p">);</span> <span class="c1">//静态函数</span>
    <span class="kt">void</span> <span class="n">b</span><span class="p">(){</span> <span class="c1">//非静态函数</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"b"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>        
<span class="p">};</span> 
 
<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">callback</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">pThis</span><span class="p">)</span> <span class="c1">//入参为类类型指针</span>
<span class="p">{</span>
    <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span> <span class="c1">//静态函数中调用非静态函数</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="n">A</span><span class="o">::</span><span class="n">callback</span><span class="p">(</span><span class="n">aptr</span><span class="p">);</span> <span class="c1">//指针传入回调函数。</span>
    <span class="k">delete</span> <span class="n">aptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>例子2：传入this指针</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">pThis</span><span class="p">);</span> <span class="c1">//静态函数</span>
    <span class="kt">void</span> <span class="n">b</span><span class="p">(){</span> <span class="c1">//非静态函数</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"b"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>       
    <span class="kt">void</span> <span class="nf">in_class</span><span class="p">(){</span>
        <span class="n">callback</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">//直接传入this</span>
    <span class="p">}</span> 
<span class="p">};</span> 
 
<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">callback</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span><span class="n">pThis</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pThis</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span> <span class="c1">//静态函数中调用非静态函数</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="n">aptr</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">aptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>例子3：使用void*类型做为入参后强转。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
    <span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pThis</span><span class="p">);</span> <span class="c1">//静态函数</span>
    <span class="kt">void</span> <span class="n">b</span><span class="p">(){</span> <span class="c1">//非静态函数</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"b"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>       
    <span class="kt">void</span> <span class="nf">in_class</span><span class="p">(){</span>
        <span class="n">callback</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="c1">//直接传入this</span>
    <span class="p">}</span> 
<span class="p">};</span> 
 
<span class="kt">void</span> <span class="n">A</span><span class="o">::</span><span class="n">callback</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pThis</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">((</span><span class="n">A</span><span class="o">*</span><span class="p">)</span><span class="n">pThis</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">();</span> <span class="c1">//静态函数中调用非静态函数。强转</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="n">aptr</span><span class="o">-&gt;</span><span class="n">in_class</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">aptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h1 id="函数类型函数指针类型和函数指针的区别">函数类型，函数指针类型和函数指针的区别</h1><ul><li><strong>函数指针</strong>指向的是函数而非对象。和其他指针类型一样，函数指针指向某种特定类型。<li><strong>函数类型</strong>由它的返回值和参数类型决定，与函数名无关。<li>函数指针类型就是函数指针的类型。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>
</pre></table></code></div></div><p>上述函数类型是：<code class="language-plaintext highlighter-rouge">bool (const string &amp;, const string &amp;)</code>; 函数指针类型是：<code class="language-plaintext highlighter-rouge">bool (*)(const string &amp;, const string &amp;)</code>;</p><p>我们提到过，函数名称在使用时会被自动转换为函数指针。也就是：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">fptr_name</span> <span class="o">=</span> <span class="n">func</span> 
    <span class="err">等价于</span> 
<span class="n">fptr_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span>
</pre></table></code></div></div><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">Func</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// Func是函数类型；</span>
<span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">FuncP</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// FuncP是函数指针类型；</span>
<span class="k">typedef</span> <span class="k">decltype</span><span class="p">(</span><span class="n">Func</span><span class="p">)</span> <span class="n">Func2</span><span class="p">;</span>  <span class="c1">// Func2是函数类型；</span>
<span class="k">typedef</span> <span class="k">decltype</span><span class="p">(</span><span class="n">FuncP</span><span class="p">)</span> <span class="o">*</span><span class="n">Func2P</span><span class="p">;</span> <span class="c1">// Func2P是函数指针类型；</span>
</pre></table></code></div></div><p><strong>注意<code class="language-plaintext highlighter-rouge">decltype(Func)</code>返回的是函数类型，而不是函数指针类型；</strong></p><ul><li>下面两个声明语句是同一个函数，因为编译器会自动的将<code class="language-plaintext highlighter-rouge">Functoin_Type</code> 转换成函数指针类型。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">Functoin_Type</span>  <span class="n">fn</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="n">Funcion_Pointer</span> <span class="n">fn</span><span class="p">);</span>
</pre></table></code></div></div><p>测试：</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">Functoin_Type</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//函数类型</span>
<span class="k">using</span> <span class="n">Funcion_Pointer</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//函数指针类型</span>


<span class="kt">void</span> <span class="nf">callback1</span><span class="p">(</span><span class="n">Functoin_Type</span> <span class="n">callable</span><span class="p">){</span> <span class="c1">//函数类型当形参。自动转换</span>
    <span class="n">callable</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">callback2</span><span class="p">(</span><span class="n">Funcion_Pointer</span> <span class="n">callable</span><span class="p">){</span> <span class="c1">//函数指针当形参。</span>
    <span class="n">callable</span><span class="p">(</span><span class="mf">1.2f</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">testsor</span><span class="p">(</span><span class="kt">float</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"success"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="c1">// test&lt;int(float, int)&gt; obj;</span>
    <span class="c1">// obj.construct(testsor, 2.5f, 234);</span>
    <span class="n">callback1</span><span class="p">(</span><span class="n">testsor</span><span class="p">);</span> <span class="c1">//效果一致</span>
    <span class="n">callback2</span><span class="p">(</span><span class="n">testsor</span><span class="p">);</span> <span class="c1">//效果一致</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>做为返回值时，由于返回的必须是函数指针类型而非函数类型，所以</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">Functoin_Type</span> <span class="nf">ret1</span><span class="p">(){</span>
 <span class="c1">//错误。返回的是函数类型</span>
<span class="p">}</span>
<span class="n">Funcion_Pointer</span> <span class="nf">ret2</span><span class="p">(){</span>
    <span class="c1">//正确。返回的是函数指针类型。</span>
<span class="p">}</span>
</pre></table></code></div></div><p>函数类型有一个非常特殊的地方：<strong>不能使用函数类型声明变量，但是可以把它当做函数的形参（编译器会自动转换）</strong></p><blockquote><p>https://zh.cppreference.com/w/cpp/language/function</p><p>形参列表部分：</p><p>….</p><p>形参列表中的每个函数形参的类型根据下列规则确定：</p><p>…</p><p>3) <strong>如果类型是函数类型<code class="language-plaintext highlighter-rouge"> F</code>，那么它被替换成类型<code class="language-plaintext highlighter-rouge">F</code> 的指针”</strong></p><p>…</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">Functoin_Type</span> <span class="n">f</span> <span class="o">=</span> <span class="n">testsor</span><span class="p">;</span>      <span class="c1">//错误 不可使用函数类型声明变量。</span>
<span class="n">Funcion_Pointer</span> <span class="n">f</span> <span class="o">=</span> <span class="n">testsor</span><span class="p">;</span>    <span class="c1">//正确</span>
</pre></table></code></div></div><ul><li>成员函数指针类型</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">obj</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">){</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">"called"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">is_same</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">obj</span><span class="o">::*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="o">::</span><span class="n">func</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">//true</span>
</pre></table></code></div></div><ul><li><strong>注意，函数指针类型是一个整体。不能把他们分开。比如函数指针<code class="language-plaintext highlighter-rouge">bool (*pf)(int)</code> 的类型是 <code class="language-plaintext highlighter-rouge">bool (*)(int)</code>。在模板接受一个参数的时候，不能把返回值类型<code class="language-plaintext highlighter-rouge">bool</code>扒下来。</strong><li><strong>当然了，如果想，也可以利用成员函数指针类型的方法把他们分开。</strong></ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">R</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">R</span><span class="p">(</span><span class="n">T</span><span class="o">::*</span><span class="n">pf</span><span class="p">)(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">puts</span><span class="p">(</span><span class="n">__PRETTY_FUNCTION__</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//void f(R (T::*)(Args ...)) [with R = bool; T = obj; Args = {int, int}]</span>
</pre></table></code></div></div><p>https://www.jianshu.com/p/6ecfd541ec04</p><p>https://stackoverflow.com/questions/17446220/c-function-types</p><p>https://stackoverflow.com/questions/13233213/can-a-function-type-be-a-class-template-parameter</p><p>https://stackoverflow.com/questions/72926596/type-deduction-for-a-member-function-pointer</p><h1 id="函数引用">函数引用</h1><p>和函数指针，函数名没啥区别。主要遇到的地方是杂记4中的decltype的函数名做为表达式的部分。剩下的看下面的链接即可。</p><p>https://stackoverflow.com/questions/19200513/function-pointer-vs-function-reference</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++%E6%9D%82%E8%AE%B0%20-%203%20-%20Sterben_01&url=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B03%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++%E6%9D%82%E8%AE%B0%20-%203%20-%20Sterben_01&u=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B03%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E6%259D%2582%25E8%25AE%25B03%2F&text=C++%E6%9D%82%E8%AE%B0%20-%203%20-%20Sterben_01" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/memory5/">C++内存管理- 14~15</a><li><a href="/posts/memory6/">C++内存管理- 16</a><li><a href="/posts/vptr/">虚函数表</a><li><a href="/posts/%E6%9D%82%E8%AE%B03/">C++杂记 - 3</a><li><a href="/posts/%E6%9D%82%E8%AE%B06/">C++杂记 - 6</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>设计模式</h3><div class="text-muted small"><p> 设计模式 创建型模式部分 创建型模式主要关注与对象的创建。通常这类模式被用于创建对象的时候。比如抽象工厂被用于创建产品族，原型模式被用来模拟更自由的深拷贝等等。 简单工厂模式 流程 设计一个抽象产品类，它包含一些产品类公共方法的实现; 从抽象产品类中派生出多个具体产品类，如篮球类、足球类、排球类，具体产品类中实现具体产品生产的相关代码; 设计一个工厂类，工厂类中提供一...</p></div></div></a></div><div class="card"> <a href="/posts/%E7%AC%94%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><div class="card-body"> <em class="small" data-ts="1664952900" data-df="YYYY/MM/DD" > 2022/10/05 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>笔试题整理</h3><div class="text-muted small"><p> 笔试题整理 输出下面函数的运行结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class A { public: virtual std::s...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%9D%82%E8%AE%B04/"><div class="card-body"> <em class="small" data-ts="1668927300" data-df="YYYY/MM/DD" > 2022/11/20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++杂记 - 4</h3><div class="text-muted small"><p> 存储类说明符 这是一个被我忽视了的细节。在官方文档中提到了： auto或 (C++11 前)无说明符 - 自动存储期。 这类对象的存储在外围代码块开始时分配，并在结束时解分配。未声明为 static、extern 或 thread_local 的所有局部对象均拥有此存储期。 register - 自动存储期，另提示编译器将此对象置于处理器的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0/" class="btn btn-outline-primary" prompt="上一篇"><p>c++并发编程实战-笔记</p></a> <a href="/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="btn btn-outline-primary" prompt="下一篇"><p>设计模式</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/%E5%BC%80%E5%8F%91/">开发</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a> <a class="post-tag" href="/tags/%E7%89%9B%E5%AE%A2/">牛客</a> <a class="post-tag" href="/tags/%E7%94%9F%E6%B4%BB/">生活</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/Kousaka_Ruri_">Sterben_01</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
