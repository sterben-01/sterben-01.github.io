<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Sterben_01</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2025-10-21T07:54:22-05:00</updated> <author> <name>Sterben_01</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 Sterben_01 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>C++杂记 - 6</title><link href="/posts/%E6%9D%82%E8%AE%B06/" rel="alternate" type="text/html" title="C++杂记 - 6" /><published>2025-04-08T01:55:00-05:00</published> <updated>2025-10-21T07:53:33-05:00</updated> <id>/posts/%E6%9D%82%E8%AE%B06/</id> <content src="/posts/%E6%9D%82%E8%AE%B06/" /> <author> <name>1</name> </author> <category term="笔记" /> <summary> std::has_unique_object_representations 这个东西用于判断是否有一个唯一性的字节表示。啥意思呢？比如我们某个结构体，可能因为不同的内存对齐要求而插入padding。但是这个8字节对齐的结构体和4字节对齐的结构体的实际含义相同，但是底层的二进制表示却不同。这时候我们就说这个对象的字节表示不唯一。说白了，只要是模糊地带，比如：虚函数，填充位，布尔值，架构，编译器相关的这种东西都会导致它返回false。那么它能干什么？他能干的事情主要是帮助我们进行序列化或让我们判断是否可以直接memcpy std::monostate 这个之前居然一直忘了写。 struct monostate { }; 他的定义就这么简单，啥都没有。为啥有这个？ 有意作为 std::variant 中的行为良好的空可选项的单位类型。具体而言，非可默认构造的变体类型可... </summary> </entry> <entry><title>响应式设计</title><link href="/posts/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/" rel="alternate" type="text/html" title="响应式设计" /><published>2024-12-22T00:55:00-06:00</published> <updated>2024-12-22T00:55:00-06:00</updated> <id>/posts/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</id> <content src="/posts/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/" /> <author> <name>1</name> </author> <category term="笔记" /> <summary> 观察者模式到底是谁持有谁？ 在 C++反应式编程书中，开头就有一个范例 int main() { int x[] = { 1,2,3,4,5 }; EvenNumberObservable *t = new EvenNumberObservable(x, 5); IObserver&amp;lt;int&amp;gt;&amp;gt; *xy = new SimpleObserver(); t-&amp;gt;Subscribe(*xy); delete xy; delete t; return 0; } 这种响应式编程的观察者模式我觉得很奇怪吗明明t是observable，是一种数据，xy是observer，是观察者，那么应该是观察者订阅数据，应该是observer-&amp;gt;subscribe(observable)这样的语义更加自然... </summary> </entry> <entry><title>C++杂记 - 5</title><link href="/posts/%E6%9D%82%E8%AE%B05/" rel="alternate" type="text/html" title="C++杂记 - 5" /><published>2023-03-07T00:55:00-06:00</published> <updated>2025-06-04T03:12:32-05:00</updated> <id>/posts/%E6%9D%82%E8%AE%B05/</id> <content src="/posts/%E6%9D%82%E8%AE%B05/" /> <author> <name>1</name> </author> <category term="笔记" /> <summary> std::pmr 多态内存分配器 先回顾一下标准分配器 这一节最好搭配侯捷的标准STL内存分配器来看，这样可以很好帮助理解一些动作的行为。 分配器的核心就是四个步骤： 分配空间（allocate），构造对象（construct），析构对象（destruct），解分配空间（deallocate）。 标准内存分配器就提供了这四个函数。多态内存分配器也提供了这四个函数。 在标准分配器当中，allocate和deallocate对应的全局的::operator new和::operator delete。construct和destruct对应的就是元素的构造和析构 为什么要有多态内存分配器 在没有多态内存分配器的时候，我们面临两个问题。 第一种情况是内存分配器的传播问题。 我们有一个独特的例子： 我们有一个CustomString类，每一个对象接受... </summary> </entry> <entry><title>Modern C++ Design 笔记</title><link href="/posts/ModernC++Design/" rel="alternate" type="text/html" title="Modern C++ Design 笔记" /><published>2023-03-03T00:55:00-06:00</published> <updated>2023-03-03T00:55:00-06:00</updated> <id>/posts/ModernC++Design/</id> <content src="/posts/ModernC++Design/" /> <author> <name>1</name> </author> <category term="笔记" /> <summary> 这本书有点儿老，好多和模板相关的都是脱裤子放屁 第一章 策略类 整个这一章讲的都是策略类的使用。这一部分分散在模板笔记当中。包括设计模式目前没有整理，后续会整理。 核心要点就是让类可以定制化。当把一个类拆分为多个策略的时候，首先要把设计的功能模块抽离。同时要注意寻找正交的策略，也就是彼此之间无交互，可以独立更改的策略。 第二章 技术 2.5 型别对型别的映射 （就是到底用不用SFINAE） 其实就是使用类似enable_if来激活SFINAE。 假设我们需要对myobj对象进行特殊处理，如果使用嵌入式enable_if会是这样： struct myobj{ }; template&amp;lt;typename T, typename U, typename = typename enable_if&amp;lt;is_same&amp;lt;U, myobj&amp;gt;::value&amp;gt;... </summary> </entry> <entry><title>More Effective C++ 笔记</title><link href="/posts/MoreEffectiveC++/" rel="alternate" type="text/html" title="More Effective C++ 笔记" /><published>2023-02-27T00:55:00-06:00</published> <updated>2023-05-14T18:24:39-05:00</updated> <id>/posts/MoreEffectiveC++/</id> <content src="/posts/MoreEffectiveC++/" /> <author> <name>1</name> </author> <category term="笔记" /> <summary> 基础议题 条款4：非必要不提供默认构造 这一点可能和我们之前的认知有差异。但是也是正确的。原因是在语义上或者是设计上，针对某一些类型，如果我们不能提供一个初值来初始化一个对象，那么通过默认构造实例化出来的这个对象会是无意义的。 当然了，还有很多类型是允许有默认对象的，比如空的容器之类的。 所以，如果类型展示出：从无到有生成对象是合理的 的语义，则应该有默认构造。 但是如果类型展示出：必须有外来信息才能生成对象 的语义，则不应该有默认构造。 但是为了表现出这种清晰的语义，会有诸多限制。 当然，需要注意有些函数或容器强调参数或元素必须是可默认构造的。 同时，在继承环境下，如果基类不是可默认构造的，那么就需要显式调用基类的构造。非常头疼。 操作符 条款8 查看memory3 效率 条款17 考虑使用 缓式评估 缓式评估就行copy on writ... </summary> </entry> </feed>
